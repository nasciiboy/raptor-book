@-*- mode: org; -*-
..title    >  Recursive Regexp Raptor
..subtitle >  La Guia Para Construir Un Motor Regexp
..author   >  nasciiboy
..language >  es
..date     >  2016
..tags     >  regex regexp c-prog algorithm
..licence  >  GNU FDL v1.3

«no soy un experto... busque documentacion para aprender y no entendi nada,
despues de mucho esfurzo logre aprender algo y termine por por escribir un
libro»

* Introduccion

  Al igual que muchos de mis predecesores, quede fascinado por la utilidad de
  las expresiones regulares. Asumo que tu interesa este libro por la misma razon
  por la que fue escrito: @e(Descubrir la forma en la que el motor ejecuta las
  expresiones y por que el patron que le has enviado falla, no esta
  implementado, o tiene una sintaxis retorcida).

  Al igual que muchos de mis predecesores, quede fascinado por la utilidad de
  las expresiones regulares.

  Asumo que tines intecion de @e(Descubrir la forma en la que el motor ejecuta
  las expresiones y por que el patron que has probado genera un falla, no esta
  implementado, o tiene una sintaxis retorcida).

  Probablemente no hayas encontrado informacion al respecto o la disponible se
  centra unicamente en los fundamentos matematicos, mismos que el autor de dicho
  material es incapaces de transladar a la realidad con un poco de codigo.

  Has acudido al codigo de alguna implementacion en busca de conocimiento
  practico?  Y... encotraste codigo rebuscado y mistico repartido en infinidad
  de ficheros, llenos de macros, guiones bajos y variables cripticas

  Pues bien, este libro va de construir un @"(motor) de expresiones regulares
  paso a paso, con mucho codigo y poca teoria. Nada de cerraduras de Kleene, NFA
  o DFA. Principalmente por el autor no tiene ni puta idea de matematicas y su
  conocimiento se limita a un par de libros de programacion en lenguaje
  C/C++... ¯\_(ツ)_/¯

  El autor de este libro reconoce que este precedente no genera mucha
  expectativa, pero confia plenamente en la simplesa de su implementacion
  avaladas por cientos de horas al frente de un par de monitores y un par de
  estrellas en github.

  Para afrontar la construccion de este particular motor de expreciones
  regulares escrito en lenguaje C, se asume que tienes conocimientos intermedios
  de programacion, particularmente con algun lenguaje basado en C y que dispones
  de las siguientes herramientas:

  - Un buen compilador de C (GNU GCC o LLVM)

  - GNU Emacs o algun simple "editor" de texto.

  - Un terminal con un interprete de comandos (como bash) o un entrorno que te
    permita enviar ordenes al compilador, ejecutar programas y ver su salida

  - Buena musica. Programar sin musica no vale la pena!

** Sobre el libro y otras cosas

   El libro se divide en cinco secciones:

   - @l(Regexp). Una breve explicacion de lo que son las expresiones regulares y
     su sintaxis

   - En @l[Regexp3 (ASCII)] se muestra como imprementar por completo un motor de
     expresiones regulares basado en el sitema de codificacion de caracteres
     @A(ASCII).

   - @l[Regexp4 (UTF-8)] toma por completo el codigo e ideas expuestas en
     @l[Regexp3 (ASCII)] agregando algunas utilidades que permiten manejar la
     codificacion de caracteres @A(UTF-8)

   - Finalmente la seccion @l(Regexp4) se centra en mejorar el desempeño del
     motor implementando una @"(tabla de instrucciones), se modifican elementos
     de la sintaxis y se egran nuevas caracteristicas.

*** otras cosas

    Este libro asi como todo el codigo que en el aparece esta cubierto por
    licencias con derechos de izquierda (Copileft). Para el libro se utiliza la
    licencia GNU FDL version 1.3. Para el codigo se utiliza la licencia GNU GPL
    version 3.

    El libro deberia estar acompañado por copias de ambas licencias, en caso
    contrario puede optener una copia desde
    @l(https://www.gnu.org/licenses/fdl-1.3.html) y
    @l(https://www.gnu.org/licenses/gpl.html)

    En esencia la licencia del codigo fuente te otorga:

    - la libertad para utilizar el software para cualquier proposito,
    - la libertad para modificar el software para que se adapte a tus necesidades,
    - la libertad para compartir el software con tus amigos y vecinos, y
    - la libertad para compartir los cambios que tu hagas.


    Estas libertades se aplican tambien al libro. Puedes copiar y redistribuir
    el trabajo, con o sin modificaciones y de forma comercial o no comercial.

    Todo aquel que obtenga una copia de este material tiene derecho a conservar
    las mimas condicines de uso, es decir tanto el original como las verciones
    modificadas tendran la misma licencia.

    El codigo de este libro se encuentra alojado en un repositiro @e(git) en
    @l(https://github.com/nasciiboy/raptor-book), @$(git) es un sistema de
    control de versiones, el cual permite llevar un registro de los cambion
    realizados en el proyecto y navegar atraves de ellos. Si en tu sistema
    tienes instalado @$(git) puedes clonar el repositiro con el comando:

    ..src > sh
      git clone https://github.com/nasciiboy/raptor-book.git
    < src..

    Cualquir duda o contrubucion sera bien resivida en el correo electronico
    @l(mailto:nasciiboy@gmail.com).

    El codigo fuente del manual esta escrito con un lenguaje de marcas ligeras
    aun en desorrollo llamado morg. Tambien se ofrecen verciones en html (libre
    de javascrip) y ebook.

*** Raptor Codigo

    El codigo agrega funcionalidades de forma incremental y cada seccion depende
    de la anterior. Por lo general se presenta todo el codigo necesario al
    inicio de cada seccion, para luego examinar los puntos relevantes.

    Dentro del codigo no se incluye ningun comentario que explique la finalidad
    de ninguna declaracion. En principio cuando se escribe codigo con una
    estructura razonable, nombres descriptivos y que puede leerse de forma
    descendente, no se necesita ninguna aclaracion.

    Actualmente la libreria sigue en desarrollo en dos repositorios

    @l(https://github.com/nasciiboy/RecursiveRegexpRaptor) o Regexp3, fue el
    punto inicial de la libreria. Es interesante ver los cambios entre cada
    vercion en particular el codigo inicial.

    @l(https://github.com/nasciiboy/RecursiveRegexpRaptor-4) o Regexp4,
    corresponde a la ruta actual de desarrollo. En su base contiene a Regexp3
    centrandose en ser mas eficiente

    Bien podrias acudir directamente al codigo de ambas versiones y tomar este
    libro como una vercion super explicita de su funcionamiento.

* RegExp

  Una Expresion regular es una secuencia de caracteres que define un patron de
  busqueda. Son mejor conocidas por las contracciones @e(RegExp), @e(RegEx) y
  @c(RE) del original @q(Regular Expressions) en ingles. La aplicacion principal
  de las @e(RegExp) es localizar patrones para filtrar informacion, validar
  datos y manipular texto.

  Se originaron en 1956, cuando el matematico Stephen Kleene describio los
  @e(lenguajes regulares) utilizanda su propia notacion matematica llamada
  @e(conjuntos regulares).

  En 1968, Ken Thompson pionero de Unix publico el articulo «Regular Expression
  Search Algorith» que contenia la descripcion tecnica de un compilador de
  expresiones regulares junto con codigo en Algol-60. Mas tarde implemento por
  primera vez en un programa informatico el uso de expresiones regulares con la
  notacion de Kleene para el editor de texto @$(QED). El objetivo era que el
  usuario pudiese hacer comparacion de patrones avanzados en archivos de
  texto. En 1969 esta capacidad fue incorporada al editor @$(ed) (creacion de
  Thompson), en forma del comando @c(g/re/p) que proviene de «globally/regular
  expresion/print» y significa «@e(g)lobally search a @e(r)egular @e(e)xpression
  and @e(p)rint» (has una busqueda global para las lineas que coincidan con la
  expresion regular e imprimelas)

  El comando @c(g/re/p) dio como resultado el programa independiente @$(grep)
  (Tambien obra de Thompson), lanzado en la cuarta edicion de Unix en 1973. Sin
  embargo, grep no tenia una completa aplicacion de expresiones regulares y no
  fue hasta el año 1979, en la septima edicion de Unix que fuimos bendesidos con
  @$(egrep) (extended grep) de Alfred Aho. El cual podia traducir cualquier
  expresion regular a su correspondiente algoritmo DFA.

  Alrededor de la misma epoca en la que Thompson desarrollo QED, un grupo de
  investigadores, implemento una herramienta basada en Expresiones Regulares
  para el analisis lexico en el diseño de compiladores.

  En la decada de los 70's muchas variaciones de las regexp implementadas en
  Unix se incorporaron a programas como @$(vi), @$(lex), @$(sed), @$(awk),
  @$(expr), @$(emacs), etc.

  en la decada de los 80's, las expresiones regulares mas complejas aparecieron
  en el lerguaje de programacio @e(Perl), derivadas de la biblioteca regexp de
  Henry Spencer (1986).

  Inevitablemente la Jihad RegExp se extendio a la mayoria de lenguajes de
  programacion, shell's, bases de datos, servidores web, editores de texto,
  navegadores de ficheros y un variado numero de programas en forma de pequeñas
  utilidades.

** Syntaxis RegExp

   Las Regexp estan formadas por una serie de constructores que pueden
   convinarse libremente entre si. Como no podria ser de otra forma los
   constructores no son mas que una serie de caracteres (numeros, letras o
   signos de puntuacion) a los que se le atribuye un comportaminto especifico.

   La sintaxis de los constructores puede variar de un motor/programa/lenguaje a
   otro, sin embargo por lo general se siguen las siguientes convenciones:

*** Caracter

    Se consideran caracteres todos los numeros, letras o signos de puntuacion
    cuyo unico significado es la coincidencia del propio caracter.

    El motor evalua los caracteres de forma secuencial uno a uno.

    Un patron compuesto unicamente por caracteres solo puede coincidir si cada
    uno de sus elementos esta precente en el texto de busqueda, de forma
    secuencial. En terminos simples esto significa que cualquier palabra esta
    conformada por sus constructores @e(caracter)

    ..example >
      "palabra" ==  'p', 'a', 'l', 'a', 'b', 'r', 'a'
    < example..

    De forma explicita el patron de busqueda @c(palabra) dice al motor lo
    siguiente: Busca el constructor de tipo caracter @c(p), si lo encuentras
    avanca una posicion dentro del texto de busqueda y comparalo con el
    constructor que de tipo caracater @c(a), si lo encuertras avanza una
    posicion dentro del texto de busqueda y compararlo con el constructor de
    tipo caracter @c(l), ..., si llegas hasta el constructor tipo caracter @c(a)
    el patron a sido localizado, de otra forma no esta precente.

*** Conjunto

    El constructor @e(Conjunto) permite agrupar una serie de constructores
    caracter para compararlos con una posicion especifica del texto de busqueda.

    Los constructores de delimitan dentro de los signos '[' y ']'. La expresion:

    ..example >
      "199[56789]"
    < example..

    le indica lo siguiente al motor: Busca el constructor de tipo caracter
    @c(1), si lo encuentras avanca una posicion dentro del texto de busqueda y
    comparalo con el constructor que de tipo caracater @c(9), si lo encuertras
    avanza una posicion dentro del texto de busqueda y compararlo con el
    constructor de tipo caracter @c(9), si lo encuentras avanza una posicion
    dentro del texto de busqueda y comparalo con alguno de estos constructores
    de tipo caracter @c(5), @c(6), @c(7), @c(8) o @c(9), Si el caracter del
    texto  coincide con alguno  de estos caracteres se ha encontrado el patron,
    de otro modo la busqueda ha fallado.

    Es decir el patron @c(199[56789]) coincide con las siguientes cadenas de
    caracteres: "1995","1996" ,"1997" ,"1998" o "1999"

*** Rangos

    Un conjunto agrupa una serie de constructores caracter, pues bien cuando
    dichos miembros del conjunto forman una secuencia alfabetica (de @c(a) a
    @c(z), o de @c(A) a @c(Z)) o numerica (de @c(0) a @c(9)) es posible abreviar
    la exprecion uniendo el elemento inicial de la secuencia con el final
    mediante el signo '-', por ejemplo la exprecion @c(199[56789]) podria
    es equivalente a la exprecion:

    ..example >
      "199[5-9]"
    < example..

    la exprecion

    ..example >
      "Unidad-[ABCDEFGHIJK]"
    < example..

    es equivalente a

    ..example >
      "Unidad-[A-K]"
    < example..

    el signo @c(-) no tiene efecto fuera del constructor agrupacion, por lo que
    se interpreta como un simple caracter @c(-)

*** Conjunto inverso

    La utlima facilidad que proporciona el constructor conjunto consiste en
    coincidir, solo si ninguno de sus elementos esta precente en el texto de
    busqueda, es decir @e(invierte) el resultado de la busqueda. La forma de
    indicar al motor este comportamiento es colocar el signo @c(^) como primer
    elemento del constructor conjunto. Por ejemplo la expresion

    ..example >
      "<[^>]>"
    < example..

    Es util para localizar etiquetas @e(xml) de un solo caracter por ejemplo
    @c(<A>), @c(<B>), @c(<C>), @c(<D>), @c(<E>), etc.

*** Punto

    El construtor punto representado por el signo '.' se utiliza para realizar
    una coincidencia con cualquier caracter presente en el texto de
    busqueda. Generalmnte se suele excluir el caracter '\n' (salto de linea).,
    la razon de esto es meramente practica aunque conceptualmente no existe un
    motivo para ello.

    Este constructor punto no tiene efecto dentro de un conjunto, dentro de este
    se evalua como @e(el caracter) @c(.), principalmente por que no tiene
    sentido que un conjunto coincida @e(con cualquier).

*** Cuantificación

    Por defecto el motor asume que cualquier constructor este presente almenos
    una vez, no obstante es posible especificar cuantas veses consecutivas puede
    aparecer un constructor. Para esto se hace uso de los @e(cuantificadores)
    que mas que un @"(constructor), son una caracteristica de un constructor.

    Los cuantificadores se colocan justo al final del contructor al que ha de
    aplicarse (a la derecha). @e(El constructor alternacion, que veremos mas
    adelante no es compatible con los cuantificadores)

    - @c(?) ::

      El constructor puede aparecer de cero a una vez. Por ejemplo, @c(ob?scuro) se
      corresponde con @c(oscuro) y @c(obscuro).

    - @c(+) ::

      El elemento debe aparecer al menos una vez. Por ejemplo, @c(ho+la) describe
      el patron infinito @c(hola), @c(hoola), @c(hooola), @c(hoooola), ...,

    - @c(*) ::

      El elemento puede aparecer cero, una, o más veces. Por ejemplo, @c(0*42) se
      corresponde con @c(42), @c(042), @c(0042), @c(00042), ...,

    - @c({n}) ::

      El elemento puede aparecer exactamente @m(n) veces. Por ejemplo @c([0-9]{3})
      se corresponden con cualquier cifra de tres digitos como @c(007), @c(747),
      @c(777), ...,

    - @c({a,b}) ::

      El elemento debe aparecer un minimo de @m(a) veces y un maximo de @m(b)
      veces.

*** Alternación

    Como ya vimos la agrupacion permite la busqueda de mas de un constructor
    caracter para una posicion especifica. Pues bien La alternacion se comporta
    de forma idetica, solo que en lugar de manejar constructores caracter maneja
    expreciones delimitadas una de otro por el signo @c(|):

    ..example >
      exp1|exp2|exp3|...
    < example..

    en este caso el termino @e(exprecion) se refiere a una regexp en si. La
    busqueda de expresiones se realiza de forma secuencial, de izquierda a
    derecha hasta localizar alguna expresion o hasta agotar las
    alternativas. Por ejemplo

    ..example >
      "Raptor|T Rex|Triceratops"
    < example..

    genera los patrones de busqueda @c(Raptor), @c(T Rex) y @c(Triceratops)

    Como ya se menciono en apartado anterior, cuantificadores no se aplican a
    este constructor. Para cuantificar las arternativas deben encontrarse dentro
    de una agrupacion.

*** Agrupación

    Una agrupacion permite definir el ámbito y la precedencia de los demás
    constructores. Las agrupaciones se delimitan dentro de las signos @c[(] y
    @c[)]. Por ejemplo:

    ..example >
      "(p|m)adre"
    < example..

    es lo mismo que

    ..example >
      "padre|madre"
    < example..

    y

    ..example >
      "(des)?amor"
    < example..

    se corresponde con @c(amor) y con @c(desamor).

*** Metacaracteres

    El motor interpreta los signos @c[(], @c[)], @c(|), @c([), @c(]), @c(+),
    etc. como delimitadores de algunos constructores. Como hacer para buscar
    estos signos como simples caracteres? Podriamos colocarlos detro de un
    conjuto de caracteres, asi:

    ..example >
      "[()|+]"
    < example..

    ohhh, y

    ..example >
      "[]]"
    < example..

    cual @c(]) marca el limite del conjunto, el primero o el segundo?. Para
    evitar casos ambiguos se hace uso del constructor @e(metacaracter) que
    despoja de su significado @e(especial) a los signos antes mencionados.

    El constructor metacaracter suele estar formado pos dos signos, el signo que
    indica que se trata de un metacaracter y el signo al que se aplica.
    Generamente se utiliza @c(\) como indicador. Para interpreter correctamente
    el alcance del conjunto anterior deberiamos expresarlo de esta forma

    ..example >
      "[\]]"
    < example..

    Y si se aplica @c(\) a un caracter sin significado especial, por ejemplo a
    @c(d)?. En estos casos la exprecion

    ..example >
      "\d"
    < example..

    seria interpretada de dos formas posibles. Primero el metacaracter @c(d), es
    el caracter en si, es decir una simple @c(d). La otra opcion seria dotar de
    un significado especial a determinados caracteres, en este caso podria ser:
    @c(d) significa @e(cualquier digito), o expresado de otra forma @c(\d) es
    equivalente a

    ..example >
      [0-9]
    < example..

    Esta logica puede aplicarse de forma arbitraria y depende unicamente de la
    especificacion del motor.

    Ademas de esto el podemos utilizar metacaracteres para representar a signos
    no impribibles como pueden ser nueva linea, tabulador, retroceso, campana,
    etc. Este aspecto es particularmente delicado, dependiendo del lenguaje en
    que este implementado el motor. Por ejemplo el lenguaje C utiliza @c(\) como
    metacaracter, a menos que deseemos llenar la exprecion con @c(\\) deberiamos
    utilizar otro signo.

*** Modiicadores

    Aunque no se definen como tal, existen formas de alterar la forma en que se
    aplica la expresion a texto. Principalmente se utilizan dos:

    - ^ :: colocar este signo @e(al inicio) de la expresion le indica al motor:
           la busqueda solo sera valida si el patron se encuentra al inicio del
           texto.

    - $ :: colocar este signo @e(al final) de la expresion indica: la busqueda
           solo sera valida si el patron se encuentra al final del texto.


    ambos modificadores pueden combinarse dentro de la expresion, indicando: la
    busqueda sera valida si el patron inicia el la posicion inicial del texto y
    finaliza en la ultima posicion.

    Los modificadores al igual que los metacaracteres dependen unicamente de lo
    que especifique el motor.

* Regexp3 (ASCII)

  Asi que, te has decidido a leer este libro y tienes la suficiente experiencia
  como para escribir compilar y ejecutar un programa en C.

  No voy a decirte el sistema bajo el que deberias programar, el editor, IDE,
  compilador, shell, mapeo de teclado, etc. No obstante te presento la
  configuracion que utilizo y el porque:

  - Como sistema operativo GNU/linux. No fue hasta que llegue a la distribucion
    @e(debian), que conoci lo que era la informatica, lo util de los
    repositorios de software y la existencia del movimiento @e(software libre).

  - Como entorno de escritorio Gnome Shell. Es simple, sobrio, bonito y eficaz.

  - Donde hay un prompt hay felicidad! No hay mejor herramienta para interactuer
    con el sistema, que una terminal.

    En particular me gusta Konsole, parte del proyecto KDE. Tiene pestañas
    multiples, puede desabilitarse el menu y la barra de despalazamiento, para
    ocupar la pantalla completa sin distracciones, ademas la configuracion del
    teclado es muy flexible.

  - Quien hace aparecer el prompt es fish, un interpre de comandos con colorines
    y un sistema de autocompletado fantanstico.

  - Para compilar programas C, GCC el compilador de GNU. Ademas suelo pedir una
    segunda opinion al compilador clang (LLVM).

  - Como sistema de control de versiones git, con conocer los comandos basicos
    es mas que suficiente.

  - Los sonidos del mundo son muy aburridos. moc (music on conlose) se encarga
    del amenizar el ambiente con buena musica.

  - Finalmente, el interprete de Emacs Lisp @e(GNU Emacs), que tambien suelo
    utilizar como editor (risas). En serio no te compliques con fastidiosos IDEs
    llenos de botones, menus y mierdas graficas. Todo es mejor en texto plano!


  Adicional a esto el mapeo de teclado es programmer dvorak (con
  modificaciones) y una configuracion minima de dos monitores.

** Mr. Raptor

   ..quote >
     Disponer del codigo fuente de un programa no garantiza que seamos capaces de
     compreder su funcionamiento. Si para entender un proyecto es necesario
     asistir a su construccion y tener presente todos los detalles ocultos de su
     funcinamiento, probablemente cuando los desarrolles pasen a otro proyecto
     nadie este dispuesto (o sea capaz) de continuar con el desarrollo.

     Por ello no es suficiente disponer del codigo, ademas debe ser simple y
     directo, para que otros sean capaces de comprender su funcionamiento. Lograr
     este objetivo inicia dar nombres claros y concisos
   < quote..

   Pues bueno, despues de esto tendre que expicar de donde surge el nombre del
   motor @"(Recurisve Regexp Raptor). La primer vercion funcional de la libreria
   por motivos obvios simplemente se le llamaba @f(regexp). Aunque este nombre
   es consiso, ya no estaba disponible. Como la libreria optiene memoria por
   medio de recursividad, era necesario incluir esta caracteristica al
   nombre. En aquel momento tenia la impresion que el codigo era absurdamente
   rapido, hay es donde surgio el @e(Raptor)

   Que el encabezado de la libreria fuese @f(RecursiveRegexpRaptor.h) teniendo
   que escribir esto

   ..src > c
     #include "RecursiveRegexpRaptor.h"
   < src..

   en cada lugar donde se utilizar, era un poco exesivo, mas si se tiene en
   cuenta los nombres de la libreria estandar de C @c(stdio), @c(ctype), ...,
   @c(stdlib). Por ello el nombre reducido es @c(regexp3) y el codigo se
   encuentra repartido en dos ficheros @c(regexp3.h) y @c(regexp3.c)

   Una ves desvelado el misterio demos paso a la construccion.

** El truco

   He tratado de mantener el codigo lo mas simple y compacto posible, centrando
   la atencion en los puntos importantes. En la practica esto repercute en tres
   puntos a cosiderar:

   - No se utiliza la sintaxis estadar, tampoco la que maneja Perl. En su lugar
     se opta por la que es mas facil de interpretar.

   - El motor asume que la expresion que resive tiene una sintaxis correcta.

     En la practica es igual de complejo constuir una programa encargado solo de
     verificar y mostrar los errores de sintaxis, a uno que solo simplemente
     busca la exprecion. Sin demasiado esfuerzo, se eligio la ultima opcion,
     ademas, se esta contruyendo un motor de expreciones @e(en C), si los datos
     de entrada que recive son inapropiados, lo minimo que mereces es un ciclo
     de ejecucion infinito.

   - El manejo de memoria no se realiza de forma @"(explicita), en su lugar se
     acude a la recursividad.


   En cualquer punto podras ser capas de reforsar el codigo si asi lo
   deseas. Sin embargo te recomiendo esperar hasta que el programa realice todas
   las funciones que necesites.

** La Sintaxis

   La vercion final de @c(regexp3) (version ascii) soporta los siguientes
   constructores

   - Alternacion @c(|)

   - Agrupacion @c[()]. Pala "capturar" la coincidencia del patron dentro de la
     agrupacion con lo encotrado en el texto, se utiliza @c(<>)

   - Los cuantificadores son

     - @c(?) cero o una vez

     - @c(+) una o mas veces

     - @c(*) cero o mas veces

     - @c({n}) n veces

     - @c({a,b}) un rango de veces

   - Los conjuntos estan dentro de corchetes @c([]).

     - Para negar un conjunto el primer elemento debe ser @c(^)

   - Lon rangos se unien con el signo @c(-). No es necesario que esten dentro de
     un conjunto

   - punto @'c(.). Un punto dentro de un conjunto, no pierde su significado.

   - el metacaracter se conforma de dos caracteres el signo @c(:) y el metacaracter.

   - Los modificadores de comportamiento se aplican de forma global o local y se
     especifican con el signo @c(#) seguido por los modificadores.

     Para modificar el comportamiento @e(global) de la exprecion, el modificador
     se coloca al inicio de la exprecion antes de cualquier constructor.

     Para modificar de forma local un constructor se colocar @c(#) al final del
     constructor. Si se aplica un cuantificador al constructor, el modificador
     se especifica despues de este.

** El algoritmo
*** Como interpretar la regexp

    En el titulo de esta seccion utilizo la palabara @e(interpretar) (aunque
    tambien serian validos @e(ejecutar) o @e(evaluar)) por que la regexp es
    una serie de instrucciones detalladas no ambiguas para un interprete
    (@e(motor)) de expreciones regulares.

    Los constructores son patrones de busqueda por si mismos y una exprecion
    podria estar formada por un solo constructor... ehhh, un cuantificador?
    Bueno los cuantificadores en realidad no son constructores, son una
    propiedad de estos, aunque tambien podrian considerarse como una indicacion
    para el motor regexp. Pues bien, los constructores pueden convinarse y
    agruparse como parte de una exprecion mas grande segun las reglas y la
    posicion relativa de cada constructor.

    En principio un motor regexp solo necesita dos entradas, la regexp y la
    cadena de texto en la que se efectua la busqueda. Una vez tiene estos dos
    datos, @e(optiene) el primer constructor de la regexp y compara todas sus
    combinaciones posibles en la cadena, tomando como posicion de referencia el
    primer caracter. Si todas las combinaciones fallan, el motor mueve la
    posicion de referencia al segundo caracter y de nuevo prueba todas las
    combinaciones del primer constructor. Cuando el primer constructor coincide
    con la cadena el motor @e(camina) atraves de ambos (regexp y cadena),
    optiene el siguiente constructor y lo compara con la nueva posicion de la
    cadena. Si el constructor no coincide, el motor vuelve al
    ultimo recorrido completo e intenta (si existe) una combinacion diferente,
    de lo contrario prueva en la siguiente posicion de la cadena e inicia de
    nuevo la comparacion apartir del primer constructor.

    Si se llega al final de la cadena sin antes agotar los constructores
    signica que el patron no esta precente. Si se agotan los contructores el
    motor informa la coincidencia.

    Es importante resaltar que la busqueda tanto en la exprecion como en la
    cadena siempre procede de izquierda a derecha, es decir siempre se regeresa
    la coincidencia mas a la izquierda de la primer combinacion que coincida con
    la regexp.

    con estos parrafos tenemos suficiente material para escribir el seudocodigo
    (no es verdad, pero de una forma unilateral y con el problema
    resuelto... es mas que suficiente). pero, antes de escribir este seudocodigo
    remarco estos puntos clave

    1. Se analiza el texto y la regexp de izquierda a derecha

    2. Se optiene el primer constructor de la regexp y se prueban todas sus
       combinaciones en la posicion actual de la cadena

    3. Si se encuentra algun patron se avanza atraves de ambos, exprecion y
       cadena

    4. Si el constructor no se encuenta en la cadena, el motor vuelve al ultimo
       recorrido completo e intenta otra ruta


    El punto dos, da a entender que un constructor tiene varias combinaciones
    posibles. A saber los constructores son @e(agrupacion), @e(alternacion),
    @e(conjunto), @e(rago), @e(punto), @e(metacaracter) y @e(caracter). Veamos
    uno a uno:

    Una @e(agrupacion) contiene un numero indeterminado de combinaciones
    posibles, ya que puede @"(agrupar) a cualquier otro constructor incluidas
    otras agrupaciones.

    Una @e(alternacion) maneja la posibilidad de recorrer multiples @e(rutas) de
    ejecucion, cada una de estas puede estar formada por expreciones de
    complejidad arbitraria.

    Los @e(conjuntos) solo pueden contener @e(rangos), @e(metacaracteres) y
    @c(caracteres). Estos ultimos incluido el constructor @e(punto) no pueden
    contener a ningun otro constructor.

    El @e(punto) puede coincidir con cualquier caracter, los @e(rangos) con un
    rango de caracteres y las coincidencias aplicables a los @e(metacarcteres)
    dependen de la implementacion del motor

    finalmente el @e(caracter) es el inico elemento con una unica combinacion
    posible, el mismo.

    Esto nos lleva a la conclusion de que si el constructor que optenemos es
    distinto a caracter en efecto, tendremos que averiguar todas sus posibles
    combinaciones, asta reducirlos a valores que pueden compararse en la cadena

    el tercer punto nos dice que el motor avanza atravez de exprecion y cadena,
    es decir, si el constructor coincide con @m(n) caracteres de la cadena, el
    el siguiente construtor se compara @m(n) caracteres adelante la la
    comparacion anterior. Imaginemos que para el ciclo actual de busquda los
    construtrores y las cadena se corresponden correctamente

    ..sketch >
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲       ▲▲     ▲▲         ▲▲     ▲
                  │Α     Ω││Α   Ω││Α       Ω││Α   Ω│
      constructor [ cons1 ][cons2][  cons3  ][cons4]...
    < sketch..

    Utilizo @e(Α) (Alfa) como punto el punto de inicio contra el que se compara
    el constructor y @e(Ω) (Omega) para representar el punto final que abarca
    lon @m(n) caracteres de la coincidencia. Como puede verse practicamente cada
    constructor desconoce la labor del anterior, son independientes uno de
    otro. Es el motor quien coordina que posicion de la cadena se compara con
    que constructor, esto como dice el punto uno siempre ocurre de izquierda a
    derecha.

    finalmente el punto cuatro dice que si la comparacion falla, el motor vuelve
    al ultimo recorrido completo e intenta @e(otra ruta). Esto da a entender que
    el motor lleva un registro de posicion y constructores de cada comparacion y
    que debe conocer esas otras rutas de ejecucion. Veamos con mas detenimiento
    este punto.

    Si tenemos una serie de constructores caracteres y la coincidencia del
    ultimo constructor caracter falla ('x' == '5')

    ..sketch >
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲▲▲▲▲△
                  ││││││
      constructor 01234x6789
    < sketch..

    cual seria esta ultima ruta de ejecucion completa? Correcto, niguna esta
    ruta de ejecucion es la exprecion @c(01234x6789) regresar al anterior
    constructor @c('4') no tiene sentido, pues para completar esta ruta de
    ejecucion tien que cruzar forzosamente por el constructor @c('x').

    veamos otro caso

    ..sketch >
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲▲▲▲▲△
                  ││││││
      constructor 0││3│x6789
                   ││ │
                   ││[456789]
                  (12)
    < sketch..

    en este caso la regexp es @c<0(12)[456789]x6789> cual seria esta ultima ruta
    de ejecucion completa? Correcto, niguna. Al igual que la exprecion anterior
    solo existe @e(una ruta) de ejecucion. los constructores @e(conjuntos) y
    @e(agrupacion) por si mismos solo tiene una ruta de ejecucion, al comparar
    estos consructores con la misma posicion de la cadena genera siempre el
    mismo resultado. Asi que tampoco hay una ruta completa a la cual regresar,
    un momento... no habia un constructor de @e(rutas) (alternacion)?

    Cuando el motor @"(ve) la exprecion @c(1234x|12345), se dice a si mismo, uhh
    tengo un par de rutas @c(1234x) y @c(12345), la posicion de inicio en la
    cadena para este ciclo corresponde al caracter '0', debo anotar esto por si
    la primer ruta falla, y hay que probar con la segunda.

    la primer ruta de ejecucion seria

    ..sketch >
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲▲▲▲▲△
                  ││││││
      constructor 01234x
    < sketch..

    falla al comparar el quinto constructor. luego el motor pueba con la segunda
    ruta de ejecucion, desde el mismo punto de inicio en la cadena para la ruta
    anterior, el caracter @c('0')

    ..sketch >
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲▲▲▲▲▲
                  ││││││
      constructor 012345
    < sketch..

    en esta ocacion, todos los constructores miembro del constructor @"(ruta)
    (@e(alternacion)) coinciden, luego entonces el consturcor es correcto. Como
    no existen mas constructores en la exprecion @c(1234x|12345) el motor
    informa de la coincidecia.

    Esto implica que el motor optener los constructores de la exprecion
    @c(1234x|12345) de la siguiente forma

    ..sketch >
      regexp   "1234x|12345"
      motor   [RUTA1] [RUTA2]
    < sketch..

    como antes se menciono, los constructores @"(ruta) pueden estar compuestos
    de cualquier tipo de constructor. Para este caso esto implica optener los
    constructores miembro de la ruta en ejecucion, para luego evaluar todas las
    combinaciones posibles de izquierda a derecha. para la primer ruta estos
    constructores serian una sucecion de constructores caracter: '1', '2', '3',
    '4' y 'x'. Para la segunda ruta de ejecucion serian '1', '2', '3', '4' y
    '5'. Como veria el motor la exprecion @c(1234x)

    ..sketch >
      regexp   "1234x"
      motor    [RUTA1]
    < sketch..

    La primer accion del motor es averiguar cuantas rutas de ejecucion existen,
    luego almacenar el punto de inicio de cada ruta y si esta falla, intentar
    con la siguiente alternativa. Por esto es que aunque no se indique de forma
    explicita, simpre existe almenos una ruta de ejecucion, es decir la
    exprecion en si misma.

    Como ve el motor a la exprecion @c[1234(x|5)]

    ..sketch >
      regexp   "1234(x|5)"
      motor    [  RUTA1  ]
    < sketch..

    En principio es solo una ruta de ejecucion, que esta formada por los los
    constructores

    ..sketch >
      regexp   "1234(x|5)"
      motor    [        RUTA1         ]
               [c][c][c][c][agrupacion]
                1  2  3  4    (x|5)
    < sketch..

    cuando el motor optiene los constructores de la @e(RUTA1), optiene la
    secuencia, constructores caracter, caracter, caracter, caracter y
    agrupacion. Como los constructores caracater solo pueden coincidir con un
    solo caracter los compara @e(directamente) en la cadena, si el primero
    coincide avanza atraves de cada constructor y de la cadena, hasta llegar al
    constructor @e(agrupacion). Este ultimo puede contener cualquier tipo de
    constructor asi que veamos el proceder del motor

    ..sketch >
      regexp   "(x|5)"
      motor    [RUTA1][RUTA2]
    < sketch..

    cuando el motor analiza una agrupacion, el primero que debe averiguar es
    conocer el numero de rutas de ejecucion posible... y luego optener los
    constructores de cada ruta y asta completar una ruta o agotar todas las
    opciones.

*** Diagrama

    En resumen este es el procedimiento que debe ejecutar el motor para optener
    uno a uno los constructores de la exprecion

    ..sketch >
                         char * re
                             │◀─────────────────────────────┐
                             ▼                              │
                ┌────────────────────────────┐              │
                │almacenar el punto de inicio│              │
                └────────────────────────────┘              │
                             │                              │
                             ▼                              │
               ┌──────────────────────────────┐             │
               │Optener las ruta de ejecucion │             │
               └──────────────────────────────┘             │
                             │                              │
                             ▼                              │
                 ┌─────────────────────────┐                │
                 │obtener los constructores│                │
                 └─────────────────────────┘                │
                             │                              │
          ┌────────┬─────────┼───────────┬──────────┐       │
          │        │         │           │          │       │
          ▼        ▼         ▼           ▼          ▼       │
      ┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐ │
      │conjunto││punto││metacaracter││caracter││agrupacion│ │
      └────────┘└─────┘└────────────┘└────────┘└──────────┘ │
          │        │         │           │          │       │
          └────────┴─────────┼───────────┘          └───────┘
                             │
                             ▼
                    ┌──────────────────┐
                    │buscar constructor│
                    └──────────────────┘
    < sketch..

    a medida que optiene cada constructor, el motor compara y coordina el avance
    (o retroceso) atraves de cadena y exprecion (constructores).

** codigo
*** interfaz

    En el lenguaje de programacion C, las funciones dividen un programa extenso
    en pequeños fragmentos que realizan tareas concretas, y dan la posibilidad
    de construir sobre lo que otros ya han hecho (como en el sotfware libre).

    En esencia y segun los gurus mas expertos una buena funcion debe cumplir
    almenos estos principios

    - debe hacer una sola cosa
    - tener un nombre que describa su funcion
    - no necesitar mas de tres tres argumentos, de preferencia ninguno.


    En realidad la lista es mas extensa y detallada. Tratare de seguir estas
    normas en la medida de lo posible, que tampoco es que existan muchos
    ejemplos de buen gusto en lo que a programar en lenguaje C se refiere.

    Que es pues lo que hace un motor regexp

    - Buscar la coincidencia de un patron en una cadena y devolver el texto que
      se corresponde con el patron (o la informacion)

    - Informar el numero de coincidencias en una cadena

    - Capturar todas las coincidencias de un patron

    - consultar las coincidencias forma independiente

    - Poder modificar todas las coincidencias de un patron


    Compactar todas estas tareas en una sola funcion, no es prudente (eso no
    evita que algunas implementaciones lo intenten). @e(Recursive Regexp Raptor)
    Hereda una interfaz que ha sobrevidido sin cambio alguno, miles de millones
    de años

    ..src > c
      unsigned int regexp3( char *txt, char *re );
    < src..

    Lo que intenta transmitir el prototipo de esta funcion es:

    Hola soy un motor de expreciones regulares, me llamo @e(Recursive Regexp
    Raptor) pero tu puedes llamarme @c(regexp3), para invocarme tienes que darme
    una Regexp en forma de cadena de caracteres (argumento @c(re)) y una cadena
    de caracteres donde buscar el patron (argumento @c(txt)). Con mis
    habilidades de raptor descubrire cuantas veces se encuetra el patron en la
    cadena y te informare de esto regresando el conteo de coincidencias.

    Podriamos decir que cumple las tres reglas

    - Hace una cosa, contabilizar las coincidencias del patron.

    - tiene un nombre descriptivo... bueno el nombre no es muy explicito que
      digamos, pero almenos tiene la palabra regexp.

    - no necesita mas de 3 parametros. 2 < 3


    El resto de la interfaz, esta relacionado con el manejo y la manipulacion de
    capturas. Se veran a su debido tiempo segun se desarrolle el motor, por el
    momento nos centraremos en como optener los constructores de la exprecion de
    forma apropiada.

*** constructores

    Lamentablemente aun no hemos sido capaces de averiguar los algoritmos que
    hacen funcionar nuestro cerebro y seran necesarios unas cuantos años mas
    (espero no muchos) antes de que podamos optener una copia de nuestro
    software mental.

    Es una lastima no poder conectarnos directamente a la maquina y tranmitirle
    los algotirmos mentales de cada problema que hemos resuelto, peor aun
    tenemos una deficiencia para poder expresarlos de forma detallada, coerente
    y no ambigua, que es precisamente en lo que consiste la
    programacion. Mientras tanto tendras que conformante con la poca habilidad
    expresiva que me caracterisa e intentar copiar mi proceso mental.

    La regexp tiene una sintaxis bien definida que nos ayuda a identificar el
    tipo, patron y alcance de cada constructor. Una ves se ha identificado el
    constructor y optenido sus caracteristicas seran almacenadas en una
    estructura de nombre RE. Esta es su definicion:

    ..src > c
      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };
    < src..

    Excepto por los constructores @e(metacaracter) y @e(caracter) la longitud de
    un patron es arbitraria. Ya que el motor recive la regexp sin procesar en
    forma de cadena de caracteres, el constructor solo necesita conocer la
    posicion de inicio y longitud del patron dentro de la exprecion en bruto

    ..sketch >
      regexp      (0123456)[abcdefg]<ABCDEFGF...
                  ▲ptr     ▲ptr     ▲
                  │< len >|│< len >|│< len >|
      constructor [  uno  ][  dos  ][  tres ]
    < sketch..

    por su parte se utiliza la variable @c(type) que almacena el tipo del
    constructor, aspecto fundamental, pues de este depende el tipo de
    comparacion y acciones del motor. Se hace uso de una enumeracion que asigna
    un identificador unico para cada tipo de constructor. Desde el inicio
    definimos todos los tipos de constructores que el motor a de manejar.

    ..src > c
      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };
    < src..

    - @c(PATH) para el constructor @e(alternacion). Esta implementacion trata a
      las alternaciones como @e(rutas) de ejecucion.

    - @c(GROUP) evidentemente hace referencia al construcor agrupacion

    - @c(HOOK). En otros motores se almacena la coincidencia del patron de una
      agrupacion a menos que se indique lo contrario. En esta implementacion se
      utiliza un tipo de constructor especifico para indicar la captura de un
      patron. @c(HOOK) segun el traductor, significa gancho y se ofrece como
      una opcion para traducir @"(captura) o @"(pesca).

    - @c(BACKREF). @e(Backreference) (retroreferencia o referencia anterior)
      solicita al motor que busque el texto de una captura presente en la actual
      ruta de ejecucion y anterior a la aparicion de esta solicitud en la
      posicion actual de la cadena.

    - @c(SET) conjunto de caracteres

    - @c(RANGEAB) un rango de caracteres. En realidad este no es un constructor,
      es una facilidad que permiten los conjuntos, pero ya que posee una
      syntaxis propia se necesita un typo especifico para su manejo. Ademas la
      sintaxis de esta implementacion permite el uso de rangos fuera de un conjunto.

    - @c(META) metacaracter

    - @c(POINT) constructor punto

    - @c(SIMPLE) un caracter.

      Ya que una secuencia de constructores @e(caracter) puede tratarse como una
      simple cadena de caracteres, este tipo de constructor es capas de
      @"(almacenar) la aparicion de estas secuencias, solo contendran un solo
      caracter cuando se presente un solo constructor de este tipo o cuando el
      constructor tenga un modificador y/o se le aplique un cuantificador.


    @"(recorrido), @"(ruta), @"(caminar) son palabras habituales a la hora de
    explicar las acciones del motor, los nombres de varibles y funciones de esta
    implementacion tendran esta tematica simpre que sea apropiado. En terminos
    visuales el diagrama de flujo sera el siguiente.

    ..sketch >
                     RE┐
                       │◀──────────────────────────────┐
                       ▼                               │
                    ┌──────┐                           │
                    │walker│                           │
                    └──┬───┘                           │
                       ▼                               │
                   ┌────────┐                          │
                   │trekking│                          │
                   └───┬────┘                          │
        ┌──────┬───────┼─────┬──────┬───────┬──────┐   │
        ▼      ▼       ▼     ▼      ▼       ▼      ▼   │
      ┌───┐┌───────┐┌────┐┌─────┐┌──────┐┌─────┐┌────┐ │
      │SET││RANGEAB││META││POINT││SIMPLE││GROUP││HOOK│ │
      └───┘└───────┘└────┘└─────┘└──────┘└─────┘└────┘ │
        └──────┴───────┼─────┴──────┘       └──────┴───┘
                       ▼
                    ┌─────┐
                    │match│
                    └─────┘
    < sketch..

    La funcion @c(walker) (caminante) recive la exprecion, y recorre las rutas
    de ejecucion.

    La funcion @c(trekking) (senderista) optiene los constructores de la ruta,
    segun el tipo se envia a @c(match) que busca el patron el la cadena, o en
    caso de las agrupaciones a @c(walker) por la posibilidad de que contengan
    nuevas rutas de ejecucion.

*** pat$h

    ..src > c
      #include <stdio.h>
      #include <string.h>

      #define TRUE  1
      #define FALSE 0

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int  walker ( struct RE  rexp );
      static int  cutPath( struct RE *rexp, struct RE *track );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.len     = strlen( re );
        rexp.type    = PATH;

        return walker( rexp );
      }

      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker INIT", rexp.len, rexp.ptr );
        while( cutPath( &rexp, &track ) )
          printf( "%-20s >>%.*s<<\n", "walker PATH", track.len, track.ptr );

        return FALSE;
      }

      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;

        for( int i = 0, deep = 0; i < rexp->len; i++ ){
          if( rexp->ptr[ i ] ==  '(' )  deep++;
          if( rexp->ptr[ i ] ==  ')' )  deep--;
          if( rexp->ptr[ i ] ==  '|' && deep == 0 ){
            track->len  = i;
            rexp->ptr  += i + 1;
            rexp->len  -= i + 1;
            return TRUE;
          }
        }

        rexp->ptr += rexp->len;
        rexp->len  = 0;

        return TRUE;
      }
    < src..

    Esta es la primer vercion de nuestro motor, la unica caracteristica que
    posee es optener las rutas de ejecucion de la exprecion que recive. Coloca
    el codigo dentro de un fichero al que deberas llamar @f(regexp3.h), luego
    crea un fichero de nombre @c(test.c) y coloca lo siguiente

    ..src > c
      #include "regexp3.h"

      int main(){
        regexp3( "", "ruta1|ruta2|ruta3" );

        return 0;
      }
    < src..

    en este ultimo fichero se aplicaran pruedas al codigo, que verificaran que
    cumpla satisfactoriamente la funcion que se le supone.

    Compila el codigo con el siguiete comando

    ..src > sh
      gcc -Wall test.c
    < src..

    y ejecuta la prueba con

    ..src > sh
      ./a.out
    < src..

    el resultado de para la exprecion @c("ruta1|ruta2|ruta3") es el siguiente

    ..example >
      walker INIT          >>ruta1|ruta2|ruta3<<
      walker PATH          >>ruta1<<
      walker PATH          >>ruta2<<
      walker PATH          >>ruta3<<
    < example..

    @c(walker) muestra la exprecion que resive de inicio, y luego despliega de
    izquierda a derecha las rutas de ejecucion de esta exprecio.

    Vamos con la explicacion del codigo en @f(regexp3.h)

    ..src > c
      #include <stdio.h>   // ➊
      #include <string.h>  // ➋

      #define TRUE  1      // ➌
      #define FALSE 0      // ➍

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };  // ➎

      struct RE {          // ➏
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int walker ( struct RE  rexp );                    // ➐
      static int cutPath( struct RE *rexp, struct RE *track );  // ➑
    < src..

    se utiliza @c(stdio) para mostrar la informacon en ➊, @c(string) ➋ para
    optener la longitud de la cadena que contiene la regexp.

    Se utilizan dos constantes de macro para representar veradero ➌ y falso ➍.

    Luego tenemos los tipos de constructor ➎ y la estructura @c(RE) ➏, el
    contenedor de los constructores.

    En c antes de utilizar una funcion tenemos que escribir su definicion o un
    prototipo y definirla despues. Se opta por la declaracion de prototipos para
    que la lectura del codigo fluya de forma descendente ➐➑, a medida que se van
    utilizando las funciones.

    ..src > c
      int regexp3( char *txt, char *re ){
        struct RE    rexp;             // ➊
        rexp.ptr     = re;             // ➋
        rexp.len     = strlen( re );   // ➌
        rexp.type    = PATH;           // ➍

        return walker( rexp );         // ➎
      }
    < src..

    @c(regexp3) la furcion principal del motor, solicita una instancia de la
    estructura @c(RE) y apropiadamente la llama rexp (Regular EXPresion)
    ➊. Asignamos el punto de inicio al inicio de la cadena que contiene la
    exprecion ➋. Como es de esperar la longitud de la exprecion es la longitud
    de la cadena que contiene la expresion ➌. Toda regexp contiene almenos una
    ruta de ejecucion, acorde a esto se asigna el tipo ruta ➍.

    @c(walker) recorre las rutas de la exprecion y nos informa y alguna de ellas
    coincide con la cadena, esta informacion es lo quedebe conocer quien
    consulta el motor ➎.

    Es importante resaltal el echo de que ninguna funcion modifica ni la
    exprecion o la cadena de busqueda. En el caso de la exprecion, siempre se
    travaja de forma @"(remota) solo con la direccion de inicio y la longitud
    de la exprecion.

    ..src > c
      static int walker( struct RE rexp ){
        struct RE track;                                                      // ➊

        printf( "%-20s >>%.*s<<\n", "walker INIT", rexp.len, rexp.ptr );      // ➋
        while( cutPath( &rexp, &track ) )                                     // ➌
          printf( "%-20s >>%.*s<<\n", "walker PATH", track.len, track.ptr );  // ➍

        return FALSE;                                                         // ➎
      }
    < src..

    @c(walker) tambien declara su propio intancia de @c(RE) y la llama @c(track)
    ➊. la funcion de @c(walker) es optener las rutas de ejecucion, para luego
    recorrerlas hasta encontrar un patron que este precesente en lacadena, esta
    el so que hace el bucle @c(while) con ayuda de la fucion @c(cutPath) ➌,
    viede a decir algo como esto: @q(continua mientras puedas optener rutas de
    ejecucion, si las rutas se agotan informa que no se a encontrado es patron
    en ninguna ruta ➎). Las funciones @c(print) despliegan la exprecion al
    inicio y las rutas de ejecucion ➍➋. Si despues del ciclo analizamos el
    patron precente en @c(rexp) encontraremos que la exprecion a quedado vacia
    (su longitud es 0, y el puntero ahora apunta al final de la exprecion).

    ..src > c
      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;  // ➊

        *track = *rexp;

        for( int i = 0, deep = 0; i < rexp->len; i++ ){  // ➋
          if( rexp->ptr[ i ] ==  '(' )  deep++;          // ➌
          if( rexp->ptr[ i ] ==  ')' )  deep--;          // ➍
          if( rexp->ptr[ i ] ==  '|' && deep == 0 ){     // ➎
            track->len  = i;
            rexp->ptr  += i + 1;
            rexp->len  -= i + 1;
            return TRUE;                    // ➏
          }
        }

        rexp->ptr += rexp->len;             // ➐
        rexp->len  = 0;                     // ➑

        return TRUE;                        // ➒
      }
    < src..

    La funcion auxiliar @c(cutPath) se encarga de cortar la ruta mas a la
    izquierda de una expresion, obviamente si la longitud de la exprecion es
    cero no hay nada que hacer ➊. Hacemos una copia de toda la ruta (puntero,
    longitud y tipo. Recordemos que ya es detipo ruta). Si pasamos por el ciclo
    @c(for) in descubrir la precencia de otras rutas, significa que la exprecion
    tiene una sola ruta, establecemeso la exprecion fuente a longitud cero ➐➑ e
    informamos que almenos existe una ruta ➒.

    Lo que hace el ciclo @c(for) es recorrer la exprecion caracter a caracter
    limitandose a la longitud de la exprecion ➋.  Recordemos que el signo @c(|)
    sirve como separador entre las rutas, y en este caso al optener los
    constructores ruta, no pueden encontrarse dentro de ningun constructor
    agrupacion. Sabemos que estamos ante una ruta cuanto se encuentra el signo
    @c(|) fuero de ninguna agrupacion ➎. Para conocer si estamos dentro de una
    agrupacion y su nivel de anidamento se utiliza la variable @c(deep). si
    inicia una agrupacion @c(deep) aumenta en uno ➌, al termino de la agrupacion
    @c(deep) disminuye en uno ➍.

    Inmediatamente despues de localizar la primer ruta, se establece la logitud
    de la seccion (@c(track)) a la posicion actual. La exprecion original ya no
    necesita el signo @c(|), y se descarta colocando el apuntador luego de este
    signo (@c(i + 1)). @e(Ten en consideracion que la primera posicion de un
    arregla es @c(0) y la posocion del recorrido (@c(i)) toma esto en
    cuento). Finalmenet informamos que se a localizado la ruta ➏.

*** simple & group

    Al igual que en la seccion anterior el codigo se presentara al inicio.
    Recomiendo que antes de pasar a la explicacion lo analices por tu cuenta,
    identifiques las diferencias con la ultima vercion e incluso lo modifiques y
    sigas tu propia ruta de desarrollo.

    ..src > c
      #include <stdio.h>
      #include <string.h>

      #define TRUE  1
      #define FALSE 0

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int walker  ( struct RE  rexp );
      static int trekking( struct RE *rexp );
      static int cutPath ( struct RE *rexp, struct RE *track );
      static int tracker ( struct RE *rexp, struct RE *track );

      static char *strnchr( char *str, int chr, int n );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );

        return walker( rexp );
      }

      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   INIT", rexp.len, rexp.ptr );
        while( cutPath( &rexp, &track ) ){
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          trekking( &track );
        }

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){
          if ( track.type == GROUP  ){
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            walker( track );
          } else if( track.type == SIMPLE ){
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
          }
        }

        return TRUE;
      }

      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;

        for( int i = 0, deep = 0; i < rexp->len; i++ ){
          if( rexp->ptr[ i ] ==  '(' )  deep++;
          if( rexp->ptr[ i ] ==  ')' )  deep--;
          if( rexp->ptr[ i ] ==  '|' && deep == 0 ){
            track->len  = i;
            rexp->ptr  += i + 1;
            rexp->len  -= i + 1;
            return TRUE;
          }
        }

        rexp->ptr += rexp->len;
        rexp->len  = 0;

        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        *track = *rexp;

        if( rexp->len ){
          if( rexp->ptr[ 0 ] == '(' ){
            for( int deep = 1, i = 1; i < rexp->len; i++ ){
              if( rexp->ptr[ i ] ==  '(' ) deep++;
              if( rexp->ptr[ i ] ==  ')' ) deep--;

              if( deep == 0 ){
                track->type = GROUP;
                track->ptr++;
                track->len  = rexp->ptr + i - track->ptr;
                rexp->len  -= i + 1;
                rexp->ptr  += i + 1;
                return TRUE;
              }
            }
          } else {
            track->type = SIMPLE;

            char *point;
            if( (point = strnchr( rexp->ptr, '(', rexp->len )) )
              track->len = point - track->ptr;

            rexp->len  -= track->len;
            rexp->ptr  += track->len;
            return TRUE;
          }
        }

        return FALSE;
      }

      static char * strnchr( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( str[ i ] == chr ) return str + i;

        return 0;
      }
    < src..

    vuelve a compilar, y ejecuta la prueba

    ..src > sh
      gcc -Wall test.c && ./a.out
    < src..

    con la prueba @c("ruta1|ruta2|ruta3") el resultado es

    ..example >
      walker   INIT        >>ruta1|ruta2|ruta3<<
      walker   PATH        >>ruta1<<
      trekking SIMPLE      >>ruta1<<
      walker   PATH        >>ruta2<<
      trekking SIMPLE      >>ruta2<<
      walker   PATH        >>ruta3<<
      trekking SIMPLE      >>ruta3<<
    < example..

    En esencia el resultado no a cambiado, sin embargo ahora somos capaces de
    identificar cadenas de caracteres de tipo @c(SIMPLE) (uno o mas
    constructores caracter).

    Probemos con una exprecion con un par de agrupaciones @c[a(b|c)|A(B|C)].
    modifica el fichero @f(test.c) para que tenga lo siguiente:

    ..src > c
      int main(){
        // regexp3( "", "ruta1|ruta2|ruta3" );
        regexp3( "", "a(b|c)|A(B|C)" );
        return 0;
      }
    < src..

    recompila y ejecuta. obtenemos:

    ..example >
      walker   init        >>a(b|c)|A(B|C)<<
      walker   PATH        >>a(b|c)<<         ➊
      trekking SIMPLE      >>a<<              ➋
      trekking GROUP       >>b|c<<            ➌
      walker   init        >>b|c<<            ➍
      walker   PATH        >>b<<              ➎
      trekking SIMPLE      >>b<<              ➏
      walker   PATH        >>c<<              ➐
      trekking SIMPLE      >>c<<              ➑
      walker   PATH        >>A(B|C)<<         ➒
      trekking SIMPLE      >>A<<
      trekking GROUP       >>B|C<<
      walker   init        >>B|C<<
      walker   PATH        >>B<<
      trekking SIMPLE      >>B<<
      walker   PATH        >>C<<
      trekking SIMPLE      >>C<<
    < example..

    lo que el motor esta haciendo es optener la primer ruta de ejecucion
    @c[a(b|c)] ➊, luego se encuentra con el constructor @c(SIMPLE) @c(a) ➋, a
    continuacion optiene la aprupacion @c[(b|c)] ➌ y se envia a @c(walker) ➍ que
    optiene posibles rutas ejecucion ➎➐. Envia las rutas de la agrupacion a
    @c(trekking) y este optiene los constructores caracter correspondientes a
    las rutas @c(b) y @c(c) ➏➑. Con esto finaliza el recorrido por la primer
    ruta @"(principal), a continuacion el motor realiza el mismo proceso con la
    segunda ruta que es @c[A(B|C)] ➒.

    La siguiente es la salida de la prueba anterior, pero en esta ocacion
    agregue un arbol descendente con el recorrido del motor, espero sea de ayuda.

    ..example >
      walker   init        >>a(b|c)|A(B|C)<<   ┌──▶ walker inicial
      walker   PATH        >>a(b|c)<<          ├─┬▶ walker primer ruta
      trekking SIMPLE      >>a<<               │ ├──> primer constructor : caracter
      trekking GROUP       >>b|c<<             │ └─┬> segundo constructor: agrupacion
      walker   init        >>b|c<<             │   ├──▶ walker recursivo
      walker   PATH        >>b<<               │   ├─┬▶ walker primer ruta
      trekking SIMPLE      >>b<<               │   │ └──> optiene el constructor
      walker   PATH        >>c<<               │   └─┬▶ walker segunda ruta
      trekking SIMPLE      >>c<<               │     └──> optiene el constructor
      walker   PATH        >>A(B|C)<<          └─┬▶ walker segunda ruta
      trekking SIMPLE      >>A<<                 ├──> primer constructor : caracter
      trekking GROUP       >>B|C<<               └─┬> segundo constructor: agrupacion
      walker   init        >>B|C<<                 ├──▶ walker recursivo
      walker   PATH        >>B<<                   ├─┬▶ walker primer ruta
      trekking SIMPLE      >>B<<                   │ └──> optiene el constructor
      walker   PATH        >>C<<                   └─┬▶ walker segunda ruta
      trekking SIMPLE      >>C<<                     └──> optiene el constructor
    < example..

    apliquemos otra prueba distinta

    ..src > c
      int main(){
        regexp3( "(a(b|c)|A(B|C))|1234(ea|eb|ec)" );

        return 0;
      }
    < src..

    optenemos

    ..example >
      walker   init        >>(a(b|c)|A(B|C))|1234(ea|eb|ec)<<    ┌──▶ walker inicial
      walker   PATH        >>(a(b|c)|A(B|C))<<                   ├─┬▶ walker primer ruta
      trekking GROUP       >>a(b|c)|A(B|C)<<                     │ └─┬> primer constructor: agrupacion
      walker   init        >>a(b|c)|A(B|C)<<                     │   ├──▶ walker recursivo
      walker   PATH        >>a(b|c)<<                            │   ├─┬▶ walker primer ruta
      trekking SIMPLE      >>a<<                                 │   │ ├──> primer constructor : caracter
      trekking GROUP       >>b|c<<                               │   │ └─┬> segundo constructor: agrupacion
      walker   init        >>b|c<<                               │   │   ├──▶ walker recursivo
      walker   PATH        >>b<<                                 │   │   ├─┬▶ walker primer ruta
      trekking SIMPLE      >>b<<                                 │   │   │ └──> optiene el constructor
      walker   PATH        >>c<<                                 │   │   └─┬▶ walker segunda ruta
      trekking SIMPLE      >>c<<                                 │   │     └──> optiene el constructor
      walker   PATH        >>A(B|C)<<                            │   └─┬▶ walker segunda ruta
      trekking SIMPLE      >>A<<                                 │     ├──> primer constructor : caracter
      trekking GROUP       >>B|C<<                               │     └─┬> segundo constructor: agrupacion
      walker   init        >>B|C<<                               │       ├──▶ walker recursivo
      walker   PATH        >>B<<                                 │       ├─┬▶ walker primer ruta
      trekking SIMPLE      >>B<<                                 │       │ └──> optiene el constructor
      walker   PATH        >>C<<                                 │       └─┬▶ walker segunda ruta
      trekking SIMPLE      >>C<<                                 │         └──> optiene el constructor
      walker   PATH        >>1234(ea|eb|ec)<<                    └─┬▶ walker segunda ruta
      trekking SIMPLE      >>1234<<                                ├──> primer constructor : caracter
      trekking GROUP       >>ea|eb|ec<<                            └─┬> segundo constructor: agrupacion
      walker   init        >>ea|eb|ec<<                              ├──▶ walker recursivo
      walker   PATH        >>ea<<                                    ├─┬▶ walker primer ruta
      trekking SIMPLE      >>ea<<                                    │ └──> optiene el constructor
      walker   PATH        >>eb<<                                    ├─┬▶ walker segunda ruta
      trekking SIMPLE      >>eb<<                                    │ └──> optiene el constructor
      walker   PATH        >>ec<<                                    └─┬▶ walker tercer ruta
      trekking SIMPLE      >>ec<<                                      └──> optiene el constructor
    < example..

    por el momento el motor solo puede optener rutas, agrupaciones y carateres.
    Aplica algunas prubas mas, hasta asegurarte que el motor procesa de forma
    correcta estos constructores, por ejeplo con

    ..src > c
      regexp3( "((a(b|c)|A(B|C))|1234(ea|eb|ec))|PATH2|PATH3|(((a(b|c)|A(B|C))|1234(ea|eb|ec))|PATH4B)|PATH5" );
    < src..

    Ahora si, la explicacion. Ignorando los nuevos prototipos de funcion, los
    cambios inician en @c(walker)

    ..src > c
      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   INIT", rexp.len, rexp.ptr );
        while( cutPath( &rexp, &track ) ){
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          trekking( &track );  ➊
        }

        return FALSE;
      }
    < src..

    ahora @c(walker) envia las rutas a @c(trekking) ➊, la tarea de esta nueva
    funcion es recorrer los constructores de la ruta.

    ..src > c
      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){     // ➊
          if ( track.type == GROUP  ){        // ➋
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );  // ➌
            walker( track );                  // ➍
          } else if( track.type == SIMPLE ){  // ➎
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr ); // ➏
          }
        }

        return TRUE;                          // ➐
      }
    < src..

    @c(trekking) sigue el mismo esquema que @c(walker), con la pequeña
    diferencia que en esta ocacion no se resive una copia sino un puntero de la
    ruta.

    la funcion de walker puede resumirse de esta forma: se resive una ruta de
    ejecucion, mientras se puedan optener constructores se evaluan ➊, si se agotan
    los constructores significara que cada constructor fue localizado y se
    regresa @c(TRUE) ➐.

    si el constructor es de tipo agrupacion (@c(GROUP)) ➋ se envia a @c(walker)
    ➌ para que este genere almenos una ruta de ejecucion.

    si el constructor es de tipo caracter (@c(SIMPLE)) ➎. no hay nada mas que
    hacer.

    al igual que en walker se despliega informacion del proceso mediente
    instrucciones @c(printf) ➍➏.

    Antes de continuar es importante señalar el esquema de manejo de memoria que
    estamos utilizando:

    ..src > c
      tipo_retorno funcion( struct RE rexp ){
        struct RE track;
      }
    < src..

    EXACTO!!!. Cuando llamamos a una funcion los paramentros son memoria que el
    compilador solicita y gestiona de forma trasparente para nosotros, lo unico
    que nos pide a cambio es un valor correcto de inicializacion.

    La syntaxis regexp nos permite que ninguna funcion necesite mas de dos
    instancias que almacenen la regexp: la exprecion inicial y el segmenento que
    se esta avaluando. Es mas la exprecion de inicio puede ser simplemente un
    puntero a memoria precedente de otra funcion, como en la llamada de
    @c(walker) a @c(trekking), de echo el mismo @c(walker) podria trabajar con
    un puntero a la regexp. No se hace de esta forma para que la exprecion
    inicial (declarada en @c(regexp3)) no sea modificada y se puedan realizar
    consultas a @c(walker) con distintas posiciones de inicio en la cadena.

    Continuemos con el codigo. @c(trekking) utiliza una funcion auxiliar
    @c(tracker) la cual que encarga de optener el constructor mas a la izquierda
    de la exprecion @c(rexp) y lo almacena dentro @c(track)

    ..src > c
      static int tracker( struct RE *rexp, struct RE *track ){
        *track = *rexp;

        if( rexp->len ){
          if( rexp->ptr[ 0 ] == '(' ){                            // ➊
            for( int deep = 1, i = 1; i < rexp->len; i++ ){
              if( rexp->ptr[ i ] ==  '(' ) deep++;
              if( rexp->ptr[ i ] ==  ')' ) deep--;

              if( deep == 0 ){
                track->type = GROUP;
                track->ptr++;
                track->len  = rexp->ptr + i - track->ptr;
                rexp->len  -= i + 1;
                rexp->ptr  += i + 1;
                return TRUE;
              }
            }
          } else {
            track->type = SIMPLE;

            char *point;
            if( (point = strnchr( rexp->ptr, '(', rexp->len )) )  // ➋
              track->len = point - track->ptr;

            rexp->len  -= track->len;
            rexp->ptr  += track->len;
            return TRUE;
          }
        }

        return FALSE;
      }
    < src..

    este es el el fundamento de @c(tracker): si la exprecion inicia con un
    constructor que necesita un @e(signo de apertura) ('(' para agrupacion, '<'
    para agrupacion con captura, '[' para conjunto, ':' para metacaracter, ...,
    etc. ) cortamos el constructor y lo almacenamos en @c(track) ➊, de lo
    contrario nos encortramos ante una simple cadena de caracteres, para ser mas
    eficientes y no cortar caracter a caracter los agrupamos en un mismo
    constructor, hasta localizar un signo (@c(strnchr)) que indique el inicio de
    un constructor distinto ➋; si no existe un constructor distinto el resto de
    la exprecion es de tipo @c(SIMPLE).

    Por el momento tenemos esto:

    ..sketch >
      ┏━━━━━━━━━━━┓                   ▸ regexp llama a walker.
      ┃           ┃
      ┃  regexp3  ┃                   ▸ walker optiene las rutas y las envia a treking
      ┃           ┃
      ┗━━━━━━━━━━━┛                   ▸ trekking optiene los constructores
         ┃  ▲      GROUP                - si el tipo es GROUP lo envia a walker
         ┃  ┃  ┏━━━━━━━━━━━━┓           - si el tipo es SIMPLE no hay nada mas que hacer
         ▼  ┃  ▼            ┃
      ┏━━━━━━━━━━━┓   ┏━━━━━━━━━━━┓
      ┃           ┃◀━━┃           ┃
      ┃  walker   ┃   ┃ trekking  ┃━━▶ SIMPLE
      ┃           ┃━━▶┃           ┃
      ┗━━━━━━━━━━━┛   ┗━━━━━━━━━━━┛
    < sketch..

    ( ͡° ͜ʖ ͡°)ง? y si dentro de una agrupacion no existieran rutas seria posible
    que trekkin presindiera de la llamada a @c(walker)?

    exelente pregunta, en tal caso @c(trekking) podria hacerse cargo de opteren
    los constructores dentro de la agrupacion de forma recurisiva y el resultado
    seguiria siendo apropiado, es mas si no existiese ninguna ruta @c(regexp3)
    podria consultar directamente a @c(trekking) sin pasar por @c(walker) pero
    tendriamos que implementar una funcion por ejemplo llamada @c(isPath) para
    averiguar si existen o no rutas. Visualmente tendriamos esto:

    ..sketch target=ispath >
      ┏━━━━━━━━━━━┓    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      ┃           ┃    ▼    ┏━━━━━━━━━━━┓  no            ┃
      ┃  regexp3  ┃━━━━━━━━▶┃  isPath   ┃━━━━━┓          ┃
      ┃           ┃         ┗━━━━━━━━━━━┛     ┃          ┃
      ┗━━━━━━━━━━━┛               ┃ yes       ┃          ┃
         ▲     ▲                  ┃           ┃          ┃
         ┃     ┃                  ▼           ┃          ┃
         ┃     ┃             ┏━━━━━━━━━━━┓    ▼    ┏━━━━━━━━━━━┓
         ┃     ┃             ┃           ┃━━━━━━━━▶┃           ┃
         ┃     ┗━━━━━━━━━━━━━┃  walker   ┃         ┃ trekking  ┃━━▶ SIMPLE
         ┃                   ┃           ┃◀━━━┳━━━━┃           ┃
         ┃                   ┗━━━━━━━━━━━┛    ┃    ┗━━━━━━━━━━━┛
         ┃                                    ┃
         ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    < sketch..

    @c(isPath) seria asi

    ..src > c
      static int isPath( struct RE *rexp ){
        for( int i = 0, deep = 0; i < rexp->len; i++ ){
          i += walkMeta( rexp->ptr + i );

          switch( rexp->ptr[i] ){
          case '(': deep++; break;
          case ')': deep--; break;
          case '|': if( deep == 0 ) return TRUE;
          }
        }

        return FALSE;
      }
    < src..

    en esencia es una version reducida de @c(walker). Si seguimos este esquema
    cuando existan 2 o mas rutas tendremos que hacer una llamada adicional, sin
    mencionar que incementaria la complejidad/cantidad de codigo para resolver
    un problema ya rusuelto. La unica razon para seguir este esquema es generar
    un registro de la optencion de constructores mas eficiente, cosa que por el
    momento no es necesaria ¯\_(ツ)_/¯.

    Por cierto hacia falta explicar la funcion @c(strnchr). La libreria estandar
    @c(<string.h>) incluye una funcion llamada @c(strchr) su labor es localizar
    la primera ocurrencia de un caracter dentro de una cadena de caracteres y
    regresar un puntero con la ubicacion de la ocurrencia. No es comveniente
    utilizar esta funcion, puesto que necesitamos mantener un rango de busqueda
    especifico, como no hay una funcion que realice esta labor dentro de la
    libreria estandar, implementamos nuestra propia vercion.

*** hook

    En el estado actual del motor no representa nigun reto agregar las
    instrucciones necesarias para optener el constructor de agrupacion con
    captura @c(<...>) mediante una serie de @c(if)-@c(else if)-@c(else). Aqui
    mismo esta el codigo:

    ..src > c
      #include <stdio.h>
      #include <string.h>

      #define TRUE  1
      #define FALSE 0

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int walker  ( struct RE  rexp );
      static int trekking( struct RE *rexp );
      static int cutPath ( struct RE *rexp, struct RE *track );
      static int tracker ( struct RE *rexp, struct RE *track );

      static char * trackerPoint( char *points, char *track, int len );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );

        return walker( rexp );
      }

      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   INIT", rexp.len, rexp.ptr );
        while( cutPath( &rexp, &track ) ){
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          trekking( &track );
        }

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){
          if ( track.type == GROUP  ){
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            walker( track );
          } else if ( track.type == HOOK  ){
            printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
            walker( track );
          } else if( track.type == SIMPLE ){
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
          }
        }

        return TRUE;
      }

      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;

        for( int i = 0, deep = 0; i < rexp->len; i++ ){
          switch( rexp->ptr[ i ] ){
          case '(': case '<': deep++; break;
          case ')': case '>': deep--; break;
          }

          if( rexp->ptr[ i ] == '|' && deep == 0 ){
            track->len  = i;
            rexp->ptr  += i + 1;
            rexp->len  -= i + 1;
            return TRUE;
          }
        }

        rexp->ptr += rexp->len;
        rexp->len  = 0;

        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        *track = *rexp;

        if( rexp->len ){
          if( rexp->ptr[ 0 ] == '(' ){
            for( int deep = 1, i = 1; i < rexp->len; i++ ){
              if( rexp->ptr[ i ] ==  '(' ) deep++;
              if( rexp->ptr[ i ] ==  ')' ) deep--;

              if( deep == 0 ){
                track->type = GROUP;
                track->ptr++;
                track->len  = rexp->ptr + i - track->ptr;
                rexp->len  -= i + 1;
                rexp->ptr  += i + 1;
                return TRUE;
              }
            }
          } else if( rexp->ptr[ 0 ] == '<' ){
            for( int deep = 1, i = 1; i < rexp->len; i++ ){
              if( rexp->ptr[ i ] ==  '<' ) deep++;
              if( rexp->ptr[ i ] ==  '>' ) deep--;

              if( deep == 0 ){
                track->type = HOOK;
                track->ptr++;
                track->len  = rexp->ptr + i - track->ptr;
                rexp->len  -= i + 1;
                rexp->ptr  += i + 1;
                return TRUE;
              }
            }
          } else {
            track->type = SIMPLE;

            char *point;
            if( (point = trackerPoint( "(<", rexp->ptr + 1, rexp->len - 1 )) )
              track->len = point - track->ptr;

            rexp->len  -= track->len;
            rexp->ptr  += track->len;
            return TRUE;
          }
        }

        return FALSE;
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }
    < src..

    se hiso una pequeña modificacion en @c(cutPath), se agrego una instruccion
    en @c(trekking) para manejar el tipo @c(HOOK), un @c(else if) especifico
    para este ultimo en @c(tracker) y @c(strnchr) se transformo en
    @c(trackerPoint).

    El esquema @c(if)-@c(else if)-@c(else) de @c(tracker) es capas de manejar
    todos los casos... simpre y cuando el tener un monton de codigo repetido no
    nos genere ningun transtorno mental...

    ┬┴┬┴┤  (ಠ├┬┴┬┴  Debo recorocer que por mas de un mes no fui campaz de
    encontrar una solucion mas elegante. Fue un perido que prefiero no recordar,
    olvida el codigo de arriba.

    ..src > c
      #include <stdio.h>
      #include <string.h>

      #define TRUE  1
      #define FALSE 0

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int  walker       ( struct RE  rexp );
      static int  trekking     ( struct RE *rexp );
      static int  tracker      ( struct RE *rexp, struct RE *track );
      static int  cutTrack     ( struct RE *rexp, struct RE *track, int type );

      static void trackByLen   ( struct RE *rexp, struct RE *track, int len, int type );
      static void fwrTrack     ( struct RE *track, int len );
      static char *trackerPoint( char *points, char *track, int len );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );

        return walker( rexp );
      }

      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   INIT", rexp.len, rexp.ptr );
        while( cutTrack( &rexp, &track, PATH ) ){
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          trekking( &track );
        }

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){
          switch( track.type ){
          case GROUP:
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            walker( track );
            break;
          case HOOK :
            printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
            walker( track );
            break;
          default   :
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
          }
        }

        return TRUE;
      }

      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track      = *rexp;
        track->type = type;
        if( type != PATH ) fwrTrack( track, 1 );

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          switch( rexp->ptr[i] ){
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          }

          switch( type ){
          case HOOK    : cut = deep == 0; break;
          case GROUP   : cut = deep == 0; break;
          case PATH    : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );
        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case '(': cutTrack( rexp, track, GROUP ); break;
        case '<': cutTrack( rexp, track, HOOK  ); break;
        default :
          if( (point = trackerPoint( "(<", rexp->ptr + 1, rexp->len - 1 )) )
            trackByLen( rexp, track, point - rexp->ptr, SIMPLE  );
          else trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

        return TRUE;
      }

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
        *track       = *rexp;
        track->type  = type;
        track->len   = len;
        fwrTrack( rexp, len );
      }

      static void fwrTrack( struct RE *track, int len ){
        track->ptr += len; track->len -= len;
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }
    < src..

    Que ha cambiado? @c(cutPath) cambio de nombre a @c(cutTrack), se agregaron
    dos funciones mas y en total hay 10 lineas menos de codigo.

    la mayoria del codigo de @c(trekking) era una duplicado del codigo de la
    funcion @c(cutPath). Ambos recorrian la regexp averiguando el nivel de
    anidamiento antes de realizar el corte de una seccion. No fue algo evidente,
    aun asi encortre la formo de agrupar distintos tipos de corte en
    @c(cutPath), agregarndo un parametro para especificar el corte deseado:
    @c(PATH), @c(GROUP) y @c(HOOK), mas adelante tambien se hara cargo de
    @c(SET). En consequencia, modifique el nombre a @c(cutTrack) para reflejar
    de mejor forma su labor. Veamos las modificaciones:

    ..src > c
      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track      = *rexp;
        track->type = type;                                             // ➊
        if( type != PATH ) fwrTrack( track, 1 );                        // ➋

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          switch( rexp->ptr[i] ){                                       // ➌
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          }

          switch( type ){                                               // ➍
          case HOOK    : cut = deep == 0; break;                        // ➎
          case GROUP   : cut = deep == 0; break;                        // ➏
          case PATH    : cut = deep == 0 && rexp->ptr[i] == '|'; break; // ➐
          }

          if( cut ){                                                    // ➑
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );                                    // ➒
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );                                    // ➓
        return TRUE;
      }
    < src..

    Necesario es resaltar que los cortes de tipo agrupacion (con o sin captura)
    requieren nuestro conocimento por adelantado de que el primer caracter con
    el que se debe encantrar la funcion debe ser @c[(] o @c(<), de lo contrario
    la seccion de corte tendra una longitud @e(cero)... esto es justo lo que
    hace @c(trekking) antes de cortar una seccion, por otro lado, la funcion
    debe conservar su antiguo comportamiento cuando @c(walker) le solicita un
    corte de tipo @c(PATH) (ღ˘⌣˘ღ).

    Despues de realizar una copia de la regexp origen a la seccion (si no hay
    ningun corte, la eprecion de orgien es la seccion) asigna el tipo de corte
    que solicitamos como el tipo de seccion que vamos a optener ➊. Cuando el
    tipo de conte no es de tipo @c(PATH) ➋ descartamos el carater de inicio en
    la seccion (@c(track)) al igual que el caracter de cierre. Es decir una vez
    conocemos el tipo de seccion a optener, no intereza  almacenar sus
    delimitadores, solo el contenido

    ..sketch >
      (cdefghijklmnopqrstuv)...
      ▲▲                  ▲▲▲
      ┃┃ zona de interez  ┃┃┃
      ┃┗━━━━━━━━━━━━━━━━━━┛┃┗━━┓
      ┃▲                   i + 1 se descarta el signo de cierre
      ┃┃
      ┃┗━━┓ se descarta el signo de inicio
      0 + 1 == fwrTrack( track, 1 )
    < sketch..

    si la seccion de interes es una ruta

    ..sketch >
      ab(cdefghijklmnopqrstuv)|AB(CDEFGHIJKLMNOPQRSTUV)
      ▲                      ▲ ▲                      ▲
      ┃   zona de interez    ┃ ┃   zona de intevez    ┃
      ┗━━━━━━━━━━━━━━━━━━━━━━┛ ┗━━━━━━━━━━━━━━━━━━━━━━┛
                              ▲▲
                             ┏┛┗━┓
                             ┃   ┃
                             i + 1
    < sketch..


    en lugar de hacer el corte y avance de cada seccion de forma manual con
    codigo de este estilo

    ..src > c
      rexp->ptr  += rexp->len;
      rexp->len  -= rexp->len;
    < src..

    se substituye por la funcion @c(fwrTrack)

    ..src > c
      static void fwrTrack( struct RE *track, int len ){
        track->ptr += len; track->len -= len;
      }
    < src..

    Utilizar instrucciones @c(if) es apropiado cuando la consulta ocurre no mas
    de dos veces e involucran tipos de datos distintos. Este caso, donde
    conocemos de antemano que el tipo de dato es de tipo @c(char) y la posicion
    es la misma para todas las consultas no solo es mas claro aplicar un
    @c(switch), ademas es mas eficiente ➌.

    Con el @c(switch) conocemos el nivel de anidamiento en la posicion
    actua. Para realizar el corte tanto para las rutas como para las
    agrupaciones es requisito estar estar fuera de ningun nivel de anidamiento
    ➎➏➐. De nuevo la instruccion @c(switch) es apropiada para conocer si debe
    ralizarse el corte segun el tipo de seccion. El estado de variable @c(cut)
    se asgina mediante una evaluacion boolean. Inmediatamente despues sigue el
    codigo que realiza el corte segun el resultado de esta asignacion ➑.

    Una ves se conoce la dimencion de la seccion, esta se elimina de la
    estructura de origen moviendo el punto de inicio y final ➒➓

    La funcion @c(trekking)

    ..src > c
      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){
          switch( track.type ){
          case GROUP:
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            walker( track );
            break;
          case HOOK :
            printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
            walker( track );
            break;
          default   :
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
          }
        }

        return TRUE;
      }
    < src..

    tambien substituyo la serie de @c(if)s por un @c(switch). El cambio mas
    relevante se realiza en su funcion auxiliar @c(tracker)

    ..src > c
      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){                                                 // ➊
        case '(': cutTrack( rexp, track, GROUP ); break;                      // ➋
        case '<': cutTrack( rexp, track, HOOK  ); break;                      // ➌
        default :                                                             // ➍
          if( (point = trackerPoint( "(<", rexp->ptr + 1, rexp->len - 1 )) )  // ➎
            trackByLen( rexp, track, point - rexp->ptr, SIMPLE  );            // ➏
          else trackByLen( rexp, track, rexp->len, SIMPLE  );                 // ➐
        }

        return TRUE;
      }
    < src..

    Una vez mas, un switch es el protaganista de la accion. Su funcion es
    evaluar la primer posicion de la cadena ne @c(rexp) ➊. Se solicita el corte
    del primer constructor a @c(cutTrack) segun sea una agrupacion ➋ o una
    agrupacion con captura ➌.

    @c(default) ➍ captura todas las posibles combinaciones de un constructor
    caracter. Primero averigua si existe dentro de la exprecion otra constructor
    de tipo agrupacion o captura ➎, si esta existe realiza un corte con el punto
    como limite ➏, de lo contrario, el constructor de tipo caracter se exiende
    hasta por el resto de la exprecion ➐.

    Finalmente la diferencia entre @c(trackerPoint) y @c(strnchr), es que la
    primera puede realizar la busqueda de un conjunto de caracteres, y la
    primera solo era capaz de manejar un solo caracter.

    ..src > c
      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }
    < src..

    @c(points) contiene los puntos (caracteres) que debemos rastrear, @c(track)
    es la region donde se realiza la busqueda y @c(len) la longitud de la
    region. Se regresa la posicion de la primer coincidencia en forma de puntero
    de caracteres o un puntero nulo.

    Aplicamos la siguente prueba (@c(test.c)):

    ..src > c
      regexp3( "", "<a(b|c)|A(B|C)>|1234(ea|eb|ec)" );
    < src..

    y nos aseguramos que el resultado sea el apropiado

    ..example >
      walker   init        >><a(b|c)|A(B|C)>|1234(ea|eb|ec)<<    ┌──▶ walker inicial
      walker   PATH        >><a(b|c)|A(B|C)><<                   ├─┬▶ walker primer ruta
      trekking HOOK        >>a(b|c)|A(B|C)<<                     │ └─┬> primer constructor: captura
      walker   init        >>a(b|c)|A(B|C)<<                     │   ├──▶ walker recursivo
      walker   PATH        >>a(b|c)<<                            │   ├─┬▶ walker primer ruta
      trekking SIMPLE      >>a<<                                 │   │ ├──> primer constructor : caracter
      trekking GROUP       >>b|c<<                               │   │ └─┬> segundo constructor: agrupacion
      walker   init        >>b|c<<                               │   │   ├──▶ walker recursivo
      walker   PATH        >>b<<                                 │   │   ├─┬▶ walker primer ruta
      trekking SIMPLE      >>b<<                                 │   │   │ └──> optiene el constructor
      walker   PATH        >>c<<                                 │   │   └─┬▶ walker segunda ruta
      trekking SIMPLE      >>c<<                                 │   │     └──> optiene el constructor
      walker   PATH        >>A(B|C)<<                            │   └─┬▶ walker segunda ruta
      trekking SIMPLE      >>A<<                                 │     ├──> primer constructor : caracter
      trekking GROUP       >>B|C<<                               │     └─┬> segundo constructor: agrupacion
      walker   init        >>B|C<<                               │       ├──▶ walker recursivo
      walker   PATH        >>B<<                                 │       ├─┬▶ walker primer ruta
      trekking SIMPLE      >>B<<                                 │       │ └──> optiene el constructor
      walker   PATH        >>C<<                                 │       └─┬▶ walker segunda ruta
      trekking SIMPLE      >>C<<                                 │         └──> optiene el constructor
      walker   PATH        >>1234(ea|eb|ec)<<                    └─┬▶ walker segunda ruta
      trekking SIMPLE      >>1234<<                                ├──> primer constructor : caracter
      trekking GROUP       >>ea|eb|ec<<                            └─┬> segundo constructor: agrupacion
      walker   init        >>ea|eb|ec<<                              ├──▶ walker recursivo
      walker   PATH        >>ea<<                                    ├─┬▶ walker primer ruta
      trekking SIMPLE      >>ea<<                                    │ └──> optiene el constructor
      walker   PATH        >>eb<<                                    ├─┬▶ walker segunda ruta
      trekking SIMPLE      >>eb<<                                    │ └──> optiene el constructor
      walker   PATH        >>ec<<                                    └─┬▶ walker tercer ruta
      trekking SIMPLE      >>ec<<                                      └──> optiene el constructor
    < example..

    En la siguiente seccion activaremos pruebas que no necesiten interpretar lo
    que realiza el motor. En su lugar, comprobaremos el resultado de la busqueda
    (ﾟヮﾟ).

*** match

    ( ︶︿︶) ... ... ... veamos, las secciones anteriores mostraron como
    optener algunos constructores de la regexp uno a uno de forma consecutiva y
    de izquierda a derecha. Segun el algoritmo debemos comparar la posicion de
    inicio de la cadena con el primer constructor si es correcto avanzar atraves
    de ambos, y mientras el patron se encuentre en la exprecion repetir este
    proceso hasta agotar los constructores, si esta ocurre el motor debe
    informar que ha encontrado una coincidencia.

    Necesario es, que el motor pueda @"(caminara) atraves de la cadena, para
    esto debe conocer donde inicia la cadena, su extencion y posicion dentro de
    esta.

    Podemos agrupar las caracteristicas de la cadena en una misma entidad
    mediante una estructura:

    ..src > c
      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      }
    < src..

    Necesitamos una instancia de la estructura @c(TEXT) con la cadena de
    busqueda, inicializarla deberia ser parte de @c(regexp), luego @c(walker)
    (que se encarga de las rutas) debe @e(guardar) la posicion de inicio, si la
    ruta falla restaurar dicha posicion y si existe intentar con otra ruta.

    Al codigo (⌐■_■)  >

    ..src > c
      #include <string.h>
      #include <stdio.h>

      #define TRUE  1
      #define FALSE 0

      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      } static text;

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int  walker       ( struct RE  rexp );
      static int  trekking     ( struct RE *rexp );
      static int  tracker      ( struct RE *rexp, struct RE *track );
      static int  cutTrack     ( struct RE *rexp, struct RE *track, int type );

      static void trackByLen   ( struct RE *rexp, struct RE *track, int len, int type );
      static void fwrTrack     ( struct RE *track, int len );
      static char *trackerPoint( char *points, char *track, int len );

      static int match( struct RE *rexp );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        text.ptr     = txt;
        text.len     = strlen( txt );
        text.pos     = 0;

        return walker( rexp );
      }

      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   init", rexp.len, rexp.ptr );
        for( const int oPos = text.pos; cutTrack( &rexp, &track, PATH ); text.pos = oPos ){
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          if( trekking( &track ) ) return TRUE;
        }

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;
        int forward;

        while( tracker( rexp, &track ) )
          switch( track.type ){
          case GROUP:
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            if( walker( track ) == FALSE ) return FALSE;
            break;
          case HOOK :
            printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
            if( walker( track ) == FALSE ) return FALSE;
            break;
          default :
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
            if( text.pos < text.len && (forward = match( &track )) )
              text.pos += forward;
            else return FALSE;
          }

        return TRUE;
      }

      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track      = *rexp;
        track->type = type;
        if( type != PATH ) fwrTrack( track, 1 );

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          switch( rexp->ptr[i] ){
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          }

          switch( type ){
          case HOOK    : cut = deep == 0; break;
          case GROUP   : cut = deep == 0; break;
          case PATH    : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );
        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case '(': cutTrack  ( rexp, track, GROUP ); break;
        case '<': cutTrack  ( rexp, track, HOOK  ); break;
        default :
          if( (point = trackerPoint( "(<", rexp->ptr + 1, rexp->len - 1 )) )
            trackByLen( rexp, track, point - rexp->ptr, SIMPLE  );
          else trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

        return TRUE;
      }

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
        *track       = *rexp;
        track->type  = type;
        track->len   = len;
        fwrTrack( rexp, len );
      }

      static void fwrTrack( struct RE *track, int len ){
        track->ptr += len; track->len -= len;
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }

      static int match( struct RE *rexp ){
        int result = strncmp( text.ptr + text.pos, rexp->ptr, rexp->len ) == 0 ? rexp->len : 0;
        printf( "match    %-11s rexp[%.*s]\n"
                "         %-11s text[%.*s]\n",
                result ? "OK" : "FAIL", rexp->len, rexp->ptr, "", rexp->len, text.ptr + text.pos );
        return  result;
      }
    < src..

    El avance atraves de la regexp ya tiene un orden apropiado, para que este se
    coordine con el avance por la cadena simplemente devemos sumar el numero de
    caracteres que coinciden a la posicion de la cadena esto se ve en la funcion
    @c(trekking)

    ..src > c
      static int trekking( struct RE *rexp ){
        struct RE track;
        int forward;

        while( tracker( rexp, &track ) )
          switch( track.type ){
          case GROUP:
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            if( walker( track ) == FALSE ) return FALSE;                           // ➊
            break;
          case HOOK :
            printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
            if( walker( track ) == FALSE ) return FALSE;                           // ➋
            break;
          default :
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
            if( text.pos < text.len && (forward = match( &track )) )               // ➌
              text.pos += forward;                                                 // ➍
            else return FALSE;                                                     // ➎
          }

        return TRUE;
      }
    < src..

    en especifico en ➍. De momento solo podemos buscar caracteres en la
    cadena, de echo no podemos comprar elementos no especificos, las
    agrupaciones y rutas mas que elementos de comparacion son instrucciones para
    el motor.

    Una ves tenemos una ruta de ejecucion, debemos agotar los constructores que
    la conforman. Si los patrones del contructor no coinciden con la cadena no
    tiene sentido ir al constructor anterior. Por esto la fucion no almacena la
    niguna posocion, solo conoce la posicion actual en la cadena.

    La comparacion contra un construtor caracter deberia fallar ➎ si:

    - no hay caracteres a comprar, es decir el constructor esta vacio, o se ha
      llegado al final de la cadena ➌ (@c(text.pos < text.len)).

    - Si no coinciden los caracteres con la cadena ➌ (@c[(forward = match(
      &track ))]).


    La comparacion de constructores de tipo agrupacion deberia fallar si:

    - Ninguna de las rutas que cotiene, coincide con la cadena ➊➋.
      Convenientemente ya tenemos una funcion que cumple con esta labor.


    Cuando el recorrido por una ruta falla, debemos proporcionar la misma
    posicion de inicio para la siguiente ruta. Hacer esto en el codigo require
    de una sola linea:

    ..src > c
      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   init", rexp.len, rexp.ptr );
        for( const int oPos = text.pos; cutTrack( &rexp, &track, PATH ); text.pos = oPos ){ // ➊
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          if( trekking( &track ) ) return TRUE;                                             // ➋
        }

        return FALSE;
      }
    < src..

    Antes de realizan niguna accion, almacenamos la posicion actual de la cadena
    ➊ (@c(const int oPos = text.pos)). Mientras existan rutas que recorrer se
    envian a @c(tekking), si el recorrido de la ruta se completa se informa la
    coincidencia del patron ➋. De lo contrario reestablecemos la posicion
    original de la cadena para el siguiente recorrido (@c(text.pos = oPos)).

    La coordinacion entre estas dos funciones es ridiculamente
    sencillo. (⌐□ل͜□)ง? porque la estructura que almacena la cadena es global? no
    es mejor pasar una instancia de la cadene a cada fucion?

    ..src > c
      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      } static text;  // ᕙ༼ຈل͜ຈ༽
    < src..

    De hecho podriamos hacerlo de dos formas

    - declarar la estructura @c(TEXT) dentro de @c(regexp3) y que las funciones
      resivan un puntero a esta estructura

    - o, cada funcion podria resivir su propia copia de la estructura


    En ambos casos, necesitariamos que el compilador nos consiga memoria para el
    argumento adicional. Mantener aislado el funcionamiento de una funcion con
    respecto de otra ayuda a tener codigo portable, pero en este caso tan
    especifico no vale la pena aumentar el numero de instrucciones necesarias,
    supongo.

    Veamos como se establecen los valores de la cadena

    ..src > c
      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        text.ptr     = txt;            // ➊
        text.len     = strlen( txt );  // ➋
        text.pos     = 0;              // ➌

        return walker( rexp );
      }
    < src..

    El inicio coincide con el inicio, la longitud coincide con la logitud y la
    posicion esta en el primer caracter \_(ʘ_ʘ)_/. Es decir solo se examina la
    primer posicion de la cadena. Apliquemos una prueba, en @c(main)
    (@f(test.c)) coloca lo siguiente:

    ..src > c
      int main(){
        if( regexp3( "123gh", "123(ab|cd|ef|gh)") ) puts( "(\\/)(^-^)(\\/)" );
        else                                        puts( "t(-.-t)" );

        return 0;
      }
    < src..

    compila y ejecuta (@c(gcc -Wall test.c && ./a.out))

    este es el resultado (modifique la indentacion para mas claridad):

    ..example >
      walker   init        >>123(ab|cd|ef|gh)<<     ┌──▶ walker inicial
      walker   PATH        >>123(ab|cd|ef|gh)<<     └─┬▶ walker primer ruta
      trekking SIMPLE      >>123<<                    ├─┬> primer constructor: caracter
      match    OK       rexp[123]                     │ └──▶ comparacion
                        text[123]                     │
      trekking GROUP           >>ab|cd|ef|gh<<        └─┬▶ segundo constructor: agrupacion
      walker   init            >>ab|cd|ef|gh<<          ├──▶ walker recursivo
      walker   PATH            >>ab<<                   ├─┬▶ walker primer ruta   ➊
      trekking SIMPLE          >>ab<<                   │ └─┬> primer constructor: caracter
      match    FAIL         rexp[ab]                    │   └──▶ comparacion
                            text[gh]                    │
      walker   PATH               >>cd<<                ├─┬▶ walker segunda ruta  ➋
      trekking SIMPLE             >>cd<<                │ └─┬> primer constructor: caracter
      match    FAIL            rexp[cd]                 │   └──▶ comparacion
                               text[gh]                 │
      walker   PATH                  >>ef<<             ├─┬▶ walker tercer ruta   ➌
      trekking SIMPLE                >>ef<<             │ └─┬> primer constructor: caracter
      match    FAIL               rexp[ef]              │   └──▶ comparacion
                                  text[gh]              │
      walker   PATH                     >>gh<<          └─┬▶ walker cuarta ruta   ➍
      trekking SIMPLE                   >>gh<<            └─┬> primer constructor: caracter
      match    OK                    rexp[gh]               └──▶ comparacion
                                     text[gh]
      (\/)(^-^)(\/)
    < example..

    La prueba regresa @c(TRUE) y por el registro que deja parece que todo
    funciona correctamente, en especial el recorrido por las rutas. Podemos
    comprobar que la posicion de inicio de la cadena es la misma para cada ruta
    ➊➋➌➍.

    Para terminar esta seccion apliquemos una bateria algo exaustiva de
    pruebas. Modifica el contenido de @c(test.c) a esto:

    ..src > c
      #include <stdio.h>

      #include "regexp3.h"

      int raptorTest(){
        int result = 0;
        int errs   = 0;
        int total  = 0;

      #define NTEST( text, re, n )                            \
        result = regexp3( text, re );                         \
        total++;                                              \
        if( result != n ){                                    \
          printf( "%s:%d Error on N-TEST >%s< >%s<\n",        \
                  __FILE__, __LINE__, text, re );             \
          printf( "results %d - %d expected\n", result, n );  \
          errs++;                                             \
        }

        NTEST( "a", "a", 1 );
        NTEST( "aa", "aa", 1 );
        NTEST( "raptor", "raptor", 1 );
        NTEST( "a", "(a)", 1 );
        NTEST( "a", "<a>", 1 );
        NTEST( "a", "((a))", 1 );
        NTEST( "a", "<<a>>", 1 );
        NTEST( "a", "((((((a))))))", 1 );
        NTEST( "a", "<<<<<<a>>>>>>", 1 );
        NTEST( "a", "b|a", 1 );
        NTEST( "a", "c|b|a", 1 );
        NTEST( "a", "(b|a)", 1 );
        NTEST( "a", "(c|b|a)", 1 );
        NTEST( "a", "(c|b)|a", 1 );
        NTEST( "a", "((<c>|<b>)|a)", 1 );
        NTEST( "raptor", "b|raptor", 1 );
        NTEST( "raptor", "c|b|raptor", 1 );
        NTEST( "raptor", "(b|raptor)", 1 );
        NTEST( "raptor", "(c|raptor)|a", 1 );
        NTEST( "raptor", "((<c>|<raptor>)|a)", 1 );
        NTEST( "ab", "a(b|c)|A(B|C)", 1 );
        NTEST( "ac", "a(b|c)|A(B|C)", 1 );
        NTEST( "AB", "a(b|c)|A(B|C)", 1 );
        NTEST( "AC", "a(b|c)|A(B|C)", 1 );
        NTEST( "ab", "a<b|c>|A<B|C>", 1 );
        NTEST( "ac", "a<b|c>|A<B|C>", 1 );
        NTEST( "AB", "a<b|c>|A<B|C>", 1 );
        NTEST( "AC", "a<b|c>|A<B|C>", 1 );
        NTEST( "ab"    , "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "ac"    , "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "AB"    , "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "AC"    , "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "ab"    , "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "ac"    , "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "AB"    , "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "AC"    , "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "1234ea", "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "1234eb", "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "1234ec", "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "1234ea", "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "1234eb", "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "1234ec", "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "abd", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "abe", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "acd", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ace", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ABD", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ABE", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ACD", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ACE", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "raptor", "(c|r)(e|a)(p|q)(t|u)(0|o)(t|r)", 1 );

        printf( "TEST %d *** ERRS %d\n\n", total, errs );
        return !errs;
      }

      int main(){
        if( raptorTest() ) puts( "I am the Raptor" );

        return 0;
      }
    < src..

    Compila y ejecuta. En mi sistema todas las pruebas fueron correctas.

    La funcion de la macro @c(NTEST), es realizar la prueba y comprobar que el
    numero de coincidencias es el esperado, de lo contrario despliega un mensaje
    de error, con el numero de linea, el fichero, la prueba y el resultado
    optenido y el esperado.

    Ninguna bateria de pruebas es suficiente, siempre pueden presentarse casos
    imprevistos, por ejemplo, como reaciona el motor ante un conjunto o una ruta
    vacia? que deberia hacer cuando la cadena o la regexp son apuntadores
    vacios? despues de una coincidencia deberia consultarse el siguiente
    caracter de la cadena o continuar al final de la coincidencia?. Las
    respuestas a estos misterios y mucho mas en el proximo capitulo!

    :: PS ::

       Eliminare todos los mensajes que se producen en @f(regexp3.h) apartir de
       la siguiente seccion, son bastate molestos. Si bien podrian suprimirse
       colacando el codigo dentro de directivas de compilacion condicional,
       cosidero que estas solo enturbian la estructura del codigo.

       Una vez te familiarices con el codigo, no necesitaras mas mensajes que
       los que se producen en las pruebas. Inteta a eliminar los mesajes por tu
       cuenta.

*** loops

    El motor ya puede realizar busquedas reales, pero se limitan solo a la
    primer posicion de la cadena. En esta seccion mostrare como localizar todas
    las coincidencias de la cadena, con apenas unas lineas mas, ademas se
    agregara una nueva caracteristica @e(cuantificadores).

    (´・ω・)っ Al codigo

    ..src > c
      #include <ctype.h>
      #include <string.h>
      #include <stdlib.h>

      #define TRUE            1
      #define FALSE           0
      #define INF    1073741824 // 2^30

      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      } static text;

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
        unsigned int loopsMin, loopsMax;
      };

      static int  walker       ( struct RE  rexp );
      static int  trekking     ( struct RE *rexp );
      static int  looper       ( struct RE *rexp );
      static int  tracker      ( struct RE *rexp, struct RE *track );
      static int  cutTrack     ( struct RE *rexp, struct RE *track, int type );

      static void trackByLen   ( struct RE *rexp, struct RE *track, int len, int type );
      static void getLoops     ( struct RE *rexp, struct RE *track );
      static void fwrTrack     ( struct RE *track, int len );

      static int  countCharDigits( char *str );
      static char *trackerPoint  ( char *points, char *track, int len );

      static int match( struct RE *rexp );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        text.len     = strlen( txt );

        if( text.len == 0 || rexp.len == 0 ) return 0;

        for( int forward, i = 0, loops = text.len; i < loops; i += forward ){
          forward    = 1;
          text.pos   = 0;
          text.ptr   = txt   + i;
          text.len   = loops - i;

          if( walker( rexp ) ){
            result++;
            if( text.pos > 0 ) forward = text.pos;
          }
        }

        return result;
      }

      static int walker( struct RE rexp ){
        struct RE track;

        for( const int oPos = text.pos; cutTrack( &rexp, &track, PATH ); text.pos = oPos )
          if( trekking( &track ) ) return TRUE;

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;
        while( tracker( rexp, &track ) )
          if( looper( &track ) == FALSE ) return FALSE;

        return TRUE;
      }

      static int looper( struct RE *rexp ){
        int steps, loops = 0;

        switch( rexp->type ){
        case HOOK: case GROUP: case PATH:
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:
          while( loops < rexp->loopsMax && text.pos < text.len && (steps = match( rexp )) ){
            text.pos += steps;
            loops++;
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;
      }

      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track      = *rexp;
        track->type = type;
        if( type != PATH ) fwrTrack( track, 1 );

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          switch( rexp->ptr[i] ){
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          }

          switch( type ){
          case HOOK    : cut = deep == 0; break;
          case GROUP   : cut = deep == 0; break;
          case PATH    : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );
        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case '(': cutTrack  ( rexp, track, GROUP ); break;
        case '<': cutTrack  ( rexp, track, HOOK  ); break;
        default :
          if( (point = trackerPoint( "(<?+*{", rexp->ptr + 1, rexp->len - 1 )) ){
            switch( *point ){
            case '(': case '<':
              trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;
            case '?': case '+': case '*': case '{':
              if( point - rexp->ptr == 1 )
                trackByLen( rexp, track, 1, SIMPLE  );
              else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  );
            }
          } else trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

        getLoops( rexp, track );
        return TRUE;
      }

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
        *track       = *rexp;
        track->type  = type;
        track->len   = len;
        fwrTrack( rexp, len );
      }

      static void fwrTrack( struct RE *track, int len ){
        track->ptr += len; track->len -= len;
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }

      static void getLoops( struct RE *rexp, struct RE *track ){
        track->loopsMin = 1; track->loopsMax = 1;
        int len = 0;

        if( rexp->len )
          switch( *rexp->ptr ){
          case '?' : len = 1; track->loopsMin = 0; track->loopsMax =   1; break;
          case '+' : len = 1; track->loopsMin = 1; track->loopsMax = INF; break;
          case '*' : len = 1; track->loopsMin = 0; track->loopsMax = INF; break;
          case '{' :
            track->loopsMin = atoi( rexp->ptr + 1 ) ;
            if( rexp->ptr[ 1 + countCharDigits( rexp->ptr + 1 ) ] == ',' )
              track->loopsMax = atoi( strchr( rexp->ptr, ',' ) + 1 );
            else
              track->loopsMax = track->loopsMin;

            len = strchr( rexp->ptr, '}' ) - rexp->ptr + 1;
          }

        fwrTrack( rexp, len );
      }

      static int countCharDigits( char *str ){
        for( int digits = 0; ; digits++ )
          if( isdigit( *str++ ) == 0 ) return digits;
      }

      static int match( struct RE *rexp ){
        return strncmp( text.ptr + text.pos, rexp->ptr, rexp->len ) == 0 ? rexp->len : 0;
      }
    < src..

    En primer lugar, se elimino el encabezado @c(<stdio.h>) y todas las
    intrucciones @c(printf).

    Un poco mas adelante de declara una nueva constante

    ..src > c
      #define INF   1073741824 // 2^30
    < src..

    se aparicion esta relacionada con dos nuevas variables que se agregan a la
    estrucura @c(RE)

    ..src > c
      unsigned int loopsMin, loopsMax;
    < src..

    y dos nuevas funciones @c(getLoops) y @c(looper). Examinemos @c(getLoops):

    ..src > c
      static void getLoops( struct RE *rexp, struct RE *track ){
        track->loopsMin = 1; track->loopsMax = 1;  // ➊
        int len = 0;

        if( rexp->len )
          switch( *rexp->ptr ){                    // ➋
          case '?' : len = 1; track->loopsMin = 0; track->loopsMax =   1; break;
          case '+' : len = 1; track->loopsMin = 1; track->loopsMax = INF; break;
          case '*' : len = 1; track->loopsMin = 0; track->loopsMax = INF; break;
          case '{' :                               // ➌
            track->loopsMin = atoi( rexp->ptr + 1 ) ;
            if( rexp->ptr[ 1 + countCharDigits( rexp->ptr + 1 ) ] == ',' )
              track->loopsMax = atoi( strchr( rexp->ptr, ',' ) + 1 );
            else
              track->loopsMax = track->loopsMin;

            len = strchr( rexp->ptr, '}' ) - rexp->ptr + 1;
          }

        fwrTrack( rexp, len );                     // ➍
      }
    < src..

    para nuestro motor, la cantidad de ocaciones (@e(cuatificadores)) que puede
    aparecer un constructor son una caracteristica del constructor. Esta
    cantidad se representa mediente un rago de repeticiones minimo-maximo en las
    variables @c(loopsMin) y @c(loopsMax) (miembros de la estructura @c(RE)).
    Como indica la funcion @c(getLoops) el rango por defecto es 1-1 ➊, es decir
    debe estar presente almenos una vez y no mas de 1 vez.

    Si el constructor cuenta con un cuantificador, El rango de repeticiones
    depende del tipo de cuantificador ➋. Para @c(?) el rango es 0-1, para @c(+)
    el rango es 1 a infinito, en este caso la forma mas sencilla de representar
    infinito, es con una cantidad absurdamente grande y corresponde a la
    cantidad de la constante @c(INF) (@m(2^30)). Por poner un ejemplo, si el
    constructor es de tipo caracter (un unico caracter) y la codificacion de
    caracteres es ASCII seria necesario un fichero con un @e(GiB) de caracteres
    consecutivos. Nuestro infinito no es inquebrantable, de ser necesario
    podriamos utilizar enteros de 64 bits, y subir el limite a @e(EiB)
    (@m(2^60)). Tambien utilizamos la constante @e(INF) para el signo @c(*) en
    este caso el rango es 0-INF.

    Para el signo @c({) ➌ tenemos las cosas mas complicadas, devemos averiguar
    si se trata de un rango, o un numero concreto, y luego asignar la cantidad
    al rango.

    Finalmente la exprecion se reccore para descartar los cuntificadores en la
    siguiente seccion ➍.

    (•̀o•́)ง ... eso significa que debemos coordinar a @c(tracker) con
    @c(getLoops)?  buueeeno, si el tipo de constructore fuese @c(GROUP) o
    @c(HOOK), el cuntificador de estar presente se encortraria final del
    constructor, solo haria falta llamar a @c(getLoops) despues de obtener el
    constructor. supongamos que tenemos la exprecion

    ..example >
      "(abc)+12?3<p-p>"
    < example..

    cuando @c(tracker) optiene el constructor agrupacion @c(abc), la exprecion
    original quedaria asi

    ..example >
      "+12?3<p-p>"
    < example..

    Si enviamos esta exprecion a @c(getLoops) junto al constructor, se asignaria @c(+)
    como cuantificador y ahora la exprecion seria esta

    ..example >
      "12?3<p-p>"
    < example..

    Sin embargo, si el cuantificador aparece en un constructor caracter o una
    serie consecutiva de caracteres (que es como los manjea nuestro motor),
    debemos identificar a que caracter se aplica el modificador, de otra forma
    el cuantificador afectaria a todos los caracteres previos.

    Veamos la solucion en forma de codigo

    ..src > c
      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case '(': cutTrack  ( rexp, track, GROUP ); break;
        case '<': cutTrack  ( rexp, track, HOOK  ); break;
        default :
          if( (point = trackerPoint( "(<?+*{", rexp->ptr + 1, rexp->len - 1 )) ){  // ➊
            switch( *point ){                                                      // ➋
            case '(': case '<':                                                    // ➌
              trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;        // ➍
            case '?': case '+': case '*': case '{':                                // ➎
              if( point - rexp->ptr == 1 )                                         // ➏
                trackByLen( rexp, track, 1, SIMPLE  );                             // ➐
              else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  );    // ➑
            }
          } else trackByLen( rexp, track, rexp->len, SIMPLE  );                    // ➒
        }

        getLoops( rexp, track );                                                   // ➓
        return TRUE;
      }
    < src..

    Primero necesitamos agregar los signos @c(?), @c(+), @c(*) y @c({) a la como
    puntos de rastreo ➊. Luego procedemos al corte segun el signo ➋. Si lo
    primero que se encuerta es un constructor de tipo agrupacion, significa que
    ningun caracter tiene cuatificadores, todos deben aparecer exactamente una
    vez (una simple cadena de caracteres) ➌, la cadena abarca desde el inicio
    hasta el signo de agrupacion ➍. Si encortramos un cuantificador ➎ y se
    encuerta en la segunda posicion (indice 1) ➏, cortamos el caracter dejando el
    cuantificador a @c(getLoops) ➐. Si la posicion delcuantificador es superior al
    indice 1, tratamos a todos los caracters @e(menos uno) como una simple
    cadena, el ultimo es al que se aplica el cuntificador ➑. Si no hay un punto
    de rastreo, el resto de la cadena es de tipo @c(SIMPLE) ➒.

    Una vez tenemos la seccion y el cuantificador coordinados, se envian a
    @c(getLoops) ➓. Pan comido (-‿-)✌

    Solo resta realizar los ciclos de repeticion corrector a cada constructor...

    ..src > c
      static int trekking( struct RE *rexp ){
        struct RE track;
        while( tracker( rexp, &track ) )                // ➊
          if( looper( &track ) == FALSE ) return FALSE; // ➋

        return TRUE;
      }
    < src..

    huuu!!!, @c(trekking) paso a la tercera edad, ahora es mas compacta y seca.

    La obligacion de @c(trekking) es comprobar la presencia de todos los
    constructores en la ruta en ejecucion. Optine los constructores ➊ y se
    asegura que esten presentes las @m(n) veces que se solicite con la funcion
    @c(looper).  si @c(looper) informa que el constructor no cumple con el
    requsito el patron de esta ruta ha fracasado ➋.

    ..src > c
      static int looper( struct RE *rexp ){
        int steps, loops = 0;

        switch( rexp->type ){                                  // ➊
        case HOOK: case GROUP: case PATH:                      // ➋
          while( loops < rexp->loopsMax && walker( *rexp ) )   // ➌
            loops++;                                           // ➍
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:             // ➎
          while( loops < rexp->loopsMax && text.pos < text.len && (steps = match( rexp )) ){  // ➏
            text.pos += steps;                                                                // ➐
            loops++;                                                                          // ➑
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;          // ➒
      }
    < src..

    @c(looper) opera de esta forma: realizamos ciclos sin revasar el limite
    superior (@(loopsMax)) ➌➏. A cada ciclo incrementamos el indice de ciclos en
    uno ➍➑. Cuando se alcanza el indice superior o el constructor no esta
    precente en la cadena termina el bucle; comprobamos que los ciclos sean
    superiores o iguales al minimo ➒ (@c(TRUE)) de lo contrario la prueba ha
    fallado (@c(FALSE)).

    La evaluacion de los constructores ➊ cuando son de tipo agrupacion ➋ queda
    acargo de la funcion @c(walker) (nunca llegara a @c(looper) un constructor
    de tipo @c(PATH), se incluye el caso para evitar una advertecia del
    compilador).

    El resto de constructores puede(?) verificarse directamete en la cadena ➎.
    La coincidencia de estos requiere un avance atraves de la cadena ➐. Aunque
    seria fuciente (y mas eficiente) con agruparlos en un caso @c(default) se
    opto por declarar todos los casos, en un intento de ser mas expresivos.

    Es necesario resaltar el echo de que las pruebas @c(walker) o @c(match)
    pueden fallar y aun asi la prueba ser satisfactoria, si el indice inferior
    (@c(loopsMin)) es cero. Se genera un avance en la cadena de @e(cero)
    caracteres.

    Hay otro @e(loop) que nos interesa: como enviar distintos puntos de inicio
    de la cadena y gestionar el avance en caso de coincidencia. Todo se reduce a
    un ciclo @c(for) dentro de @c(regexp3).

    ..src > c
      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;                                 // ➊
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        text.len     = strlen( txt );

        if( text.len == 0 || rexp.len == 0 ) return 0;    // ➋

        for( int forward, i = 0, loops = text.len; i < loops; i += forward ){ // ➌
          forward    = 1;                                 // ➍
          text.pos   = 0;                                 // ➎
          text.ptr   = txt   + i;                         // ➏
          text.len   = loops - i;                         // ➐

          if( walker( rexp ) ){                           // ➑
            result++;
            if( text.pos > 0 ) forward = text.pos;        // ➒
          }
        }

        return result;                                    // ➓
      }
    < src..

    ➊➍➎➑

    Si queremos conocer cuantas coincidencias hay en una cadena, debemos
    realizar la busqueda en todas las posiciones de esta, es decir, el numero de
    consultas depende de la longitud de la cadena ➌, a cada nueva consulta
    el inicio y longitud de la cadena se recorre en un caracter ➍➏➐, la posicion
    de inicio siempre es el primer caracter ➎. Contabilizamos el resultado de la
    buqueda con la variable @c(result) ➊, con cada coincidencia se incrementa en
    1. Al terminar informamos del numero de coincidencias ➐.

    Segun el resto de implementaciones regexp, cuando se localiza un patron, la
    siguiente busqueda continua al final de la coincidencia en la cadena. Esta
    posicion se corresponde con la posicion final de la cadena si se a
    localizado el patron. Si sumamos esta posicion (recuerda tine indice 0 con
    respecto a la seccion actual de la cadena, no de la cadena original) la
    siguiente consulta tendra el indice que buscamos ➒. Es necesaria la
    intruccion

    ..src > c
      if( text.pos > 0 )
    < src..

    pues si se consulta un constructor con un cuantificador que permite que el
    constructor aparesca cero veces, aunque el resultado es correcto si aparece
    cero veces el avance es de cero caracteres, por ejemplo

    ..src > c
      regexp3( "xx", "(yy)?" )
    < src..

    si el avance para el siguite ciclo es cero, la siguiente consulta tendra el
    mismo indice de inicio, y tendremos el mismo resultado una y otra vez en un
    bucle infinito. Para prevenir este caso el avance por defecto siempre es de
    un caracter a menos que alla una coincidencia y el numero de caracteres de
    la coincidencia sea almenos uno.

    el @"(problema) con los constructores que pueden aparecer cero veces, radica
    en al compararlos con una cadena de longitud cero (no hay cadena), deberian
    regresar una coincidencia. En esta implementacion si no recive una cadena
    o una exprecion con almenos un caracter, simplemente no regresa
    coincidencias ➋.

    Pasemos a las pruebas!

    agrega lo siguiente despues de la ultima prueba @c(NTEST) en @f(test.c)

    ..src > c
      NTEST( "",  "",  0 );
      NTEST( "", "a",  0 );
      NTEST( "a", "",  0 );
      NTEST( "a", "o", 0 );
      NTEST( "a", "a", 1 );
      NTEST( "aaa", "a", 3 );
      NTEST( "a", "aaa", 0 );
      NTEST( "a aaa aaa", "aaa", 2 );
      NTEST( "Raptor Test", "a", 1 );
      NTEST( "Raptor Test", "t", 2 );
      NTEST( "aeiou", "a|e|i|o|u", 5 );
      NTEST( "aeiou", "(a|e|i|o|u)", 5 );
      NTEST( "aeiou", "(a|e)|i|(o|u)", 5 );
      NTEST( "aeiou", "(a|(e))|(i|(o|u))", 5 );
      NTEST( "aa ae ai ao au", "a(a|e|i|o|u)", 5 );
      NTEST( "aa ae ai ao au", "a(0|1|2|3|4)", 0 );
      NTEST( "a1 a2 a3 ao au", "a(1|2|3|4|5)", 3 );
      NTEST( "a1 a2 a3 a4 a5", "a(1|2|3|4|5)", 5 );
      NTEST( "aa ae ai ao au", "a(a|e|i|o|u) ", 4 );
      NTEST( "aa ae Ai ao au", "A(a|e|i|o|u)", 1 );
      NTEST( "aa ae Ai ao au", "(A|a)(a|e|i|o|u)", 5 );
      NTEST( "aae aei Aio aoa auu", "(A|a)(a|e|i|o|u)(a|e|i|o|u)", 5 );

      NTEST( "aa aaaa aaaa", "a", 10 );
      NTEST( "aa aaaa aaaa", "aa", 5 );
      NTEST( "aa aaaa aaaa", "aaa", 2 );
      NTEST( "aa aaaa aaaa", "aaaa", 2 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a", 20 );
      NTEST( "abababababababababababababababababababab", "a"  , 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "(a)", 20 );
      NTEST( "abababababababababababababababababababab", "(a)", 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "<a>", 20 );
      NTEST( "abababababababababababababababababababab", "<a>", 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a+",   1 );
      NTEST( "abababababababababababababababababababab", "a+" , 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a?", 20 );
      NTEST( "abababababababababababababababababababab", "a?" , 40 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a*", 1 );
      NTEST( "abababababababababababababababababababab", "a*" , 40 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1}", 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1}", 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{5}", 4 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1,5}", 4 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{5,5}", 4 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{10}", 2 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1,100}", 1 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{001,00100}", 1 );
      NTEST( "abababababababababababababababababababab", "a{1}" , 20 );
      NTEST( "abababababababababababababababababababab", "a{001}" , 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1,1}", 20 );
      NTEST( "abababababababababababababababababababab", "a{1,1}" , 20 );
      NTEST( "abababababababababababababababababababab", "a{001,000001}" , 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{20}", 1 );
      NTEST( "abababababababababababababababababababab", "(a|b){1,1}" , 40 );

      NTEST( "abc", "<b>", 1 );
      NTEST( "abc", "a<b>", 1 );
      NTEST( "abc", "<b>c", 1 );
      NTEST( "abc", "a<b>c", 1 );
      NTEST( "abc", "<a|b>", 2 );
      NTEST( "abc", "<a|b|c>", 3 );
      NTEST( "abc", "<(a|b)|c>", 3 );
      NTEST( "aa aaaa aaaa", "<aa>", 5 );
      NTEST( "abc", "a<x>", 0 );
      NTEST( "abc", "<a>x", 0 );
      NTEST( "abc", "<a|b>x", 0 );
      NTEST( "abc", "<<a|b>x|abc>", 1 );
      NTEST( "abc", "<x<a|b>|abc>", 1 );
      NTEST( "abc abc abc", "<a|b|c>", 9 );
      NTEST( "abc abc abc", "<(a|b|c)(a|b|c)(a|b|c)>", 3 );
      NTEST( "abc abc abc", "<(a|b|c)(a|b|c)(a|b|c)> ", 2 );
      NTEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 3 );

      NTEST( "a", "a?", 1 );
      NTEST( "a", "b?", 1 );
      NTEST( "a", "a+", 1 );
      NTEST( "a", "a*", 1 );
      NTEST( "a", "b*", 1 );
      NTEST( "a", "aa?", 1 );
      NTEST( "a", "ab?", 1 );
      NTEST( "a", "aa+", 0 );
      NTEST( "a", "aa*", 1 );
      NTEST( "a", "ab*", 1 );
      NTEST( "a", "a{1,2}", 1 );
      NTEST( "aaa", "a+", 1 );
      NTEST( "aaa", "a*", 1 );
      NTEST( "aaa", "a+", 1 );
      NTEST( "aaa", "a?", 3 );
      NTEST( "aaab", "a+", 1 );
      NTEST( "aaab", "a*", 2 );
      NTEST( "aaab", "a?", 4 );
      NTEST( "aaab", "a+b", 1 );
      NTEST( "aaab", "a*b", 1 );
      NTEST( "aaab", "a?b", 1 );
      NTEST( "aaab", "a+b?", 1 );
      NTEST( "aaab", "a*b?", 1 );
      NTEST( "aaab", "a?b?", 3 );
      NTEST( "aaab", "a+b+", 1 );
      NTEST( "aaab", "a*b+", 1 );
      NTEST( "aaab", "a?b+", 1 );
      NTEST( "aaab", "a+b*", 1 );
      NTEST( "aaab", "a*b*", 1 );
      NTEST( "aaab", "a?b*", 3 );
      NTEST( "aaabaaa", "a+", 2 );
      NTEST( "aaabaaa", "a*", 3 );
      NTEST( "aaabaaa", "a*", 3 );
      NTEST( "aaabaaa", "a*", 3 );
      NTEST( "a", "(a)?", 1 );
      NTEST( "a", "(b)?", 1 );
      NTEST( "a", "(a)+", 1 );
      NTEST( "a", "(a)*", 1 );
      NTEST( "a", "(b)*", 1 );
      NTEST( "aaa", "(a)+", 1 );
      NTEST( "aaa", "(a)*", 1 );

      NTEST( "Raptor Test",     "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
      NTEST( "Raaaaptor TFest", "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
      NTEST( "CaptorTest",      "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
      NTEST( "Cap CaptorTest",  "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
      NTEST( "Rap Captor Fest", "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
    < src..

*** set & meta & point

    Tratar los conjuntos, implica manejar rangos. Los cambios necesarios para
    este constructor no eran suficientes como para justificar mostrar todo el
    codigo de nuevo, por ello a forma de extra, se incluye el manejo de
    metacaracteres y el constructor punto. Esto significa que al termino de esta
    seccion tendremos operativos todos los constructores basicos. Quedaran
    pendientes las capturas y los modificadores.

    (^-人-^) # code -mode ON

    ..src > c
      #include <ctype.h>
      #include <string.h>
      #include <stdlib.h>

      #define TRUE            1
      #define FALSE           0
      #define INF    1073741824 // 2^30

      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      } static text;

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
        unsigned int loopsMin, loopsMax;
      };

      static int  walker    ( struct RE  rexp );
      static int  trekking  ( struct RE *rexp );
      static int  looper    ( struct RE *rexp );
      static int  tracker   ( struct RE *rexp, struct RE *track );
      static int  cutTrack  ( struct RE *rexp, struct RE *track, int type );

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type );
      static void getLoops  ( struct RE *rexp, struct RE *track );
      static void fwrTrack  ( struct RE *track, int len );

      static int  walkMeta       ( char *str );
      static int  walkSet        ( char *str );
      static int  countCharDigits( char *str );
      static char *trackerPoint  ( char *points, char *track, int len );

      static int  match     ( struct RE *rexp );
      static int  matchSet  ( struct RE  rexp );
      static int  matchMeta ( struct RE *rexp, int   chr );
      static int  matchText ( struct RE *rexp, char *txt );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        text.len     = strlen( txt );

        if( text.len == 0 || rexp.len == 0 ) return 0;

        for( int forward, i = 0, loops = text.len; i < loops; i += forward ){
          forward    = 1;
          text.pos   = 0;
          text.ptr   = txt   + i;
          text.len   = loops - i;

          if( walker( rexp ) ){
            result++;
            if( text.pos > 0 ) forward = text.pos;
          }
        }

        return result;
      }

      static int walker( struct RE rexp ){
        struct RE track;

        for( const int oPos = text.pos; cutTrack( &rexp, &track, PATH ); text.pos = oPos )
          if( trekking( &track ) ) return TRUE;

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;
        while( tracker( rexp, &track ) )
          if( looper( &track ) == FALSE ) return FALSE;

        return TRUE;
      }

      static int looper( struct RE *rexp ){
        int steps, loops = 0;

        switch( rexp->type ){
        case HOOK: case GROUP: case PATH:
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:
          while( loops < rexp->loopsMax && text.pos < text.len && (steps = match( rexp )) ){
            text.pos += steps;
            loops++;
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;
      }

      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track      = *rexp;
        track->type = type;
        if( type != PATH ) fwrTrack( track, 1 );

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          i += walkMeta( rexp->ptr + i );

          switch( rexp->ptr[i] ){
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          case '[': i += walkSet( rexp->ptr + i ); break;
          }

          switch( type ){
          case HOOK : cut = deep == 0; break;
          case GROUP: cut = deep == 0; break;
          case SET  : cut =              rexp->ptr[i] == ']'; break;
          case PATH : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );
        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case ':': trackByLen( rexp, track, 2, META  ); break;
        case '.': trackByLen( rexp, track, 1, POINT ); break;
        case '(': cutTrack  ( rexp, track,    GROUP ); break;
        case '<': cutTrack  ( rexp, track,    HOOK  ); break;
        case '[': cutTrack  ( rexp, track,    SET   ); break;
        default :
          if( (point = trackerPoint( "(<[:.?+*{-", rexp->ptr + 1, rexp->len - 1 )) ){
            switch( *point ){
            case '(': case '<': case '[': case ':': case '.':
              trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;
            case '?': case '+': case '*': case '{': case '-':
              if( point - rexp->ptr == 1 ){
                if( *point == '-' ) trackByLen( rexp, track, 3, RANGEAB );
                else                trackByLen( rexp, track, 1, SIMPLE  );
              } else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  );
            }
          } else trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

        getLoops( rexp, track );
        return TRUE;
      }

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
        *track       = *rexp;
        track->type  = type;
        track->len   = len;
        fwrTrack( rexp, len );
      }

      static void fwrTrack( struct RE *track, int len ){
        track->ptr += len; track->len -= len;
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }

      static int walkSet( char *str ){
        int i = 0;
        while( TRUE )
          switch( str[ i ] ){
          case ']': return i;
          case ':': i += walkMeta( str + i ); break;
          default : i++   ; break;
          }
      }

      static int walkMeta( char *str ){
        for( int i = 0; ; i += 2 )
          if( str[i] != ':' ) return i;
      }

      static void getLoops( struct RE *rexp, struct RE *track ){
        track->loopsMin = 1; track->loopsMax = 1;
        int len = 0;

        if( rexp->len )
          switch( *rexp->ptr ){
          case '?' : len = 1; track->loopsMin = 0; track->loopsMax =   1; break;
          case '+' : len = 1; track->loopsMin = 1; track->loopsMax = INF; break;
          case '*' : len = 1; track->loopsMin = 0; track->loopsMax = INF; break;
          case '{' :
            track->loopsMin = atoi( rexp->ptr + 1 ) ;
            if( rexp->ptr[ 1 + countCharDigits( rexp->ptr + 1 ) ] == ',' )
              track->loopsMax = atoi( strchr( rexp->ptr, ',' ) + 1 );
            else
              track->loopsMax = track->loopsMin;

            len = strchr( rexp->ptr, '}' ) - rexp->ptr + 1;
          }

        fwrTrack( rexp, len );
      }

      static int countCharDigits( char *str ){
        for( int digits = 0; ; digits++ )
          if( isdigit( *str++ ) == 0 ) return digits;
      }

      static int match( struct RE *rexp ){
        switch( rexp->type ){
        case POINT  : return text.pos < text.len;
        case RANGEAB: return text.ptr[ text.pos ] >= rexp->ptr[ 0 ] &&
                             text.ptr[ text.pos ] <= rexp->ptr[ 2 ];
        case SET    : return matchSet ( *rexp );
        case META   : return matchMeta( rexp, text.ptr[text.pos]  );
        default     : return matchText( rexp, text.ptr + text.pos );
        }
      }

      static int matchText( struct RE *rexp, char *txt ){
        return strncmp( txt, rexp->ptr, rexp->len )  == 0 ? rexp->len : 0;
      }

      static int matchMeta( struct RE *rexp, int chr ){
        switch( rexp->ptr[1] ){
        case 'a' : return isalpha( chr ) != 0;
        case 'A' : return isalpha( chr ) == 0;
        case 'd' : return isdigit( chr ) != 0;
        case 'D' : return isdigit( chr ) == 0;
        case 'w' : return isalnum( chr ) != 0;
        case 'W' : return isalnum( chr ) == 0;
        case 's' : return isspace( chr ) != 0;
        case 'S' : return isspace( chr ) == 0;
        default  : return rexp->ptr[1] == chr;
        }
      }

      static char * strnChr( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( str[ i ] == chr ) return str + i;

        return 0;
      }

      static int matchSet( struct RE rexp ){
        struct RE track;
        int result = 0, reverse = *rexp.ptr == '^';

        if( reverse ) fwrTrack( &rexp, 1 );

        while( tracker( &rexp, &track ) ){
          switch( track.type ){
          case RANGEAB: case META: case POINT:
            result = match( &track ); break;
          default:
            result = strnChr( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
          }

          if( result ) return reverse ? FALSE : result;
        }

        return reverse ? TRUE : FALSE;
      }
    < src..

    Dejando de lado los nuevos prototipos de funcion, las modificaciones que nos
    interesan inician en @c(cutTrack)

    ..src > c
      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track      = *rexp;
        track->type = type;
        if( type != PATH ) fwrTrack( track, 1 );

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          i += walkMeta( rexp->ptr + i );                             // ➊

          switch( rexp->ptr[i] ){
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          case '[': i += walkSet( rexp->ptr + i ); break;              // ➋
          }

          switch( type ){
          case HOOK : cut = deep == 0; break;
          case GROUP: cut = deep == 0; break;
          case SET  : cut =              rexp->ptr[i] == ']'; break;  // ➌
          case PATH : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );
        return TRUE;
      }
    < src..

    la funcion @c(walkMeta) ➊, nos informa cuantos caracteres presentan la
    sintaxis de metacaracter de forma consecutiva (en nuestro motor, un
    metacarater se declara con el signo @c(:) seguido por cualquier
    caracter). La posicion de la instruccion, al igual que el conocer todos los
    metacaractes contiguos son de vital importancia.

    Si no coordinamos el avance por la exprecion podriamos cometer el error de
    evaluar el segundo elemento del metacaracter, situacion potencialmente
    peligrosa.

    Una situacion similar se presenta si analizamos el contenido de un conjunto.
    Recondemos que dentro de un conjunto signos como @c[(], @c[)], @c(|), @c(?),
    etc. no necesitan escaparse. Esto nos obliga a pasar de largo este
    constructor (en esta funcion) saltando directamente a su punto de cierre ➋.

    El ultimo cambio en esta funcion nos permite realizar el corte de una
    seccion de tipo conjunto (@c(SET)) (☞ﾟ∀ﾟ)☞ ➌. Si tienes dificultad para
    entender esta declaracion revisa la seccion @l(simple & group).

    Aqui esta la definicion del @c(walkMeta) y @c(walkSet)

    ..src > c
      static int walkSet( char *str ){
        int i = 0;
        while( TRUE )
          switch( str[ i ] ){
          case ']': return i;
          case ':': i += walkMeta( str + i ); break;
          default : i++   ; break;
          }
      }

      static int walkMeta( char *str ){
        for( int i = 0; ; i += 2 )
          if( str[i] != ':' ) return i;
      }
    < src..

    Su funcionamiento es bastante sencillo, en especial el de @c(walkMeta) de
    echo podriamos prescindir de ella. Elegi conservarla por que aporta
    expresividad al codigo, ademas si deseamos que los metacaracteres tenga una
    longitud y sintaxis distinta, este seria el punto al que acudir.

    @e(Nota) que ambas funciones operan con punteros, ademas no verifican ningun
    limite, Si la sintaxis que reciven no fuese apropiada se seguramente
    optendriamos un error de acceso. Por suerte todos todas las expreciones que
    resiva el motor seran meticulosamente examinadas por seres de elevada
    inteligencia!

    El el siguiente foco de modificacion se concentra en @c(tracker). Ahora debe
    identificar y optener tres nuevos constructores.

    ..src > c
      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case ':': trackByLen( rexp, track, 2, META  ); break;                // ➊
        case '.': trackByLen( rexp, track, 1, POINT ); break;                // ➋
        case '(': cutTrack  ( rexp, track,    GROUP ); break;
        case '<': cutTrack  ( rexp, track,    HOOK  ); break;
        case '[': cutTrack  ( rexp, track,    SET   ); break;                // ➌
        default :
          if( (point = trackerPoint( "(<[:.?+*{-", rexp->ptr + 1, rexp->len - 1 )) ){
            switch( *point ){
            case '(': case '<': case '[': case ':': case '.':
              trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;  // ➍
            case '?': case '+': case '*': case '{': case '-':
              if( point - rexp->ptr == 1 ){                                  // ➎
                if( *point == '-' ) trackByLen( rexp, track, 3, RANGEAB );   // ➏
                else                trackByLen( rexp, track, 1, SIMPLE  );   // ➐
              } else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  ); // ➑
            }
          } else trackByLen( rexp, track, rexp->len, SIMPLE  );              // ➒
        }

        getLoops( rexp, track );
        return TRUE;
      }
    < src..

    El @c(switch) principal no oculta su proposito, cada caso muestra de forma
    evidente nuestra intencion. Conocemos la sintaxis del constructor, la
    constante que prepresenta su tipo y la accion @c(cotar) (@c(cutTrack)) o
    @c(generar) (@c(trackByLen)) una seccion. Los nuevos constructores no son
    una exepcion ➊➋➌.

    (°_o) ?. Bueno el caso @c(default) no es tan sencillo de analizar, y es
    donde se incluye el corte de los rangos, pero no es inaccesible. El caso que
    estamos buscando ocurre cuando el punto que de rastreo esta en la posicion
    @c(1) de la exprecion ➑, y el caracter es @c(-) ➑. El resto de acciones
    dejan claro (o no) que estamos opteniendo cadenas de caracteres ➍➐➑➒.

    Si el funcionaminto de esta funcion aun genera incertidumbre, recuerda que
    su funcionamiento esta relacionado y en este orden con @c(walker),
    @c(cutTrack) y @c(trekking).

    Toca pues buscar los nuevos constructores en la cadena.

    Por medio de la funcion @c(looper), conocemos de antemano que los nuevos
    casos se comprueban mediente @c(match)

    ..src > c
      static int match( struct RE *rexp ){
        switch( rexp->type ){
        case POINT  : return text.pos < text.len;                        // ➊
        case RANGEAB: return text.ptr[ text.pos ] >= rexp->ptr[ 0 ] &&   // ➋
                             text.ptr[ text.pos ] <= rexp->ptr[ 2 ];
        case SET    : return matchSet ( *rexp );                         // ➌
        case META   : return matchMeta( rexp, text.ptr[text.pos]  );     // ➍
        default     : return matchText( rexp, text.ptr + text.pos );     // ➎
        }
      }
    < src..

    En @c(looper) ya conociamos el tipo de constructor, efectuar un @c(switch)
    adicional, dentro de @c(match) podria parecer redundante, sin embargo esta
    instruccion adicional y la llamada intermediaria a @c(match) ayuda a
    diminuir codigo en @c(looper) del estilo:

    ..src > c
      while( loops < rexp->loopsMax && text.pos < text.len && (steps = matchXXXX( rexp )) ){
        text.pos += steps;
        loops++;
       }
    < src..

    donde @c(matchXXXX) seria la llamada especializada de cada caso. Mas
    adelante no muy lejos de aqui cuando se trate  la busqueda de los conjuntos
    veremos que este esquema ofrece una ventaja adicional.

    Analicemos el primer caso. En nuestro motor @c(POINT) coincide con cualquier
    caracter, por lo tanto si no se ha alcanzado el final de la cadena, tenemos
    una coincidencia ➊.

    Los rangos son igual de sencillos, comprobamos, mediante una evaluacion
    booleana el valor del caracter de la posicion actual de la cadena ➋. Para
    tener una coincidencia su valor debe ser mayor o igual al limite inferir del
    rango (primer elemento del rango, indice 0) y a su vez menor o igual al
    limite superior (tercer elemento del rango indice 2). Recordemos que la
    cadena que define un rango de caracteres esta forrmada por tres caracters y
    el segundo elemento es el signo @c(-).

    ʕ´•ᴥ•`ʔ y para este constructor no veficamos antes estar dentro del limite
    da la cadena? no esperaba menos, en efecto, podriamos colocar un @c(if)
    antes del @c(switch) que verifique el limite. y una instruccion @c(return
    FALSE) al final de la funcion... o dentro de @c(looper) ☜(ﾟ∀ﾟ✌) colocar esta
    condicion antes de realizar la cosulta, como hemos venido haciendo desde que
    aparecio @c(match) en el codigo.

    Por orden de complejidad, seguiria el caso @c(default)

    ..src > c
      static int matchText( struct RE *rexp, char *txt ){
        return strncmp( txt, rexp->ptr, rexp->len )  == 0 ? rexp->len : 0;
      }
    < src..

    en esencia es el @c(match) de la seccion previa con un nombre distinto. Pese
    a que utilizar @c(defualt) es apropiado, se utilizo en lugar de @c(SIMPLE)
    para suprimir advertencias del compilador.

    Continuemos con los metacaracteres

    ..src > c
      static int matchMeta( struct RE *rexp, int chr ){
        switch( rexp->ptr[1] ){                 // ➊
        case 'a' : return isalpha( chr ) != 0;  // ➋
        case 'A' : return isalpha( chr ) == 0;  // ➌
        case 'd' : return isdigit( chr ) != 0;  // ➍
        case 'D' : return isdigit( chr ) == 0;  // ➎
        case 'w' : return isalnum( chr ) != 0;  // ➏
        case 'W' : return isalnum( chr ) == 0;  // ➐
        case 's' : return isspace( chr ) != 0;  // ➑
        case 'S' : return isspace( chr ) == 0;  // ➒
        default  : return rexp->ptr[1] == chr;  // ➓
        }
      }
    < src..

    En nuestro motor un meta caracter esta formado por dos caracteres, el
    indicador de metacaracter ':' y el metacaracter en si. El primer paso es
    averiguar el metacarater ➊, luego segun el caso realizamos una accion
    especifica segun los metacracteres que deseemos implementar. En esta
    implementacion son

    - (@c(a)) cualquier caracter en el rango a-z o A-Z ➋.
    - (@c(A)) cualquier caracter que no este en el rango a-z o A-Z ➌.
    - (@c(d)) cualquier caracter en el rango 0-9 ➍.
    - (@c(D)) cualquier carácter que no este en el rango 0-9 ➎.
    - (@c(w)) cualquier carácter alfanumérico ➏.
    - (@c(W)) cualquier carácter no alfanumérico ➐.
    - (@c(s)) cualquier caracter que sea un espacio en blanco ➑.
    - (@c(S)) cualquier carácter que no sea un espacio en blanco ➒.


    Afortunadamente, la libreria @c(ctype) incluye funciones para evaluar estos
    casos. Lamentablemente el valor que retornan en cado de acierto es demasiado
    ambiguo, segun se lee en el manual

    ..quote >
       Los valores devueltos son no-cero si el carácter cae dentro de la clase
       pedida, y cero si no.
    < quote..

    Es decir exepto cuando el caracter no cae dentro de la clasificacion, nos
    puede regresar el valor que les venga en gana. Haran uso de un generador de
    numeros aleatorios y luego una verificacion de que el valor no sea cero para
    cumplir la especificacion? Ni idea. La solucion mas sencilla es aplicar una
    evaluacion booleana al retorno.

    Todos los casos no definidos (@c[(], @c[)], @c([), @c(]), ..., etc.), se
    tratan como simples caracteres ➓.

    Por cierto, esta funcion (como el resto de las tipo @c(match)) regresa la
    cantidad de caracteres que coinciden. Esta caracteristica nos permite
    implementar metacaracteres que comparen mas de un caracter, podrian ser dos,
    tres o de la longitud que se nos ocurra, incluso si lo gestionamos bien
    expresiones regulares!.

    El caso @c(SET) para los constructores conjunto, es de lejos el mas
    complejo. La expresion que almacena sigue sin procesar, sumado a esto tine
    un modificador que no tiene ningun otro constructor, @e(la negacion).

    ..src > c
      static int matchSet( struct RE rexp ){               // ➊
        struct RE track;
        int result = 0, reverse = *rexp.ptr == '^';        // ➋

        if( reverse ) fwrTrack( &rexp, 1 );                // ➌

        while( tracker( &rexp, &track ) ){                 // ➍
          switch( track.type ){
          case RANGEAB: case META: case POINT:
            result = match( &track ); break;               // ➎
          default:
            result = strnChr( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;  // ➏
          }

          if( result ) return reverse ? FALSE : result;    // ➐
        }

        return reverse ? TRUE : FALSE;                     // ➑
      }
    < src..

    Es interesante desde el argumento. Al igual que @c(walker) opera con una
    copia de la estructura @c(RE) ➊. Necesitamos optener los componentes de la
    exprecion, no obstante estos se descartan de la expresion original a medida
    que se optinen ➍. Si manejaramos un puntero en lugar de una copia y el
    constructor requiriera mas de un ciclo de repeticion en el sugundo ciclo la
    eprecion estaria imcompleta o vacia y el resultado seria incorrecto.

    Es valido que existan metacaracteres dentro de los conjuntos, ya que el
    numero de caracteres con el que pueden coincider es arbitrario necesitamos
    almacenar el resultado. Ademas debemos activar el modificador de negacion
    (@c(reverse)) si el primer caracter del conjunto es el signo @c(^) ➋, si es
    el caso, se descarta de la expresion avanzando un caracter ➌.

    Ya disponemos de una funcion capas de generar todos los componentes de una
    exprecion (exepto rutas), solo hace falta verificarlo uno a uno hasta hasta
    optener una coincidencia o hasta agotar los componentes.

    Si terminamos el bucle @c(while) sin ninguna coincidencia se devuelve
    @c(FALSE) a menos que @c(reverse) este activo, en ese caso devolvemos
    @c(TRUE) ➑.

    Si hay una coincidencia devolvemos @c(TRUE) a menos que @c(reverse) este
    activo, en ese caso devolvemos @c(FALSE) ➐.

    La evalucion de cada componente depende de su tipo... alucinantes
    recursiones, echamos mano de @c(match) ➎ al examinar rangos, metacaracteres
    y @e(punto)? (ha, por que no?). No podemos hacero lo mismo con las
    secuencias de caracteres. Es necesario comparar caracter a caracter de la
    expresion con el caracter de la cadena. (⌐□ل͜□)ง ya tenimos una funcion que
    hacia esto al inicio del motor y luego se transformo en @c(trackerPoint) se
    llamaba @c(strnChr). GFO!

    (ಠ_ಠ)┘ ? pero, al utilizar @e(tracker) tambien se generan el resto de
    constructores, seria necesario aplicar escapes a cada signo relevante!... No
    solo eso  que @e(tracker) reconosca todos los constructores hace que existan
    rangos fuera de las agrupaciones!

    ( ͡° ͜ʖ ͡°) ... insignificancias, las considero una @"(caracteristica) o desde
    tu punto de vista, un inconveniente de facil solucion. Solo hay que eliminar
    el reconocimiento de rangos de @c(tracker) e implementar un @c(tracker)
    especifico para los rangos.

    (っ◕‿◕)っ (づ｡◕‿‿◕｡)づ (ノಠ益ಠ)ノ (ノ・∀・)ノ (Todos: ¡Felicidades Shinji!)

    Ya esta listo nuestro motor regexp 100% funcional (con caracteristicas
    incluidas) ... <(^-^!)> ehh, faltan 4 secciones mas, una serie de peliculas
    (Death, Rebirth, End, Revival), un Rebuild mal logrado, 19 años para que se
    termine el manga y derivados varios...

    Bueno, algunas pruebas (ya sabes, al final del ultimo @(NTEST) dentro de
    @f(test.c)):

    ..src > c
      NTEST( "a", ":a", 1 );
      NTEST( "a", ":A", 0 );
      NTEST( "a", ":d", 0 );
      NTEST( "a", ":D", 1 );
      NTEST( "a", ":w", 1 );
      NTEST( "a", ":W", 0 );
      NTEST( "a", ":s", 0 );
      NTEST( "a", ":S", 1 );
      NTEST( "A", ":a", 1 );
      NTEST( "A", ":A", 0 );
      NTEST( "A", ":d", 0 );
      NTEST( "A", ":D", 1 );
      NTEST( "A", ":w", 1 );
      NTEST( "A", ":W", 0 );
      NTEST( "A", ":s", 0 );
      NTEST( "A", ":S", 1 );
      NTEST( "4", ":a", 0 );
      NTEST( "4", ":A", 1 );
      NTEST( "4", ":d", 1 );
      NTEST( "4", ":D", 0 );
      NTEST( "4", ":w", 1 );
      NTEST( "4", ":W", 0 );
      NTEST( "4", ":s", 0 );
      NTEST( "4", ":S", 1 );
      NTEST( " ", ":a", 0 );
      NTEST( " ", ":A", 1 );
      NTEST( " ", ":d", 0 );
      NTEST( " ", ":D", 1 );
      NTEST( " ", ":w", 0 );
      NTEST( " ", ":W", 1 );
      NTEST( " ", ":s", 1 );
      NTEST( " ", ":S", 0 );
      NTEST( "\t", ":a", 0 );
      NTEST( "\t", ":A", 1 );
      NTEST( "\t", ":d", 0 );
      NTEST( "\t", ":D", 1 );
      NTEST( "\t", ":w", 0 );
      NTEST( "\t", ":W", 1 );
      NTEST( "\t", ":s", 1 );
      NTEST( "\t", ":S", 0 );

      NTEST( "abc", ":a", 3 );
      NTEST( "abc", ":A", 0 );
      NTEST( "abc", ":d", 0 );
      NTEST( "abc", ":D", 3 );
      NTEST( "abc", ":w", 3 );
      NTEST( "abc", ":W", 0 );
      NTEST( "abc", ":s", 0 );
      NTEST( "abc", ":S", 3 );
      NTEST( "ABC", ":a", 3 );
      NTEST( "ABC", ":A", 0 );
      NTEST( "ABC", ":d", 0 );
      NTEST( "ABC", ":D", 3 );
      NTEST( "ABC", ":w", 3 );
      NTEST( "ABC", ":W", 0 );
      NTEST( "ABC", ":s", 0 );
      NTEST( "ABC", ":S", 3 );
      NTEST( "123", ":a", 0 );
      NTEST( "123", ":A", 3 );
      NTEST( "123", ":d", 3 );
      NTEST( "123", ":D", 0 );
      NTEST( "123", ":w", 3 );
      NTEST( "123", ":W", 0 );
      NTEST( "123", ":s", 0 );
      NTEST( "123", ":S", 3 );
      NTEST( " \n\t", ":a", 0 );
      NTEST( " \n\t", ":A", 3 );
      NTEST( " \n\t", ":d", 0 );
      NTEST( " \n\t", ":D", 3 );
      NTEST( " \n\t", ":w", 0 );
      NTEST( " \n\t", ":W", 3 );
      NTEST( " \n\t", ":s", 3 );
      NTEST( " \n\t", ":S", 0 );
      NTEST( " \n\t", ":a", 0 );
      NTEST( " \n\t", ":A", 3 );
      NTEST( " \n\t", ":d", 0 );
      NTEST( " \n\t", ":D", 3 );
      NTEST( " \n\t", ":w", 0 );
      NTEST( " \n\t", ":W", 3 );
      NTEST( " \n\t", ":s", 3 );
      NTEST( " \n\t", ":S", 0 );

      NTEST( "abc", ":a+", 1 );
      NTEST( "abc", ":A+", 0 );
      NTEST( "abc", ":d+", 0 );
      NTEST( "abc", ":D+", 1 );
      NTEST( "abc", ":w+", 1 );
      NTEST( "abc", ":W+", 0 );
      NTEST( "abc", ":s+", 0 );
      NTEST( "abc", ":S+", 1 );
      NTEST( "ABC", ":a+", 1 );
      NTEST( "ABC", ":A+", 0 );
      NTEST( "ABC", ":d+", 0 );
      NTEST( "ABC", ":D+", 1 );
      NTEST( "ABC", ":w+", 1 );
      NTEST( "ABC", ":W+", 0 );
      NTEST( "ABC", ":s+", 0 );
      NTEST( "ABC", ":S+", 1 );
      NTEST( "123", ":a+", 0 );
      NTEST( "123", ":A+", 1 );
      NTEST( "123", ":d+", 1 );
      NTEST( "123", ":D+", 0 );
      NTEST( "123", ":w+", 1 );
      NTEST( "123", ":W+", 0 );
      NTEST( "123", ":s+", 0 );
      NTEST( "123", ":S+", 1 );
      NTEST( " \n\t", ":a+", 0 );
      NTEST( " \n\t", ":A+", 1 );
      NTEST( " \n\t", ":d+", 0 );
      NTEST( " \n\t", ":D+", 1 );
      NTEST( " \n\t", ":w+", 0 );
      NTEST( " \n\t", ":W+", 1 );
      NTEST( " \n\t", ":s+", 1 );
      NTEST( " \n\t", ":S+", 0 );
      NTEST( " \n\t", ":a+", 0 );
      NTEST( " \n\t", ":A+", 1 );
      NTEST( " \n\t", ":d+", 0 );
      NTEST( " \n\t", ":D+", 1 );
      NTEST( " \n\t", ":w+", 0 );
      NTEST( " \n\t", ":W+", 1 );
      NTEST( " \n\t", ":s+", 1 );
      NTEST( " \n\t", ":S+", 0 );

      NTEST( "aeiou", ":a", 5 );

      NTEST( "(((", ":(", 3 );
      NTEST( ")))", ":)", 3 );
      NTEST( "<<<", ":<", 3 );
      NTEST( ">>>", ":>", 3 );
      NTEST( ":::", "::", 3 );
      NTEST( "|||", ":|", 3 );
      NTEST( "###", ":#", 3 );
      NTEST( ":#()|<>", ":::#:(:):|:<:>", 1 );
      NTEST( ":#()|<>", "(::|:#|:(|:)|:||:<|:>)", 7 );
      NTEST( "(test1)(test2)", ":(test:d:)", 2 );

      NTEST( "",  ".",  0 );
      NTEST( "a", ".",  1 );
      NTEST( "aaa", ".", 3 );
      NTEST( "a", "...", 0 );
      NTEST( "a aaa aaa", ".", 9 );
      NTEST( "a aaa aaa", "...", 3 );
      NTEST( "a aaa aaa", ".aa", 2 );
      NTEST( "a aaa aaa", "aa.", 2 );
      NTEST( "Raptor Test", ".a", 1 );
      NTEST( "Raptor Test", ".t", 2 );
      NTEST( "Raptor Test", ".z", 0 );
      NTEST( "Raptor Test", "a.", 1 );
      NTEST( "Raptor Test", " .", 1 );
      NTEST( "Raptor Test", "z.", 0 );
      NTEST( "a", ".?", 1 );
      NTEST( "a", ".+", 1 );
      NTEST( "a", ".*", 1 );
      NTEST( "a", ".{1}", 1 );
      NTEST( "a aaa aaa", ".?", 9 );
      NTEST( "a aaa aaa", ".+", 1 );
      NTEST( "a aaa aaa", ".*", 1 );
      NTEST( "a aaa aaa", ".{1}", 9 );
      NTEST( "a", "a.?", 1 );
      NTEST( "a", "a.+", 0 );
      NTEST( "a", "a.*", 1 );
      NTEST( "a", "a.{1}", 0 );
      NTEST( "aeiou", "a|.", 5 );
      NTEST( "aeiou", "a|.?", 5 );
      NTEST( "aeiou", "a|.+", 2 );
      NTEST( "aeiou", "a|.*", 2 );
      NTEST( "aeiou", ".|a", 5 );
      NTEST( "aeiou", ".?|a", 5 );
      NTEST( "aeiou", ".+|a", 1 );
      NTEST( "aeiou", ".*|a", 1);
      NTEST( "aeiou", "(a|.)", 5 );
      NTEST( "aeiou", "(a|.?)", 5 );
      NTEST( "aeiou", "(a|.+)", 2 );
      NTEST( "aeiou", "(a|.*)", 2 );
      NTEST( "aeiou", "(.|a)", 5 );
      NTEST( "aeiou", "(.?|a)", 5 );
      NTEST( "aeiou", "(.+|a)", 1 );
      NTEST( "aeiou", "(.*|a)", 1);
      NTEST( "aeiou", "a|(.)", 5 );
      NTEST( "aeiou", "a|(.?)", 5 );
      NTEST( "aeiou", "a|(.+)", 2 );
      NTEST( "aeiou", "a|(.*)", 2 );
      NTEST( "aeiou", "(.)|a", 5 );
      NTEST( "aeiou", "(.?)|a", 5 );
      NTEST( "aeiou", "(.+)|a", 1 );
      NTEST( "aeiou", "(.*)|a", 1);
      NTEST( "aeiou", "a|(.)", 5 );
      NTEST( "aeiou", "a|(.)?", 5 );
      NTEST( "aeiou", "a|(.)+", 2 );
      NTEST( "aeiou", "a|(.)*", 2 );
      NTEST( "aeiou", "(.)|a", 5 );
      NTEST( "aeiou", "(.)?|a", 5 );
      NTEST( "aeiou", "(.)+|a", 1 );
      NTEST( "aeiou", "(.)*|a", 1);
      NTEST( "abababababababababababababababababababab", "." , 40 );
      NTEST( "abababababababababababababababababababab", "(a.)" , 20 );
      NTEST( "abababababababababababababababababababab", "(.a)" , 19 );
      NTEST( "abababababababababababababababababababab", "(:a.)" , 20 );
      NTEST( "abababababababababababababababababababab", "(.:a)" , 20 );
      NTEST( "abababababababababababababababababababab", "(.{5}:a{5})" , 4 );

      NTEST( "",  "a-z",  0 );
      NTEST( "a", "a-z",  1 );
      NTEST( "a", "A-Z",  0 );
      NTEST( "A", "A-Z",  1 );
      NTEST( "1", "a-z",  0 );
      NTEST( "1", "0-9",  1 );
      NTEST( "a", "0-9",  0 );
      NTEST( "A", "0-9",  0 );
      NTEST( "abc", "a-z", 3 );
      NTEST( "a", "a-za-za-z", 0 );
      NTEST( "a bcd efg", "a-z", 7 );
      NTEST( "a bcd efg", "a-za-za-z", 2 );
      NTEST( "a baa eaa", "a-zaa", 2 );
      NTEST( "a aad aag", "aaa-z", 2 );
      NTEST( "Raptor Test", "A-Za", 1 );
      NTEST( "Raptor Test", "a-zt", 2 );
      NTEST( "Raptor Test", "a-zz", 0 );
      NTEST( "Raptor Test", "aa-z", 1 );
      NTEST( "Raptor Test", " A-Z", 1 );
      NTEST( "Raptor Test", "za-z", 0 );
      NTEST( "a", "a-z?", 1 );
      NTEST( "a", "a-z+", 1 );
      NTEST( "a", "a-z*", 1 );
      NTEST( "a", "a-z{1}", 1 );
      NTEST( "a bcd efg", "a-z?", 9 );
      NTEST( "a bcd efg", "a-z+", 3 );
      NTEST( "a bcd efg", "a-z*", 5 );
      NTEST( "a bcd efg", "a-z{1}", 7 );
      NTEST( "a", "aa-z?", 1 );
      NTEST( "a", "aa-z+", 0 );
      NTEST( "a", "aa-z*", 1 );
      NTEST( "a", "aa-z{1}", 0 );
      NTEST( "aeiou", "a|a-z", 5 );
      NTEST( "aeiou", "a|a-z?", 5 );
      NTEST( "aeiou", "a|a-z+", 2 );
      NTEST( "aeiou", "a|a-z*", 2 );
      NTEST( "aeiou", "a-z|a", 5 );
      NTEST( "aeiou", "a-z?|a", 5 );
      NTEST( "aeiou", "a-z+|a", 1 );
      NTEST( "aeiou", "a-z*|a", 1);
      NTEST( "aeiou", "(a|a-z)", 5 );
      NTEST( "aeiou", "(a|a-z?)", 5 );
      NTEST( "aeiou", "(a|a-z+)", 2 );
      NTEST( "aeiou", "(a|a-z*)", 2 );
      NTEST( "aeiou", "(a-z|a)", 5 );
      NTEST( "aeiou", "(a-z?|a)", 5 );
      NTEST( "aeiou", "(a-z+|a)", 1 );
      NTEST( "aeiou", "(a-z*|a)", 1);
      NTEST( "aeiou", "a|(a-z)", 5 );
      NTEST( "aeiou", "a|(a-z?)", 5 );
      NTEST( "aeiou", "a|(a-z+)", 2 );
      NTEST( "aeiou", "a|(a-z*)", 2 );
      NTEST( "aeiou", "(a-z)|a", 5 );
      NTEST( "aeiou", "(a-z?)|a", 5 );
      NTEST( "aeiou", "(a-z+)|a", 1 );
      NTEST( "aeiou", "(a-z*)|a", 1);
      NTEST( "aeiou", "a|(a-z)", 5 );
      NTEST( "aeiou", "a|(a-z)?", 5 );
      NTEST( "aeiou", "a|(a-z)+", 2 );
      NTEST( "aeiou", "a|(a-z)*", 2 );
      NTEST( "aeiou", "(a-z)|a", 5 );
      NTEST( "aeiou", "(a-z)?|a", 5 );
      NTEST( "aeiou", "(a-z)+|a", 1 );
      NTEST( "aeiou", "(a-z)*|a", 1);
      NTEST( "1a2a3a4a5a6a", "1-6a", 6 );
      NTEST( "1a2a3a4a5a6a", "1-3a", 3 );
      NTEST( "1a2b3c4d5e6f", "1-6a-z", 6 );
      NTEST( "1a2b3c4d5e6f", "1-3a-z", 3 );
      NTEST( "abababababababababababababababababababab", "(aa-z)" , 20 );
      NTEST( "abababababababababababababababababababab", "(a-za)" , 19 );
      NTEST( "abababababababababababababababababababab", "(:aa-z)" , 20 );
      NTEST( "abababababababababababababababababababab", "(a-z:a)" , 20 );
      NTEST( "abababababababababababababababababababab", "(a-z{5}:a{5})" , 4 );

      NTEST( "",  "[a]",  0 );
      NTEST( "a", "[a]",  1 );
      NTEST( "a", "[.]",  1 );
      NTEST( ".", "[.]",  1 );
      NTEST( "a", "[A]",  0 );
      NTEST( "A", "[A]",  1 );
      NTEST( "1", "[A]",  0 );
      NTEST( "1", "[1]",  1 );
      NTEST( "a", "[:a]", 1 );
      NTEST( "A", "[:D]", 1 );
      NTEST( "aaa", "[a-z]", 3 );
      NTEST( "a", "[a-z][a-z][a-z]", 0 );
      NTEST( "a aaa aaa", "[a-z]", 7 );
      NTEST( "a aaa aaa", "[ a-z]", 9 );
      NTEST( "a aaa aaa", "[a-z][a-z][a-z]", 2 );
      NTEST( "a aaa aaa", "[a-z]aa", 2 );
      NTEST( "a aaa aaa", "aa[a-z]", 2 );
      NTEST( "Raptor Test", "[:w]a", 1 );
      NTEST( "Raptor Test", "[:w]t", 2 );
      NTEST( "Raptor Test", "[a-z]z", 0 );
      NTEST( "Raptor Test", "a[a-z]", 1 );
      NTEST( "Raptor Test", " [A-Z]", 1 );
      NTEST( "Raptor Test", "z[a-z]", 0 );
      NTEST( "a", "[a]?", 1 );
      NTEST( "a", "[a]+", 1 );
      NTEST( "a", "[a]*", 1 );
      NTEST( "a", "[a]{1}", 1 );
      NTEST( "a aaa aaa", "[a-z]?", 9 );
      NTEST( "a aaa aaa", "[a-z]+", 3 );
      NTEST( "a aaa aaa", "[a-z]*", 5 );
      NTEST( "a aaa aaa", "[a-z]{1}", 7 );
      NTEST( "a", "a[a-z]?", 1 );
      NTEST( "a", "a[a-z]+", 0 );
      NTEST( "a", "a[a-z]*", 1 );
      NTEST( "a", "a[a-z]{1}", 0 );
      NTEST( "aeiou", "a|[aeiou]", 5 );
      NTEST( "aeiou", "a|[aeiou]?", 5 );
      NTEST( "aeiou", "a|[aeiou]+", 2 );
      NTEST( "aeiou", "a|[aeiou]*", 2 );
      NTEST( "aeiou", "[aeiou]|a", 5 );
      NTEST( "aeiou", "[aeiou]?|a", 5 );
      NTEST( "aeiou", "[aeiou]+|a", 1 );
      NTEST( "aeiou", "[aeiou]*|a", 1);
      NTEST( "aeiou", "(a|[aeiou])", 5 );
      NTEST( "aeiou", "(a|[aeiou]?)", 5 );
      NTEST( "aeiou", "(a|[aeiou]+)", 2 );
      NTEST( "aeiou", "(a|[aeiou]*)", 2 );
      NTEST( "aeiou", "([aeiou]|a)", 5 );
      NTEST( "aeiou", "([aeiou]?|a)", 5 );
      NTEST( "aeiou", "([aeiou]+|a)", 1 );
      NTEST( "aeiou", "([aeiou]*|a)", 1);
      NTEST( "aeiou", "a|([aeiou])", 5 );
      NTEST( "aeiou", "a|([aeiou]?)", 5 );
      NTEST( "aeiou", "a|([aeiou]+)", 2 );
      NTEST( "aeiou", "a|([aeiou]*)", 2 );
      NTEST( "aeiou", "([aeiou])|a", 5 );
      NTEST( "aeiou", "([aeiou]?)|a", 5 );
      NTEST( "aeiou", "([aeiou]+)|a", 1 );
      NTEST( "aeiou", "([aeiou]*)|a", 1);
      NTEST( "aeiou", "a|([aeiou])", 5 );
      NTEST( "aeiou", "a|([aeiou])?", 5 );
      NTEST( "aeiou", "a|([aeiou])+", 2 );
      NTEST( "aeiou", "a|([aeiou])*", 2 );
      NTEST( "aeiou", "([aeiou])|a", 5 );
      NTEST( "aeiou", "([aeiou])?|a", 5 );
      NTEST( "aeiou", "([aeiou])+|a", 1 );
      NTEST( "aeiou", "([aeiou])*|a", 1);
      NTEST( "1a2a3a4a5a6a", "[1-6]a", 6 );
      NTEST( "1a2a3a4a5a6a", "[1-3]a", 3 );
      NTEST( "1a2b3c4d5e6f", "[123456][abcdef]", 6 );
      NTEST( "1a2b3c4d5e6f", "[123][abcdef]", 3 );
      NTEST( ".b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b", "[:.]",  20 );
      NTEST( ".b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b", "[:.b]",  40 );
      NTEST( "abababababababababababababababababababab", "(a[ab])" , 20 );
      NTEST( "abababababababababababababababababababab", "([ab]a)" , 19 );
      NTEST( "abababababababababababababababababababab", "(:a[ab])" , 20 );
      NTEST( "abababababababababababababababababababab", "([ab]:a)" , 20 );
      NTEST( "abababababababababababababababababababab", "([ab]{5}:a{5})" , 4 );
      NTEST( "()<>[]{}*?+", "[:(:):<:>:[:]:{:}:*:?:+]", 11 );
      NTEST( ")>}", "[)>}]", 3 );

      NTEST( "",  "[^a]",  0 );
      NTEST( "a", "[^1]",  1 );
      NTEST( "a", "[^a]",  0 );
      NTEST( "A", "[^a]",  1 );
      NTEST( "1", "[^1]",  0 );
      NTEST( "1", "[^A]",  1 );
      NTEST( "a", "[^:a]", 0 );
      NTEST( "A", "[^:A]", 1 );
      NTEST( "aaa", "[^z]", 3 );
      NTEST( "a", "[^z][^z][^z]", 0 );
      NTEST( "a aaa aaa", "[^ ]", 7 );
      NTEST( "a aaa aaa", "[^ a]", 0 );
      NTEST( "a aaa aaa", "[^:d]", 9 );
      NTEST( "a aaa aaa", "[^:d:s]", 7 );
      NTEST( "a aaa aaa", "[^:d:s][^:d:s][^:d:s]", 2 );
      NTEST( "a aaa aaa", "[^:d:s]aa", 2 );
      NTEST( "a aaa aaa", "aa[^:d:s]", 2 );
      NTEST( "Raptor Test", "[^:d:s]a", 1 );
      NTEST( "Raptor Test", "[^A-Z]t", 2 );
      NTEST( "Raptor Test", "[^:s]z", 0 );
      NTEST( "Raptor Test", "a[^ ]", 1 );
      NTEST( "Raptor Test", " [^t]", 1 );
      NTEST( "Raptor Test", "z[^a]", 0 );
      NTEST( "a", "[^z]?", 1 );
      NTEST( "a", "[^z]+", 1 );
      NTEST( "a", "[^z]*", 1 );
      NTEST( "a", "[^z]{1}", 1 );
      NTEST( "a aaa aaa", "[^ ]?", 9 );
      NTEST( "a aaa aaa", "[^ ]+", 3 );
      NTEST( "a aaa aaa", "[^ ]*", 5 );
      NTEST( "a aaa aaa", "[^ ]{1}", 7 );
      NTEST( "a", "a[^ ]?", 1 );
      NTEST( "a", "a[^ ]+", 0 );
      NTEST( "a", "a[^ ]*", 1 );
      NTEST( "a", "a[^ ]{1}", 0 );
      NTEST( "aeiou", "a|[^ ]", 5 );
      NTEST( "aeiou", "a|[^ ]?", 5 );
      NTEST( "aeiou", "a|[^ ]+", 2 );
      NTEST( "aeiou", "a|[^ ]*", 2 );
      NTEST( "aeiou", "[^ ]|a", 5 );
      NTEST( "aeiou", "[^ ]?|a", 5 );
      NTEST( "aeiou", "[^ ]+|a", 1 );
      NTEST( "aeiou", "[^ ]*|a", 1);
      NTEST( "aeiou", "(a|[^ ])", 5 );
      NTEST( "aeiou", "(a|[^ ]?)", 5 );
      NTEST( "aeiou", "(a|[^ ]+)", 2 );
      NTEST( "aeiou", "(a|[^ ]*)", 2 );
      NTEST( "aeiou", "([^ ]|a)", 5 );
      NTEST( "aeiou", "([^ ]?|a)", 5 );
      NTEST( "aeiou", "([^ ]+|a)", 1 );
      NTEST( "aeiou", "([^ ]*|a)", 1);
      NTEST( "aeiou", "a|([^ ])", 5 );
      NTEST( "aeiou", "a|([^ ]?)", 5 );
      NTEST( "aeiou", "a|([^ ]+)", 2 );
      NTEST( "aeiou", "a|([^ ]*)", 2 );
      NTEST( "aeiou", "([^ ])|a", 5 );
      NTEST( "aeiou", "([^ ]?)|a", 5 );
      NTEST( "aeiou", "([^ ]+)|a", 1 );
      NTEST( "aeiou", "([^ ]*)|a", 1);
      NTEST( "aeiou", "a|([^ ])", 5 );
      NTEST( "aeiou", "a|([^ ])?", 5 );
      NTEST( "aeiou", "a|([^ ])+", 2 );
      NTEST( "aeiou", "a|([^ ])*", 2 );
      NTEST( "aeiou", "([^ ])|a", 5 );
      NTEST( "aeiou", "([^ ])?|a", 5 );
      NTEST( "aeiou", "([^ ])+|a", 1 );
      NTEST( "aeiou", "([^ ])*|a", 1);
      NTEST( "1a2a3a4a5a6a", "[^:a]a", 6 );
      NTEST( "1a2a3a4a5a6a", "[^4-6]a", 3 );
      NTEST( "1a2b3c4d5e6f", "[^:a][^:d]", 6 );
      NTEST( "1a2b3c4d5e6f", "[^4-6][^:d]", 3 );
      NTEST( "abababababababababababababababababababab", "(a[^a])" , 20 );
      NTEST( "abababababababababababababababababababab", "([^a]a)" , 19 );
      NTEST( "abababababababababababababababababababab", "(:a[^a])" , 20 );
      NTEST( "abababababababababababababababababababab", "([^b]:a)" , 20 );
      NTEST( "abababababababababababababababababababab", "([^x]{5}:a{5})" , 4 );
      NTEST( "()<>[]{}*?+", "[^:w]", 11 );
    < src..

*** mods

    Nuestra creacion ya puede conseguir presas por su cuenta, aun asi requiere
    un poco mas de entrenamiento antes de ascender a las grades ligas de los
    motores RegExp.

    En estas seccion la kata nos trasmite una tecnica prohibida en los dojos
    regexp mas ortodoxos, el @e(agua control), la habilidad de adaptarse
    facilmente a distintas situaciones.

    Nuestro motor contabiliza todas las coincidencias de la regexp, pero y si:

    - solo quisieramos la primer coincidencia,

    - o indicar que la coincidencia debe aparecer al final de la cadena,

    - o al principio,

    - o modificar el comportamiento de un constructor,

    - o de la expresion entera,

    - o cualquer otra situacion extravagante y arbitraria?


    Los motores de las grandes ligas ofrecen varias soluciones a este dilema

    1. Funciones especificas

    2. Extender la sintaxis

    3. Agregar parametros

    4. o una combinacion de los anteriores


    De estas, la solucion que mas se utiliza es @e(extender la sintaxis).
    Supongo, es lo mas sencillo y facil de mantener. Particularmente se aplica a
    tres casos concretos:

    - Si el primer signo de la expresion es @c(^), se indica al motor que
      la busqueda ha de realizarse solo en la primer posicion de la cadena

    - Si el ultimo signo de la expresion es @c($), se indica al motor que la
      coincidencia debe aparecer al final de la cadena.

    - Si la cadena inicia con @c(^) y termina con @c($) se le indica al motor
      que realice una busqueda solo en la primer posicion de la cadena y que la
      coincidencia debe abarcar toda la cadena


    Extender la sintaxis en nustro codigo para dar soportar a los signos @c(^) y
    @c($) apenas y requiere una ligera modifacacion en @c(regexp3)

    ..src > c
      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;
        int atTheEnd = 0;                         // ➊
        int loops    = strlen( txt );             // ➋
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        text.len     = loops;

        if( rexp.ptr[ rexp.len - 1 ] == '$' ){    // ➌
          atTheEnd = TRUE;
          rexp.len--;
        }

        if( *rexp.ptr == '^' ){                   // ➍
          fwrTrack( &rexp, 1 );
          loops = 1;                              // ➎
        }

        if( text.len == 0 || rexp.len == 0 ) return 0;

        for( int forward, i = 0; i < loops; i += forward ){
          forward    = 1;
          text.pos   = 0;
          text.ptr   = txt           + i;
          text.len   = strlen( txt ) - i;

          if( walker( rexp ) ){                                        // ➏
            if( atTheEnd ){ if( text.pos == text.len ) return TRUE; }  // ➐
            else {                                                     // ➑
              result++;
              if ( text.pos > 0 ) forward = text.pos;
            }
          }
        }

        return result;
      }
    < src..

    Los cambios son sencillos. Para realizar la busqueda en la primer posicion
    de la cadena (signo @c(^) ➍) solo debemos limitar el ciclo de repeticiones
    a una sola iteraccion ➎, de lo contrario el numero de iteracciones es igual
    a la longitud de la cadena ➋.

    Si debemos verificar que la coincidencia este al final de la cadena (signo
    @c($) ➌), y ya que la cantidad de caracteres que forman el patron es
    desconocido realizamos todas las comprobaciones atraves de la cadena, hasta
    encontrar una coincidencia ➏. Si la longitud de la coincidencia
    (@c(text.pos)) es igual a el tamaño (relativo) de la cadena (@c(text.len))
    tenemos una coincidencia al final de la cadena ➐. En este caso echamos mano
    de una variable, si esta encendida caeremos siempre en este caso ➐, de lo
    contrario, se lleva a cabo el conteo de coincidencias ➑

    ... y con los dos signos? ¡¡¡ho my glob ꒰--■_■-꒱!!! la solucion se
    presenta por si sola, solo hay un ciclo (@c(loops == 1)) y debe abarcar toda
    la cadena.

    Para probar la eficacia del nuevo cambio intentemos con estas pruebas

    ..src > c
      NTEST( "Raptor Test", "^Raptor", 1 );
      NTEST( "Raptor Test", "Raptor$", 0 );
      NTEST( "Raptor Test", "Test$", 1 );
      NTEST( "Raptor Test", "^Test", 0 );
      NTEST( "Raptor Test", "^Raptor Test$", 1 );
    < src..

    Ahora bien... como agregar otros modificadores, por ejemplo para indicarle
    al motor que se detenga con la primer coincidencia? agregamos el signo al
    principio? al final? en una varible adicional? unimos todos los
    modificadores en una mascara de bits? mas @c(if)s?

    ٩꒰･ัεั･꒱۶ si agregamos nuevos signos al los extremos tenemos que establecer
    un orden de evaluacion mas elaborado. Por otra parte el metodo de la varible
    adicional, nos obligaria a establecer valores en la llamada, aunque su uso
    fuese anecdotico. Algo similar ocurre si agrupamos las modificaciones en una
    varible adicional en forma de mascara de bits, con el inconveniente
    adicional de tener que recordar nombres de constantes (por lo general
    extensos).

    En cualquier caso estos modificadores operan de forma @e(global), es decir,
    afectan el comportamiento de toda la expresion. Si quisieramos implementar
    modificadores a nivel de constructor (como la busqueda inversa en los
    conjuntos) tendriamos un inconveniente adicional.

    Varios motores utilizan la siguiente sintaxis

    - c[(?i)] hace que la regexp ignore entre minusculas y mayusculas.

    - c[(?c)] hace que la regexp distinga entre mayusculas y minusculas

    - c[(?:)] no capturar coincidencia

    - c[(?s)] @"(modo de una sola linea). Hace que punto coincida con todos los
      caracteres, incluido el salto de linea.


    Estas y otras @"(opciones de busqueda) pueden aplicarse a toda la regexp o a
    parte de ella. No es imposible incorporarla al raptor, pero seria
    terriblemente complicado y roperia el flujo de ejecucion!

    El raptor no teme romper tabus menos si estan relacionadas con la sintaxis,
    con tal de mantener el codigo lo mas sencillo posible.

    Vamos a implementar este esquema:

    ..example >
      constructor-cuantificador-modificador
    < example..

    con esto podemos modificar el comportamiento de los constructores de forma
    individual, los modificaderes se especifican luego de los cuantificadores
    (joder, si lo hacemos bien podemos unificar cuantificadores y modificadores
    en una sola sintaxis, claro, si lo hacemos bien...).

    Para indicar modificadores que afecten de forma global tenbremos este
    esquema:

    ..example >
      modificador-regexp
    < example..

    el decir el modificador precede a la expresion.

    Ambos, modificador local, como global seguiran la misma sintaxis: El signo
    @c(#) le indicar al motor la presencia de una cadena de uno o mas signos con
    significado especial @"(los modificadores). La cadena de modificadores
    termina cuando aparece el primer signo no establecido como modificador:

    ..sketch >
      #mod_1-mod_2-mod_nCualquierConstructor
      ▲
      │< modificadores >
      └─ signo de modificador
    < sketch..

    Si queremos aplicar los modificadores @c(^) + @c($) la exprecion seria

    ..example >
      #^$regep
    < example..

    para aplicar modificadores a un constructor

    ..example >
      [conjunto]*#MODS(agrupacion)#MODS
    < example..

    vamos con el codigo

    ..src > c
      #include <ctype.h>
      #include <string.h>
      #include <stdlib.h>

      #define TRUE                 1
      #define FALSE                0
      #define INF         1073741824 // 2^30

      #define MOD_ALPHA            1
      #define MOD_OMEGA            2
      #define MOD_LONLEY           4
      #define MOD_FwrByChar        8
      #define MOD_COMMUNISM       16

      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      } static text;

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char          *ptr;
        int            len;
        enum     TYPE  type;
        unsigned char  mods;
        unsigned int   loopsMin, loopsMax;
      };

      static int  walker    ( struct RE  rexp );
      static int  trekking  ( struct RE *rexp );
      static int  looper    ( struct RE *rexp );
      static int  tracker   ( struct RE *rexp, struct RE *track );
      static int  cutTrack  ( struct RE *rexp, struct RE *track, int type );

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type );
      static void getMods   ( struct RE *rexp, struct RE *track );
      static void getLoops  ( struct RE *rexp, struct RE *track );
      static void fwrTrack  ( struct RE *track, int len );

      static int  walkMeta       ( char *str );
      static int  walkSet        ( char *str );
      static int  countCharDigits( char *str );
      static char *trackerPoint  ( char *points, char *track, int len );

      static int  match     ( struct RE *rexp );
      static int  matchSet  ( struct RE  rexp );
      static int  matchRange( struct RE *rexp, int   chr );
      static int  matchMeta ( struct RE *rexp, int   chr );
      static int  matchText ( struct RE *rexp, char *txt );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;
        text.len     = strlen( txt );
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        rexp.mods    = 0;

        if( text.len == 0 || rexp.len == 0 ) return 0;

        getMods( &rexp, &rexp );

        for( int forward, i = 0, loops = rexp.mods & MOD_ALPHA ? 1 : text.len; i < loops; i += forward ){
          forward    = 1;
          text.pos   = 0;
          text.ptr   = txt           + i;
          text.len   = strlen( txt ) - i;

          if( walker( rexp ) ){
            if     (  rexp.mods & MOD_OMEGA    ){ if( text.pos == text.len ) return TRUE; }
            else if(  rexp.mods & MOD_LONLEY   )                             return TRUE;
            else if( (rexp.mods & MOD_FwrByChar) || text.pos == 0 )          result++;
            else   {  forward = text.pos;                                    result++; }
          }
        }

        return result;
      }

      static int walker( struct RE rexp ){
        struct RE track;

        for( const int oPos = text.pos; cutTrack( &rexp, &track, PATH ); text.pos = oPos )
          if( trekking( &track ) ) return TRUE;

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;
        while( tracker( rexp, &track ) )
          if( looper( &track ) == FALSE ) return FALSE;

        return TRUE;
      }

      static int looper( struct RE *rexp ){
        int steps, loops = 0;

        switch( rexp->type ){
        case HOOK: case GROUP: case PATH:
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:
          while( loops < rexp->loopsMax && text.pos < text.len && (steps = match( rexp )) ){
            text.pos += steps;
            loops++;
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;
      }

      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track      = *rexp;
        track->type = type;
        if( type != PATH ) fwrTrack( track, 1 );

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          i += walkMeta( rexp->ptr + i );

          switch( rexp->ptr[i] ){
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          case '[': i += walkSet( rexp->ptr + i ); break;
          }

          switch( type ){
          case HOOK : cut = deep == 0; break;
          case GROUP: cut = deep == 0; break;
          case SET  : cut =              rexp->ptr[i] == ']'; break;
          case PATH : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );
        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case ':': trackByLen( rexp, track, 2, META  ); break;
        case '.': trackByLen( rexp, track, 1, POINT ); break;
        case '(': cutTrack  ( rexp, track,    GROUP ); break;
        case '<': cutTrack  ( rexp, track,    HOOK  ); break;
        case '[': cutTrack  ( rexp, track,    SET   ); break;
        default :
          if( (point = trackerPoint( "(<[:.?+*{-#", rexp->ptr + 1, rexp->len - 1 )) ){
            switch( *point ){
            case '(': case '<': case '[': case ':': case '.':
              trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;
            case '?': case '+': case '*': case '{': case '-': case '#':
              if( point - rexp->ptr == 1 ){
                if( *point == '-' ) trackByLen( rexp, track, 3, RANGEAB );
                else                trackByLen( rexp, track, 1, SIMPLE  );
              } else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  );
            }
          } else trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

        getLoops( rexp, track );
        getMods ( rexp, track );
        return TRUE;
      }

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
        *track       = *rexp;
        track->type  = type;
        track->len   = len;
        fwrTrack( rexp, len );
      }

      static void fwrTrack( struct RE *track, int len ){
        track->ptr += len; track->len -= len;
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }

      static int walkSet( char *str ){
        int i = 0;
        while( TRUE )
          switch( str[ i ] ){
          case ']': return i;
          case ':': i += walkMeta( str + i ); break;
          default : i++   ; break;
          }
      }

      static int walkMeta( char *str ){
        for( int i = 0; ; i += 2 )
          if( str[i] != ':' ) return i;
      }

      static void getMods( struct RE *rexp, struct RE *track ){
        int inMods = *rexp->ptr == '#', pos = 0;

        while( inMods )
          switch( rexp->ptr[ ++pos ] ){
          case '^': track->mods |=  MOD_ALPHA     ; break;
          case '$': track->mods |=  MOD_OMEGA     ; break;
          case '?': track->mods |=  MOD_LONLEY    ; break;
          case '~': track->mods |=  MOD_FwrByChar ; break;
          case '*': track->mods |=  MOD_COMMUNISM ; break;
          case '/': track->mods &= ~MOD_COMMUNISM ; break;
          default : inMods       =  FALSE         ; break;
          }

        fwrTrack( rexp, pos );
      }

      static void getLoops( struct RE *rexp, struct RE *track ){
        track->loopsMin = 1; track->loopsMax = 1;
        int len = 0;

        if( rexp->len )
          switch( *rexp->ptr ){
          case '?' : len = 1; track->loopsMin = 0; track->loopsMax =   1; break;
          case '+' : len = 1; track->loopsMin = 1; track->loopsMax = INF; break;
          case '*' : len = 1; track->loopsMin = 0; track->loopsMax = INF; break;
          case '{' :
            track->loopsMin = atoi( rexp->ptr + 1 ) ;
            if( rexp->ptr[ 1 + countCharDigits( rexp->ptr + 1 ) ] == ',' )
              track->loopsMax = atoi( strchr( rexp->ptr, ',' ) + 1 );
            else
              track->loopsMax = track->loopsMin;

            len = strchr( rexp->ptr, '}' ) - rexp->ptr + 1;
          }

        fwrTrack( rexp, len );
      }

      static int countCharDigits( char *str ){
        for( int digits = 0; ; digits++ )
          if( isdigit( *str++ ) == 0 ) return digits;
      }

      static int match( struct RE *rexp ){
        switch( rexp->type ){
        case POINT  : return text.pos < text.len;
        case SET    : return matchSet  ( *rexp );
        case RANGEAB: return matchRange( rexp, text.ptr[text.pos]  );
        case META   : return matchMeta ( rexp, text.ptr[text.pos]  );
        default     : return matchText ( rexp, text.ptr + text.pos );
        }
      }

      static char * strnChr( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( str[ i ] == chr ) return str + i;

        return 0;
      }

      static int cmpChrCommunist( char a, char b){
        a = tolower(a);
        b = tolower(b);
        return a == b;
      }

      static char * strnChrCommunist( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( cmpChrCommunist( str[i], chr ) ) return str + i;

        return 0;
      }

      static int strnCmpCommunist( char *s, char *t, int n ){
        for( ; cmpChrCommunist( *s, *t ); s++, t++ )
          if( *s == '\0' || --n <= 0 ) return 0;

        return *s - *t;
      }

      static int matchText( struct RE *rexp, char *txt ){
        if( rexp->mods & MOD_COMMUNISM )
          return    strnCmpCommunist( txt, rexp->ptr, rexp->len )  == 0 ? rexp->len : 0;
        else return strncmp         ( txt, rexp->ptr, rexp->len )  == 0 ? rexp->len : 0;
      }

      static int matchRange( struct RE *rexp, int chr ){
        if( rexp->mods & MOD_COMMUNISM ){
          chr = tolower( chr );
          return chr >= tolower( rexp->ptr[ 0 ] ) && chr <= tolower( rexp->ptr[ 2 ] );
        } else
          return chr >=          rexp->ptr[ 0 ]   && chr <=          rexp->ptr[ 2 ];
      }

      static int matchMeta( struct RE *rexp, int chr ){
        switch( rexp->ptr[1] ){
        case 'a' : return isalpha( chr ) != 0;
        case 'A' : return isalpha( chr ) == 0;
        case 'd' : return isdigit( chr ) != 0;
        case 'D' : return isdigit( chr ) == 0;
        case 'w' : return isalnum( chr ) != 0;
        case 'W' : return isalnum( chr ) == 0;
        case 's' : return isspace( chr ) != 0;
        case 'S' : return isspace( chr ) == 0;
        default  : return rexp->ptr[1] == chr;
        }
      }

      static int matchSet( struct RE rexp ){
        struct RE track;
        int result  = 0, reverse = *rexp.ptr == '^';

        if( reverse ) fwrTrack( &rexp, 1 );

        while( tracker( &rexp, &track ) ){
          switch( track.type ){
          case RANGEAB: case META: case POINT:
            result = match( &track ); break;
          default:
            if( track.mods & MOD_COMMUNISM )
                 result = strnChrCommunist( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
            else result = strnChr         ( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
          }

          if( result ) return reverse ? FALSE : result;
        }

        return reverse ? TRUE : FALSE;
      }
    < src..

    ya que cada constructor es propenso a contar con modificadores se agrego una
    nueva varible a la estructura @c(RE):

    ..src > c
      unsigned char  mods;
    < src..

    Como en esensia, cada modificador no es mas que una bandera, utilizaremos
    @c(mods) como una mascara de bits, situacion que lo obliga ser de tipo
    @c(unsigned). De momento solo vamos a establecer 5 modificadores, al ser
    tipo @c(char) nos proporciona ocho bits, o puesto de otra forma, disponemos
    de 3 modificaciones adicionales antes de acudir a enteros de 16, 32, 64 o
    128 @"(interruptores) (bits).

    Para activar o desactivar cada bit de forma independiente, necesitamos
    conocer el valor que representa la posicion del bit a modificar. Como
    sabemos, esto se logra elevando 2 a la posicion del bit. Asi el primer bit
    es @m(2^0 = 1), el segundo @m(2^1 = 2), el tercero @m(2^2 = 4) y asi
    sucesivamente.

    Recordar la posicion de cada modificador, no es lo mas conveniete, en su
    lugar utilizamos constantes de preprosesador:

    ..src > c
      #define MOD_ALPHA            1
      #define MOD_OMEGA            2
      #define MOD_LONLEY           4
      #define MOD_FwrByChar        8
      #define MOD_COMMUNISM       16
    < src..

    @c(MOD_ALPHA), signo @c(^) sera el modificador @"(busca al inicio).

    @c(MOD_OMEGA), signo @c($) sera el modificador @"(busca al final).

    @c(MOD_LONLEY), signo @c(?) sera el modificador @"(busca una vez).

    @c(MOD_FwrByChar), signo @c(~) sera el modificador @"(busca caracter a
    caracter. Si hay una coincidencia no continues al final de esta, prueba con
    el caracter imediatamente despues del que utilizaste para este ciclo).

    @c(MOD_COMMUNISM), signo @c(*) sera el modificador @"(ignora entre
    mayusculas y minusculas.

    finalmente signo @c(/), apaga el bit @c(MOD_COMMUNISM) para decir @"(no
    ignores entre mayusculas y minusculas), que es el comportamiento por
    defecto. Tenemos 6 modificadores por el precio de 5!

    si los signos que he eligido no son de tu agrado, se pueden modificar sin
    despeinarse en la funcion @c(getMods). Como su nombre indica, optiene los
    modificadores... y los asigna a un constructor:

    ..src > c
      static void getMods( struct RE *rexp, struct RE *track ){
        int inMods = *rexp->ptr == '#', pos = 0;             // ➊

        while( inMods )                                      // ➋
          switch( rexp->ptr[ ++pos ] ){                      // ➌
          case '^': track->mods |=  MOD_ALPHA     ; break;
          case '$': track->mods |=  MOD_OMEGA     ; break;
          case '?': track->mods |=  MOD_LONLEY    ; break;
          case '~': track->mods |=  MOD_FwrByChar ; break;
          case '*': track->mods |=  MOD_COMMUNISM ; break;
          case '/': track->mods &= ~MOD_COMMUNISM ; break;
          default : inMods       =  FALSE         ; break;   // ➍
          }

        fwrTrack( rexp, pos );                               // ➎
      }
    < src..

    El funcionamiento se basa en el mismo principio que @c(getLoops), lo que
    significa que si el constructor posee algun modificador, deberia encontrarse
    en la posicion inicial de @c(rexp) ➊. Si esto es asi recorremos y asignamos
    los valores en la cadena de modificadores ➋➌ hasta que el signo en cuestion
    no forme parte de los modificadores ➍. Una vez que optenemos la informacion,
    la cadena de mods se descarta ➎.

    Por cierto, antes de modificar o agregar nuvos mods, considera la sintaxis
    actual, mal negocio seria agregar los signos @c(|), @c[(], @c[)], ..., etc.

    Como hacemos para otener los modis de los constructores? (¬‿¬) je, recuerdas
    donde que supuestamente vamos a colocar los modificadores despues de los
    cuantificadores? (pista: en que funcion esta getLoops)

    ..src > c
      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case ':': trackByLen( rexp, track, 2, META  ); break;
        case '.': trackByLen( rexp, track, 1, POINT ); break;
        case '(': cutTrack  ( rexp, track,    GROUP ); break;
        case '<': cutTrack  ( rexp, track,    HOOK  ); break;
        case '[': cutTrack  ( rexp, track,    SET   ); break;
        default :
          if( (point = trackerPoint( "(<[:.?+*{-#", rexp->ptr + 1, rexp->len - 1 )) ){ // ➊
            switch( *point ){
            case '(': case '<': case '[': case ':': case '.':
              trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;
            case '?': case '+': case '*': case '{': case '-': case '#':                // ➋
              if( point - rexp->ptr == 1 ){
                if( *point == '-' ) trackByLen( rexp, track, 3, RANGEAB );
                else                trackByLen( rexp, track, 1, SIMPLE  );
              } else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  );
            }
          } else trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

        getLoops( rexp, track );
        getMods ( rexp, track );  // ➌
        return TRUE;
      }
    < src..

    Exacto! solo agregamos @c(getMods) ➌ inmediatamente despues de @c(getLoops),
    el resto solo es colocar un nuevo signo a la cadena de rastreo ➊➋. Vuala!
    cada constructor tiene sos mods! o no... Mira bien el comportamiento de las
    dos funciones @c(get), toma tu tiempo.

    Notas la diferencia? @c(getLoops) siempre establece valores por defecto. Por
    su parte @c(getMods) solo modifica los valores que indiquemos, y como todos
    los constructores inician como copias del constructor primordial
    (@c(regexp3)) no puede significar otra cosa mas que los modificadores se
    heredan. Si en el constructor primigenio establecemos algun modificador, sera
    transmitido a todos sus descendientes.

    ..src > c
      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;
        text.len     = strlen( txt );
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        rexp.mods    = 0;             // ➊

        if( text.len == 0 || rexp.len == 0 ) return 0;

        getMods( &rexp, &rexp );      // ➋

        for( int forward, i = 0, loops = rexp.mods & MOD_ALPHA ? 1 : text.len; i < loops; i += forward ){  // ➌
          forward    = 1;
          text.pos   = 0;
          text.ptr   = txt           + i;
          text.len   = strlen( txt ) - i;

          if( walker( rexp ) ){
            if     (  rexp.mods & MOD_OMEGA    ){ if( text.pos == text.len ) return TRUE; }  // ➍
            else if(  rexp.mods & MOD_LONLEY   )                             return TRUE;    // ➎
            else if( (rexp.mods & MOD_FwrByChar) || text.pos == 0 )          result++;       // ➏
            else   {  forward = text.pos;                                    result++; }     // ➐
          }
        }

        return result;
      }
    < src..

    El constructor fundamental, inicia con ningun modifidor ➊. Los modificadores
    que en este sean establecidos, tendran un alcance global ➋, claro, siempre y
    cuando tengamos codigo para una tarea especifica, es decir, podemos aplicar los
    modificadores @c(^) o @c($) o @c(?) o @c(~) al primer constructor y luego
    ignorarlos en todos sus descendientes, al fin y al cabo, solo nos importan
    para modificar el comportamiento del ciclo por la cadena ➌. Veamos a detalle
    las alteraciones principales:

    Si tenemos el bit @c(MOD_ALPHA) encendido, aplicamos solo un ciclo (primera
    posicion de la cadena) ➌.

    Si hay una coincidencia y el bit @c(MOD_OMEGA) esta encendido comprobamos
    que la coincidencia abarque el resto de la cadena, si es asi tenemos la
    coincidencia que buscamos ➍.

    Si la coincidencia ocurre con el bit @c(MOD_LONLEY) activo, detenemos la
    busqueda con la primer coincidencia ➎.

    Si el el bit activo es @c(MOD_FwrByChar) o la longitud de la captura es de 0
    caracteres, la busqueda continuara en la posicion siguiente ➏.

    Si no hay ningun modificador, simplemente incrementamos el contador de
    coincidencias y la sigiente posicion del ciclo por la cadena estara al final
    de la coincidencia ➐.

    Para terminar, tenemos un modificador que afecta el comportamiento de los
    constructores de formo individual, el @c(MOD_COMMUNISM). Hace que los
    caracteres alfabeticos coincidan tanto con mayusculas como con
    minisculas. Cuando asignamos el mod de forma global se transmite a todos los
    constructores, por ello existe el @c(MOD CAPITALISTA), su funcion es
    terminar con la igualdad, de hecho este es el comportamiento por defecto.

    Naturalmente dicho mod sera aplicado en las fuciones de busqueda

    ..src > c
      static int matchText( struct RE *rexp, char *txt ){
        if( rexp->mods & MOD_COMMUNISM )     // ➊
          return    strnCmpCommunist( txt, rexp->ptr, rexp->len )  == 0 ? rexp->len : 0;
        else return strncmp         ( txt, rexp->ptr, rexp->len )  == 0 ? rexp->len : 0;
      }
    < src..

    ..src > c
      static int matchRange( struct RE *rexp, int chr ){
        if( rexp->mods & MOD_COMMUNISM ){    // ➋
          chr = tolower( chr );
          return chr >= tolower( rexp->ptr[ 0 ] ) && chr <= tolower( rexp->ptr[ 2 ] );
        } else
          return chr >=          rexp->ptr[ 0 ]   && chr <=          rexp->ptr[ 2 ];
      }
    < src..

    ..src > c
      static int matchSet( struct RE rexp ){
        struct RE track;
        int result  = 0, reverse = *rexp.ptr == '^';

        if( reverse ) fwrTrack( &rexp, 1 );

        while( tracker( &rexp, &track ) ){
          switch( track.type ){
          case RANGEAB: case META: case POINT:
            result = match( &track ); break;
          default:
            if( track.mods & MOD_COMMUNISM ) // ➌
                 result = strnChrCommunist( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
            else result = strnChr         ( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
          }

          if( result ) return reverse ? FALSE : result;
        }

        return reverse ? TRUE : FALSE;
      }
    < src..

    Unicamente necesitamos conocer si el estado del modificador ➊➋➌, luego, con
    ayuda de tres nuevas funciones (examinalas por tu cuenta) realizamos la
    busqueda segun sea el caso.

    Como puedes apreciar, ahora los constructores de tipo @c(RANGEAB) tienen su
    propia funcion. Es demasido extensa como para permanecer en @c(match). En
    cambio @c(matchMeta) no fue afectado, ninguno de los metacaracteresuna
    definidos requiere cambios.

    Antes de concuir verificamos que las prubebas previas no presenten errores y
    agregamos una cuantas mas:

    ..src > c
      NTEST( "ABC", "#^A", 1 );
      NTEST( "ABC", "#^AB", 1 );
      NTEST( "ABC", "#^ABC", 1 );
      NTEST( "ABC", "#^(b|A)", 1 );
      NTEST( "ABC", "#^A(B|C)(B|C)", 1 );
      NTEST( "ABC", "#^(A(B|C))(B|C)", 1 );
      NTEST( "ABC", "#$C", 1 );
      NTEST( "ABC", "#$BC", 1 );
      NTEST( "ABC", "#$ABC", 1 );
      NTEST( "ABC", "#$(b|C)", 1 );
      NTEST( "ABC", "#$A(B|C)(B|C)", 1 );
      NTEST( "ABC", "#$(A(B|C))(B|C)", 1 );
      NTEST( "ABC", "#^$ABC", 1 );
      NTEST( "ABC", "#^$A(c|B)(b|C)", 1 );
      NTEST( "ABC", "#^$A(B|C)(B|C)", 1 );
      NTEST( "ABC", "#^$(A(B|C))(B|C)", 1 );

      NTEST( "ABC", "#^E", 0 );
      NTEST( "ABC", "#^EB", 0 );
      NTEST( "ABC", "#^EBC", 0 );
      NTEST( "ABC", "#^(b|E)", 0 );
      NTEST( "ABC", "#^A(B|C)(B|E)", 0 );
      NTEST( "ABC", "#^(A(B|C))(B|E)", 0 );
      NTEST( "ABC", "#$E", 0 );
      NTEST( "ABC", "#$BE", 0 );
      NTEST( "ABC", "#$ABE", 0 );
      NTEST( "ABC", "#$(b|E)", 0 );
      NTEST( "ABC", "#$A(B|C)(B|E)", 0 );
      NTEST( "ABC", "#$(A(B|C))(B|E)", 0 );
      NTEST( "ABC", "#^$ABE", 0 );
      NTEST( "ABC", "#^$A(c|B)(b|E)", 0 );
      NTEST( "ABC", "#^$A(B|C)(B|E)", 0 );
      NTEST( "ABC", "#^$(A(B|C))(B|E)", 0 );

      NTEST( "A", "a#*", 1 );
      NTEST( "A", "a?#*", 1 );
      NTEST( "A", "b?#*", 1 );
      NTEST( "A", "a+#*", 1 );
      NTEST( "A", "a*#*", 1 );
      NTEST( "A", "b*#*", 1 );
      NTEST( "aAa", "a#*", 3 );
      NTEST( "aAa", "a+#*", 1 );
      NTEST( "aAa", "a*#*", 1 );
      NTEST( "aAa", "a+#*", 1 );
      NTEST( "aAa", "a?#*", 3 );
      NTEST( "aAab", "a+#*", 1 );
      NTEST( "aAab", "a*#*", 2 );
      NTEST( "aAab", "a?#*", 4 );
      NTEST( "aAab", "a+#*?^$~b", 1 );
      NTEST( "aAab", "a*#*?^$~b", 1 );
      NTEST( "aAab", "a?#*?^$~b", 1 );
      NTEST( "aAab", "a+#*?^$~b?", 1 );
      NTEST( "aAab", "a*#*?^$~b?", 1 );
      NTEST( "aAab", "a?#*?^$~b?", 3 );
      NTEST( "aAab", "a+#*?^$~b+", 1 );
      NTEST( "aAab", "a*#*?^$~b+", 1 );
      NTEST( "aAab", "a?#*?^$~b+", 1 );
      NTEST( "aAab", "a+#*?^$~b*", 1 );
      NTEST( "aAab", "a*#*?^$~b*", 1 );
      NTEST( "aAab", "a?#*?^$~b*", 3 );

      NTEST( "a", "a#*", 1 );
      NTEST( "a", "A#*", 1 );
      NTEST( "a", "#*A", 1 );
      NTEST( "a", "#*a", 1 );
      NTEST( "a", "#*(A)", 1 );
      NTEST( "a", "#*(a)", 1 );
      NTEST( "a", "#*[A]", 1 );
      NTEST( "a", "#*[a]", 1 );
      NTEST( "a", "#*A-Z", 1 );
      NTEST( "a", "A-Z#*", 1 );
      NTEST( "a", "(a)#*", 1 );
      NTEST( "a", "(A)#*", 1 );
      NTEST( "a", "[a]#*", 1 );
      NTEST( "a", "[A]#*", 1 );
      NTEST( "a", "#*[A-Z]", 1 );
      NTEST( "a", "[A-Z]#*", 1 );

      NTEST( "aAaA", "a#*", 4 );
      NTEST( "aAaA", "A#*", 4 );
      NTEST( "aAaA", "#*A", 4 );
      NTEST( "aAaA", "#*a", 4 );
      NTEST( "aAaA", "#*(A)", 4 );
      NTEST( "aAaA", "#*(a)", 4 );
      NTEST( "aAaA", "#*[A]", 4 );
      NTEST( "aAaA", "#*[a]", 4 );
      NTEST( "aAaA", "#*A-Z", 4 );
      NTEST( "aAaA", "A-Z#*", 4 );
      NTEST( "aAaA", "(a)#*", 4 );
      NTEST( "aAaA", "(A)#*", 4 );
      NTEST( "aAaA", "[a]#*", 4 );
      NTEST( "aAaA", "[A]#*", 4 );
      NTEST( "aAaA", "#*[A-Z]", 4 );
      NTEST( "aAaA", "[A-Z]#*", 4 );
      NTEST( "aAaA", "(a#*)", 4 );
      NTEST( "aAaA", "(A#*)", 4 );
      NTEST( "aAaA", "(a)#*", 4 );
      NTEST( "aAaA", "(A)#*", 4 );
      NTEST( "aAbB", "#*a|b", 4 );
      NTEST( "aAbB", "#*A|B", 4 );
      NTEST( "aAbB", "#*(a|b)", 4 );
      NTEST( "aAbB", "#*(A|B)", 4 );
      NTEST( "aAbB", "(a#*|b#*)", 4 );
      NTEST( "aAbB", "(A#*|B#*)", 4 );
      NTEST( "aAbB", "(a|b)#*", 4 );
      NTEST( "aAbB", "(A|B)#*", 4 );
      NTEST( "TesT", "test", 0 );
      NTEST( "TesT", "test#*", 0 );
      NTEST( "TesT", "t#*est#*", 1 );
      NTEST( "TesT", "#*test", 1 );
      NTEST( "TesT", "#*tESt", 1 );
      NTEST( "TesT", "#*(tESt)", 1 );
      NTEST( "TesT", "(tESt)#*", 1 );

      NTEST( "a aaa aaa", "#^aaa", 0 );
      NTEST( "a aaa aaa", "#$aaa", 1 );
      NTEST( "a aaa aaa", "#?aaa", 1 );
      NTEST( "a aaa aaa", "#~aaa", 2 );
      NTEST( "a aaa aaa", "#^?aaa", 0 );
      NTEST( "a aaa aaa", "#?^aaa", 0 );
      NTEST( "a aaa aaa", "#?$aaa", 1 );
      NTEST( "a aaa aaa", "#^?$aaa", 0 );
      NTEST( "a aaa aaa", "#?$^aaa", 0 );
      NTEST( "a aaa aaa", "#^?$a aaa aaa", 1 );
      NTEST( "aa aaaa aaaa", "#~a", 10 );
      NTEST( "aa aaaa aaaa", "#~aa", 7 );
      NTEST( "aa aaaa aaaa", "#~aaa", 4 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "#?a+", 1 );
      NTEST( "abababababababababababababababababababab", "#?a+" , 1 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "#~a+", 20 );
      NTEST( "abababababababababababababababababababab", "#~a+" , 20 );

      NTEST( "Raptor TesT Fest", "RapTor (tESt)#* fEST", 0 );
      NTEST( "Raptor TesT Fest", "#*rapTor (tESt) fEST", 1 );
      NTEST( "Raptor TesT Fest", "(RapTor)#* (tESt)#* (fEST)#*", 1 );
      NTEST( "Raptor TesT Fest", "((Rap#*Tor)#* (t#*ESt)#* (fEST)#*)#*", 1 );
      NTEST( "Raptor TesT Fest", "#*a-z#*apTor (tESt) A-Z#*EST", 1 );

      NTEST( "a", "a#/", 1 );
      NTEST( "a", "A#/", 0 );
      NTEST( "a", "#/A", 0 );
      NTEST( "a", "#/a", 1 );
      NTEST( "a", "#/(A)", 0 );
      NTEST( "a", "#/(a)", 1 );
      NTEST( "a", "#/[A]", 0 );
      NTEST( "a", "#/[a]", 1 );
      NTEST( "a", "#/A-Z", 0 );
      NTEST( "a", "A-Z#/", 0 );
      NTEST( "a", "(a)#/", 1 );
      NTEST( "a", "(A)#/", 0 );
      NTEST( "a", "[a]#/", 1 );
      NTEST( "a", "[A]#/", 0 );
      NTEST( "a", "#/[A-Z]", 0 );
      NTEST( "a", "[A-Z]#/", 0 );

      NTEST( "aAaA", "a#/", 2 );
      NTEST( "aAaA", "A#/", 2 );
      NTEST( "aAaA", "#/A", 2 );
      NTEST( "aAaA", "#/a", 2 );
      NTEST( "aAaA", "#/(A)", 2 );
      NTEST( "aAaA", "#/(a)", 2 );
      NTEST( "aAaA", "#/[A]", 2 );
      NTEST( "aAaA", "#/[a]", 2 );
      NTEST( "aAaA", "#/A-Z", 2 );
      NTEST( "aAaA", "A-Z#/", 2 );
      NTEST( "aAaA", "(a)#/", 2 );
      NTEST( "aAaA", "(A)#/", 2 );
      NTEST( "aAaA", "[a]#/", 2 );
      NTEST( "aAaA", "[A]#/", 2 );
      NTEST( "aAaA", "#/[A-Z]", 2 );
      NTEST( "aAaA", "[A-Z]#/", 2 );
      NTEST( "aAaA", "(a#/)", 2 );
      NTEST( "aAaA", "(A#/)", 2 );
      NTEST( "aAaA", "(a)#/", 2 );
      NTEST( "aAaA", "(A)#/", 2 );
      NTEST( "aAbB", "#/a|b", 2 );
      NTEST( "aAbB", "#/A|B", 2 );
      NTEST( "aAbB", "#/(a|b)", 2 );
      NTEST( "aAbB", "#/(A|B)", 2 );
      NTEST( "aAbB", "(a#/|b#/)", 2 );
      NTEST( "aAbB", "(A#/|B#/)", 2 );
      NTEST( "aAbB", "(a|b)#/", 2 );
      NTEST( "aAbB", "(A|B)#/", 2 );

      NTEST( "Raptor TesT Fest", "#*rapTor (tESt)#/ fEST", 0 );
      NTEST( "Raptor tESt Fest", "#*rapTor (tESt)#/ fEST", 1 );
      NTEST( "Raptor TesT Fest", "#*rapTor (tE#/S#/t)#* fEST", 0 );
      NTEST( "Raptor tESt Fest", "#*rapTor (tE#/S#/t)#* fEST", 1 );
    < src..

*** Catch

    Hace mucho, mucho, mucho codigo se establecio la sintaxis "<...>".
    Supuestamento serviria para decilre al motor que almacenara una referencia
    al patron de coincidencia en la cadena.

    La situacion es la siguiente:

    1. Tenemos que almacenar los datos de cada captura de alguna forma.

    2. Desconocemos la dimencion de cada captura

    3. Desconocemos el numero de coincidencias... y capturas


    ( ︶︿︶) ... ... ...  vamos a utilizar una estructura que almacene la
    captura. La dimencion es irrelevante, haremos como en @c(RE) @e(puntero) y
    @e(longitud). En cuanto al numero, pues, con un manejo dinamico de memoria
    luego de cada consulta tendriamos que liberar la memoria, algo asi

    ..src > c
      void regexp3_freeData();
    < src..

    cosa que no deseo hacer. Tambien podriamos pasar la responsabilidad al
    usuario y obligarlo que nos envie un arreglo de estructuras

    ..src > c
      int regexp3( char *txt, char *re, struct CATch *Catch, int maxCatch );
    < src..

    podriamos separar la funcion inicializando antes el motor

    ..src > c
      void regexp3_init( struct CATch *Catch, int maxCatch )
    < src..

    bahh, que pereza, todo estatico un millon de capturas (puntero de 64 bits,
    un entero de 64 bits para la longitud y el indice biene gratis) serian 122
    MiB. Dejomoslo en 16 para empezar, si hay problemas ¯\_(ツ)_/¯

    En esta ocacion los cambios son minimos, solo veremos el codigo
    nuevo. Intenta colocarlo de forma armoniosa. Puede que necesites agregar
    algunos prototipos de funcion o simplemente coloca toda al inicio e intenta
    a ver si funciona. Primero veamos la estructura

    ..src > c
      #define MAX_CATCHS          16

      struct CATch {
        char *ptr[ MAX_CATCHS ];
        int   len[ MAX_CATCHS ];
        int   id [ MAX_CATCHS ];
        int   idx;
        int   index;
      } static Catch;
    < src..

    Si, es un poco distinta al requisito. En lugar de tener un arreglo de
    estructuras, la estructura contiene un arreglo de datos para cada captura:

    - @c(ptr) apunta al inicio de la coincidencia en la cadena

    - @c(len) la dimencion de la coincidencia.

    - @c(id), no es el indice de la captura, en vez de eso es la posicion donde
      aparece la captura con respecto a la regexp.

      Si recivimos la llamada

      ..src > c
        regexp3( "uno-dos-uno-dos-uno-dos-uno", "<uno><dos>" )
      < src..

      El indice de capturas seria

      ..sketch >
        cadena    "uno-dos-uno-dos-uno-dos-uno"
        captura    <1> <2> <3> <4> <5> <6> <7>
      < sketch..

      en cambio el identificador de la captura con respecto a la posicion en la
      regexp seria

      ..sketch >
        cadena    "uno-dos-uno-dos-uno-dos-uno"
        captura    <1> <2> <1> <2> <1> <2> <1>
      < sketch..

      haremos uso de esto valor para modificar todas las apariciones de una
      captura con repecto a su @c(id), en lugar de modificar captura a captura
      en base a su aparicion. Ya veremos los detalles mas adelante.


    Utilizo @c(index) para que el motor sepa cual es la captura @"(actual),
    ademas y en conjunto con la constante @c(MAX_CATCHS) evita ir mas alla de
    los limites del arreglo.

    @c(idx) es el indice @"(actual) con respecto a la posicion en cadena de cada
    captura, @e(para cada ciclo), esto quiere decir que cada ciclo el indice se
    coloca a 1 (indice a partir de 1) y cada vez que aparece una indicacion que
    captura @c(idx) se incrementa en 1.

    Tanto @c(idx) como @c(index) perfectamente podrian estar fuera de la
    estructura incluso puede que sea mas adecuado:

    ..src > c
      #define MAX_CATCHS          16

      struct CATch {
        char *ptr;
        int   len;
        int   id ;
      } static Catch[ MAX_CATCHS ];

      int CatchIdx;
      int CatchIndex;
    < src..

    no obstante, mantener todo agrupado bajo un solo @"(nombre) por alguna
    extraña razon se ve mejor en (@+(mi cabeza)) el codigo. Puedes sumarlo al
    resto de filias del estilo de codificacion que utilizo

    - alinear @"(lo que se puede alinear)
    - instrucciones sencillas (y no tanto) en una sola linea
    - la llave de inicio de cada funcion en la misma linea donde se define
    - espacios a derecha e izquierda de cada argumento
    - dos espacios de indentacion


    Regresando al tema, el siguiente cambio ocurre en @c(regexp3)

    ..src > c
      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;
        text.len     = strlen( txt );
        Catch.ptr[0] = txt;               // ➊
        Catch.len[0] = text.len;          // ➋
        Catch.id [0] = 0;                 // ➌
        Catch.index  = 1;                 // ➍
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        rexp.mods    = 0;

        if( text.len == 0 || rexp.len == 0 ) return 0;

        getMods( &rexp, &rexp );

        for( int forward, i = 0, loops = rexp.mods & MOD_ALPHA ? 1 : text.len; i < loops; i += forward ){
          forward    = 1;
          Catch.idx  = 1;                 // ➎
          text.pos   = 0;
          text.ptr   = txt          + i;
          text.len   = Catch.len[0] - i;  // ➏

          if( walker( rexp ) ){
            if     (  rexp.mods & MOD_OMEGA    ){ if( text.pos == text.len ) return TRUE; }
            else if(  rexp.mods & MOD_LONLEY   )                             return TRUE;
            else if( (rexp.mods & MOD_FwrByChar) || text.pos == 0 )          result++;
            else   {  forward = text.pos;                                    result++; }
          }
        }

        return result;
      }
    < src..

    Con justa razon te preguntaras, ¿que hace este borracho iniciando la primer
    captura con los datos de la cadena ➊➋? En efecto no es necesario, desperdicio
    la primer posicion (0) para evitar aser ajustes estilo @c(index - 1) cada
    vez que el usuario solicite una captura indexada apartir de 1 y no de 0,
    visto de esa forma igual y tiene sentido. Ho, tombien asigno el
    identificador 0 ➌ para que el usuario no tenga acceso a esta captura. En
    consecuencia con lo anterior la primer captura disponible estara en la
    posicion uno ➍.

    Ya en el ciclo de busqueda, como antes se explico, la posicion de cada
    captura con respecto a la regexp esta indicada por la variable @c(id), esta
    debe reiniciarse en cada ciclo ➎, aqui no tenemos problemas de indice pero
    lo colocamos a uno para mentener una consintencia.

    En la vercion anterior, interaccion a iteracion haciamos uso de @c(strlen)
    para establecer la longitud de la cadena, esto no solo es ineficiente, en
    cadenas de longitud consiberable sera una fuente exagerada de lentitud. Ya
    que la captura cero almacena la longitud del texto subtituimos @c(strlen)
    por @c(len) ➏.

    La existencia de las capturas acarrea un problema critico. Ahora el motor no
    solo debe recordar el punto de inicio con respecto a la cadena para cada
    ruta de ejecucion, tambien ha de recordar el indice de captura y el
    identificador.

    ..src > c
      static int walker( struct RE rexp ){
        struct RE track;
        for( const int oCindex = Catch.index, oCidx = Catch.idx, oTpos = text.pos; // ➊
             cutTrack( &rexp, &track, PATH );
             Catch.index = oCindex, Catch.idx = oCidx, text.pos = oTpos )          // ➋
          if( track.len && trekking( &track ) ) return TRUE;

        return FALSE;
      }
    < src..

    easy, agregamos los nuevos puntos de control ➊ y los restablecemos para cada
    ciclo ➋.

    Establecer el inicio y el final de la captura es quiza lo mas complicado, el
    motor debe gestionar el inicio y final de cada captura de forma
    independiente dentro de toda la recursividad. @c(looper), nuestro punto de
    gestion recursivo y de avance por la cadena tambien sera resposable de la
    tarea:

    ..src > c
      static int looper( struct RE *rexp ){
        int iCatch, steps, loops = 0;  // ➊

        switch( rexp->type ){
        case HOOK:                     // ➋
          openCatch( &iCatch );        // ➌
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          if( loops >= rexp->loopsMin ) closeCatch( iCatch ); // ➍
          break;
        case GROUP: case PATH:
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:
          while( loops < rexp->loopsMax && text.pos < text.len && (steps = match( rexp )) ){
            text.pos += steps;
            loops++;
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;
      }
    < src..

    El gestor independiente de cada captura se llama @c(iCatch) ➊, recuerda: aun
    en medio de la recursividad cada funcion tiene sus propios parametros, por
    lo que cada llamada se hara cargo de su propio captura.

    El caso @c(HOOK) ➋, es una copia del codigo en el caso @c(GROUP) al que
    agregamos la apertura de la captura antes de iniciar el ciclo recursivo
    ➌. Al finalizar, si cumplimos el ciclo correctamente cerromos la captura ➍.

    Es posible que la simplesa del codigo muestre las soluciones de forma
    trivial (de no serlo soy un fracaso), detente un momento a asimilar el
    proceso, pon musica psicotropica e imagina situaciones recursivas, magicas,
    misticas y misteriosas.

    Aqui estan las funciones auxiliares (@c(open)|@c(close))@c(Catch)

    ..src > c
      static void openCatch( int *index ){
        if( Catch.index < MAX_CATCHS ){               // ➊
          *index = Catch.index++;                     // ➋
          Catch.ptr[ *index ] = text.ptr + text.pos;  // ➌
          Catch.id [ *index ] = Catch.idx++;          // ➍
        } else *index = MAX_CATCHS;                   // ➎
      }
    < src..

    ..src > c
      static void closeCatch( int index ){
        if( index < MAX_CATCHS )                      // ➏
          Catch.len[ index ] = &text.ptr[ text.pos ] - Catch.ptr[ index ]; // ➐
      }
    < src..

    En ambas funciones antes de hacer nada comprobamos que estemos dentro del
    limite del arreglo ➊➏. En @c(openCatch) si se ha llegado al ultimo elemento
    regresamos un valor @"(seguro) ➎, si no hacemos esto el paramentro @c(index)
    contrendra un valor basura, que perfectamente podria pasar la prueba inicial
    de @c(closeCatch) probocando resultados escabrosos.

    El resto es optener e ircrementar el indice actual ➋, establecer el punto de
    inicio en la cadena ➌ y optener e incrementar el identificador actual ➍.

    Cerromos la captura restando la posicion inicial a la posicion actual, esto
    nos da la longitud en bytes.

    Listo tenemos Capturas funcionales... sin una interfaz de uso.

    Que funciones necesita realizar el usuario con las capturas?

    1. Conocer cuantas capturas hay

       ..src > c
         int totCatch(){ return Catch.index - 1; }
       < src..

    2. Recuperar los datos de la captura

       ..src > c
         char * gpsCatch( int index ){
           return ( index > 0 && index < Catch.index ) ? Catch.ptr[ index ] : 0;
         }

         int lenCatch( int index ){
           return ( index > 0 && index < Catch.index ) ? Catch.len[ index ] : 0;
         }
       < src..

       @c(gpsCatch) nos regeresa la posicion de inicio de la captura, o un
       puntero nulo

       @c(lenCatch) nos informa la longitud de una captura o regeresa cero

    3. Recuperar una captura

       ..src > c
         char * cpyCatch( char * str, int index ){
           if( index > 0 && index < Catch.index ){
             strncpy( str, Catch.ptr[ index ], Catch.len[ index ] );
             str[ Catch.len[ index ] ] = '\0';
           } else *str = '\0';

           return str;
         }
       < src..

       el usuario nos indica el indice de la captura y nos proporciona la
       memoria que haga falta para hacer una copia, posiblemente con ayuda de
       @c(lenCatch), y nosotres amablemente le hacemos una copia que finaliza
       con el signo de terminacion de cadena, junto con un apuntador, por si
       desea utilizarlo directamente.

       Si el indice es incorrecto, le enviamos una cadena vacia.

    4. Reemplazar todas las apariciones de una coincidencia

       hey, aqui es donde el identificador @c(id) demuestra utilidad

       ..src > c
         char * rplCatch( char * newStr, char * rplStr, int id ){
           char *oNewStr = newStr, *text = Catch.ptr[ 0 ];          // ➊
           strcpy( newStr, text );                                  // ➋

           for( int index = 1; index < Catch.index; index++ )       // ➌
             if( Catch.id[ index ] == id ){                         // ➍
               newStr += Catch.ptr[ index ] - text;                 // ➎
               strcpy( newStr, rplStr );                            // ➏
               newStr += strlen( rplStr );                          // ➐
               text    = Catch.ptr[ index ] + Catch.len[ index ];   // ➑
               strcpy( newStr, text );                              // ➒
             }

           return oNewStr;                                          // ➓
         }
       < src..

       Los argumentos son los siguientes: @c(newStr) es un puntero a una cadena
       de caracteres que almacena el resultado, @c(rplStr) es la cadena que
       substituira la captura e @c(id) el identificador de las capturas a
       modificar.

       Es necesario advertir que la cadena @c(newStr) no debe ser la misma que
       la cadena principal (@c(txt) de @c(regexp3)). Esto se debe a que:

       - esta funcion esta diseñada para trabajar con cadenas distintas,
       - no deberaimos alterar los datos de entrada bajo ningun motivo,
       - las demas funciones de manejo de capturas apuntaran a datos erroneos
       - y desconocemos si la cadena principal es modificable.

       A la explicacion. Tenemos dos cadenas, la cadena fuente @c(text) y la
       cadena donde ponemos el resultado de la modificacion @c(newStr) ➊.

       No sabemos si la captura a modificar existe, ¿que deberiamos regeresar en
       caso no realizar ninguna modificacion? Una copia exacta de la cadena
       fuente ➋.

       Lo que hacemos es recorrer todas las capturas ➌, en busca de
       coincidencias del @c(id) que nos solicitan ➍. Si hay una coincidencia nos
       movemos a la posicion donde se supone esta el inicio de la captura ➎,
       hacemos el reemplazo ➏ y movemos la cadena fuente ➑ y la resultado ➐ al
       final del la captura-subtitucion, sincronizamos el resto de la cadena ➒ y
       continuamos buscando coincidencias.

       Al terminar regresamos un puntero a la posicion inicial del resultado ➓.

       Por cierto, el funcionamiento actual de la funcion, la hace incompatible
       con el modificador @c(MOD_FwrByChar) (@c(~)) entender el porque sera
       parte de tu entrenamiento. El resto de funciones no tiene ninguna
       contraindicacion.

    5. Poder crear una cadena apartir de las capturas

       ..src > c
         char * putCatch( char * newStr, char * putStr ){
           char *pos, *oNewStr = newStr;
           strcpy( newStr, putStr );

           while( (pos = strchr( putStr, '#' )) ){     // ➊
             if( pos[ 1 ] == '#' ){                    // ➋
               newStr += pos + 1 - putStr;
               putStr  = pos + 2;
             } else {
               int index = atoi( pos + 1 );            // ➌
               newStr += pos - putStr;
               cpyCatch( newStr, index );              // ➍
               newStr += lenCatch( index );
               putStr  = pos + 1 + countCharDigits( pos + 1 );
             }

             strcpy( newStr, putStr );
           }

           return oNewStr;                             // ➎
         }
       < src..

       Esta funcion esta basada @c(printf), solo que en lugar de desplegar el
       resultado, lo almacena en una cadena @c(netStr) y en lugar de subtituir
       sus secuencias especiales por valores, lo hara por capturas. Nuestra
       secuencia especial sera el signo @c(#) seguido por el indice de una
       captura, por ejemplo:

       ..src > c
         rplCatch( str, "la primer captura es : #1" );
       < src..

       Colocara dentro de la cadena @c(str) el texto @c(la primer captura es : )
       y la secuencia @c(#1) sera subtituida por el contenido de la primer
       captura.

       - Si el indice es incorrecto no colocamos nada y el indicador
         @"(desaparace).

       - Si en lugar de un indice (numeros) hay una secuencia de caracteres no
         numerica, en el resultado desaparace el signo @c(#), pero la secuencia
         de caracteres seguira precente.

       - Si lo que queremos es colocar un @c(#), ponemos la secuencia @c(##). El
         primer @c(#) @"(escapa) al segundo @c(#).

       El mecanismo de @c(putCatch) es similar al de @c(rplCatch). En lugar de
       recorrer los indices, se recorren las secuencias @c(#) ➊.

       Si la secuencia va seguida de un @c(#) ➋, en la cadena resultado dejamos
       un @c(#), sincronizamos el resto y vamos por la siguiente secuencia. De
       lo contrario, se optene el indice de la captura ➌, movemos la cadena
       @c(newStr) a la posicion de inicio de la secuencia @c(#) y hacemos una
       copia del contenido de la captura con ayuda de @c(cpyCatch) ➍ (si el
       indice es incorrecto @c(cpyCatch) solo colocara un '\0'). Luego movemos
       @c(newStr) al fin del texto de la captura y @c(putStr) al fin de la
       secuencia especial. Sincronizamos el resto y buscamos la siguiente
       secuencia.

       Al terminar se regresa un puntero al inicio de la cadena ➎ resultado.


    Como es costumbre aplicamos un conjunto variado de pruebas.

    ..src > c
        char str[1024];
      #define CATCH_TEST( text, re, n, rtext )                \
        result = regexp3( text, re );                         \
        total++;                                              \
        if( strcmp( cpyCatch( str, n ), rtext ) != 0 ){       \
          printf( "%s:%d Error on " text ", " re "\n",        \
                  __FILE__, __LINE__ );                       \
          printf( "result    >>%s<<\n"                        \
                  "expected  >>%s<<\n", str, rtext );         \
          errs++;                                             \
        }

        CATCH_TEST( "a", "<a>", 1, "a" );
        CATCH_TEST( "aa", "<aa>", 1, "aa" );
        CATCH_TEST( "a a a", "<a>", 3, "a" );
        CATCH_TEST( "abcd", "<a|b|c|d>", 1, "a" );
        CATCH_TEST( "abcd", "<a|b|c|d>", 2, "b" );
        CATCH_TEST( "abcd", "<a|b|c|d>", 3, "c" );
        CATCH_TEST( "abcd", "<a|b|c|d>", 4, "d" );
        CATCH_TEST( "abcd", "<a|b|c|d>", 5, "" );
        CATCH_TEST( "abc", "a<x>", 1, "" );
        CATCH_TEST( "abc", "<a>x", 1, "" );
        CATCH_TEST( "abc", "<a|b>x", 1, "" );
        CATCH_TEST( "abc", "<<a|b>x|abc>", 1, "abc" );
        CATCH_TEST( "abc", "<<a|b>x|abc>", 2, "" );
        CATCH_TEST( "abc", "<x<a|b>|abc>", 1, "abc" );
        CATCH_TEST( "abc", "<x<a|b>|abc>", 2, "" );
        CATCH_TEST( "abc abc abc", "<a|b|c>", 9, "c" );
        CATCH_TEST( "abc abc abc", "<(a|b|c)(a|b|c)(a|b|c)>", 3, "abc" );
        CATCH_TEST( "abc abc abc", "<(a|b|c)(a|b|c)(a|b|c)> ", 2, "abc" );
        CATCH_TEST( "abc abc abc", "#?<(a|b|c)(a|b|c)(a|b|c)>", 1, "abc" );
        CATCH_TEST( "abc abc abc", "#?<(a|b|c)(a|b|c)((a|b)|x)>", 1, "" );
        CATCH_TEST( "abc abc abx", "#?<(a|b|c)(a|b|c)((a|b)|x)>", 1, "abx" );
        CATCH_TEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 1, "abc" );
        CATCH_TEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 2, "iec" );
        CATCH_TEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 3, "i" );
        CATCH_TEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 4, "c" );
        CATCH_TEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 5, "oeb" );
        CATCH_TEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 6, "o" );
        CATCH_TEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 7, "b" );
        CATCH_TEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 8, "" );

        CATCH_TEST( "a", "<a>?", 1, "a" );
        CATCH_TEST( "a", "<b>?", 1, "" );
        CATCH_TEST( "a", "<a>+", 1, "a" );
        CATCH_TEST( "a", "<a>*", 1, "a" );
        CATCH_TEST( "a", "<b>*", 1, "" );
        CATCH_TEST( "aaa", "<a>+", 1, "aaa" );
        CATCH_TEST( "aaa", "<a>*", 1, "aaa" );
        CATCH_TEST( "aaa", "#~<a>+", 1, "aaa" );
        CATCH_TEST( "aaa", "#~<a>*", 1, "aaa" );
        CATCH_TEST( "aaab", "#~<a+>", 1, "aaa" );
        CATCH_TEST( "aaab", "#~<a*>", 1, "aaa" );
        CATCH_TEST( "aaab", "#~<a?>", 4, "" );
        CATCH_TEST( "aaab", "#~<a+b>", 1, "aaab" );
        CATCH_TEST( "aaab", "#~<a*b>", 1, "aaab" );
        CATCH_TEST( "aaab", "#~<a?b>", 1, "ab" );
        CATCH_TEST( "aaab", "#~<a+b?>", 1, "aaab" );
        CATCH_TEST( "aaab", "#~<a*b?>", 1, "aaab" );
        CATCH_TEST( "aaab", "#~<a?b?>", 3, "ab" );
        CATCH_TEST( "aaab", "#~<a+b+>", 1, "aaab" );
        CATCH_TEST( "aaab", "#~<a*b+>", 1, "aaab" );
        CATCH_TEST( "aaab", "#~<a?b+>", 1, "ab" );
        CATCH_TEST( "aaab", "#~<a+b*>", 1, "aaab" );
        CATCH_TEST( "aaab", "#~<a*b*>", 1, "aaab" );
        CATCH_TEST( "aaab", "#~<a?b*>", 3, "ab" );
        CATCH_TEST( "aaabaaa", "#~<a+>", 4, "aaa" );
        CATCH_TEST( "aaabaaa", "#~<a*>", 5, "aaa" );

        CATCH_TEST( "Raptor Test",     "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1, "Raptor Test" );
        CATCH_TEST( "Raptor Test",     "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 2, "T" );
        CATCH_TEST( "Raaaaptor TFest", "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1, "Raaaaptor TFest" );
        CATCH_TEST( "Raaaaptor TFest", "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 2, "TF" );
        CATCH_TEST( "CaptorTest",      "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1, "CaptorTest" );
        CATCH_TEST( "Cap CaptorTest",  "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1, "Cap CaptorTest" );
        CATCH_TEST( "Cap CaptorTest",  "#~<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 3, "CaptorTest" );
        CATCH_TEST( "Rap Captor Fest", "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1, "Rap Captor Fest" );
        CATCH_TEST( "Rap Captor Fest", "#~<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 3, "Captor Fest" );

      #define REPLACE_TEST( text, re, n, rtext, ctext )               \
        result = regexp3( text, re );                                 \
        total++;                                                      \
        if( strcmp( rplCatch( str, rtext, n ), ctext ) != 0 ){        \
          printf( "%s:%d Error on " text ", " re "\n",                \
                  __FILE__, __LINE__ );                               \
          printf( "result    >>%s<<\n"                                \
                  "expected  >>%s<<\n", str, ctext );                 \
          errs++;                                                     \
        }

        REPLACE_TEST( "a", "<a>"   , 1, "", "" );
        REPLACE_TEST( "a", "<a>?"  , 1, "", "" );
        REPLACE_TEST( "a", "<a>+"  , 1, "", "" );
        REPLACE_TEST( "a", "<a>*"  , 1, "", "" );
        REPLACE_TEST( "a", "<a>{1}", 1, "", "" );
        REPLACE_TEST( "a", "<a?>"  , 1, "", "" );
        REPLACE_TEST( "a", "<a+>"  , 1, "", "" );
        REPLACE_TEST( "a", "<a*>"  , 1, "", "" );
        REPLACE_TEST( "a", "<a{1}>", 1, "", "" );

        REPLACE_TEST( "a", "<a>"   , 1, "e", "e" );
        REPLACE_TEST( "a", "<a>?"  , 1, "e", "e" );
        REPLACE_TEST( "a", "<a>+"  , 1, "e", "e" );
        REPLACE_TEST( "a", "<a>*"  , 1, "e", "e" );
        REPLACE_TEST( "a", "<a>{1}", 1, "e", "e" );
        REPLACE_TEST( "a", "<a?>"  , 1, "e", "e" );
        REPLACE_TEST( "a", "<a+>"  , 1, "e", "e" );
        REPLACE_TEST( "a", "<a*>"  , 1, "e", "e" );
        REPLACE_TEST( "a", "<a{1}>", 1, "e", "e" );

        REPLACE_TEST( "a", "<x>"   , 1, "z", "a" );
        REPLACE_TEST( "a", "<x>?"  , 1, "z", "za" );
        REPLACE_TEST( "a", "<x>+"  , 1, "z", "a" );
        REPLACE_TEST( "a", "<x>*"  , 1, "z", "za" );
        REPLACE_TEST( "a", "<x>{1}", 1, "z", "a" );
        REPLACE_TEST( "a", "<x?>"  , 1, "z", "za" );
        REPLACE_TEST( "a", "<x+>"  , 1, "z", "a" );
        REPLACE_TEST( "a", "<x*>"  , 1, "z", "za" );
        REPLACE_TEST( "a", "<x{1}>", 1, "z", "a" );

        REPLACE_TEST( "aaa", "<a>"   , 1, "", "" );
        REPLACE_TEST( "aaa", "<a>?"  , 1, "", "" );
        REPLACE_TEST( "aaa", "<a>+"  , 1, "", "" );
        REPLACE_TEST( "aaa", "<a>*"  , 1, "", "" );
        REPLACE_TEST( "aaa", "<a>{1}", 1, "", "" );
        REPLACE_TEST( "aaa", "<a?>"  , 1, "", "" );
        REPLACE_TEST( "aaa", "<a+>"  , 1, "", "" );
        REPLACE_TEST( "aaa", "<a*>"  , 1, "", "" );
        REPLACE_TEST( "aaa", "<a{1}>", 1, "", "" );

        REPLACE_TEST( "aaa", "<a>"   , 1, "e", "eee" );
        REPLACE_TEST( "aaa", "<a>?"  , 1, "e", "eee" );
        REPLACE_TEST( "aaa", "<a>+"  , 1, "e", "e" );
        REPLACE_TEST( "aaa", "<a>*"  , 1, "e", "e" );
        REPLACE_TEST( "aaa", "<a>{1}", 1, "e", "eee" );
        REPLACE_TEST( "aaa", "<a?>"  , 1, "e", "eee" );
        REPLACE_TEST( "aaa", "<a+>"  , 1, "e", "e" );
        REPLACE_TEST( "aaa", "<a*>"  , 1, "e", "e" );
        REPLACE_TEST( "aaa", "<a{1}>", 1, "e", "eee" );

        REPLACE_TEST( "aaa", "<x>"   , 1, "z", "aaa" );
        REPLACE_TEST( "aaa", "<x>?"  , 1, "z", "zazaza" );
        REPLACE_TEST( "aaa", "<x>+"  , 1, "z", "aaa" );
        REPLACE_TEST( "aaa", "<x>*"  , 1, "z", "zazaza" );
        REPLACE_TEST( "aaa", "<x>{1}", 1, "z", "aaa" );
        REPLACE_TEST( "aaa", "<x?>"  , 1, "z", "zazaza" );
        REPLACE_TEST( "aaa", "<x+>"  , 1, "z", "aaa" );
        REPLACE_TEST( "aaa", "<x*>"  , 1, "z", "zazaza" );
        REPLACE_TEST( "aaa", "<x{1}>", 1, "z", "aaa" );

        REPLACE_TEST( "aaab", "<a>"   , 1, "e", "eeeb" );
        REPLACE_TEST( "aaab", "<a>?"  , 1, "e", "eeeeb" );
        REPLACE_TEST( "aaab", "<a>+"  , 1, "e", "eb" );
        REPLACE_TEST( "aaab", "<a>*"  , 1, "e", "eeb" );
        REPLACE_TEST( "aaab", "<a>{1}", 1, "e", "eeeb" );
        REPLACE_TEST( "aaab", "<a?>"  , 1, "e", "eeeeb" );
        REPLACE_TEST( "aaab", "<a+>"  , 1, "e", "eb" );
        REPLACE_TEST( "aaab", "<a*>"  , 1, "e", "eeb" );
        REPLACE_TEST( "aaab", "<a{1}>", 1, "e", "eeeb" );

        REPLACE_TEST( "aaab", "<x>"   , 1, "z", "aaab" );
        REPLACE_TEST( "aaab", "<x>?"  , 1, "z", "zazazazb" );
        REPLACE_TEST( "aaab", "<x>+"  , 1, "z", "aaab" );
        REPLACE_TEST( "aaab", "<x>*"  , 1, "z", "zazazazb" );
        REPLACE_TEST( "aaab", "<x>{1}", 1, "z", "aaab" );
        REPLACE_TEST( "aaab", "<x?>"  , 1, "z", "zazazazb" );
        REPLACE_TEST( "aaab", "<x+>"  , 1, "z", "aaab" );
        REPLACE_TEST( "aaab", "<x*>"  , 1, "z", "zazazazb" );
        REPLACE_TEST( "aaab", "<x{1}>", 1, "z", "aaab" );

        REPLACE_TEST( "aaabaaa", "<a>"   , 1, "e", "eeebeee" );
        REPLACE_TEST( "aaabaaa", "<a>?"  , 1, "e", "eeeebeee" );
        REPLACE_TEST( "aaabaaa", "<a>+"  , 1, "e", "ebe" );
        REPLACE_TEST( "aaabaaa", "<a>*"  , 1, "e", "eebe" );
        REPLACE_TEST( "aaabaaa", "<a>{1}", 1, "e", "eeebeee" );
        REPLACE_TEST( "aaabaaa", "<a?>"  , 1, "e", "eeeebeee" );
        REPLACE_TEST( "aaabaaa", "<a+>"  , 1, "e", "ebe" );
        REPLACE_TEST( "aaabaaa", "<a*>"  , 1, "e", "eebe" );
        REPLACE_TEST( "aaabaaa", "<a{1}>", 1, "e", "eeebeee" );

        REPLACE_TEST( "aaabaaa", "<x>"   , 1, "z", "aaabaaa" );
        REPLACE_TEST( "aaabaaa", "<x>?"  , 1, "z", "zazazazbzazaza" );
        REPLACE_TEST( "aaabaaa", "<x>+"  , 1, "z", "aaabaaa" );
        REPLACE_TEST( "aaabaaa", "<x>*"  , 1, "z", "zazazazbzazaza" );
        REPLACE_TEST( "aaabaaa", "<x>{1}", 1, "z", "aaabaaa" );
        REPLACE_TEST( "aaabaaa", "<x?>"  , 1, "z", "zazazazbzazaza" );
        REPLACE_TEST( "aaabaaa", "<x+>"  , 1, "z", "aaabaaa" );
        REPLACE_TEST( "aaabaaa", "<x*>"  , 1, "z", "zazazazbzazaza" );
        REPLACE_TEST( "aaabaaa", "<x{1}>", 1, "z", "aaabaaa" );


        REPLACE_TEST( "Raptor Test", "<Raptor>", 1, "Captor", "Captor Test"   );
        REPLACE_TEST( "Raptor Test", "<Raptor>", 0, "Captor", "Raptor Test"   );
        REPLACE_TEST( "Raptor Test", "<Raptor|Test>", 0, "Captor", "Raptor Test"   );
        REPLACE_TEST( "Raptor Test", "<Raptor|Test>", 1, "Captor", "Captor Captor"   );
        REPLACE_TEST( "Raptor Test", "<Raptor|Test>", 2, "Captor", "Raptor Test"   );
        REPLACE_TEST( "Raptor Test", "<Raptor|<Test>>", 2, "Fest", "Raptor Fest"   );
        REPLACE_TEST( "Raptor Raptors Raptoring", "<Raptor:w*>", 1, "Test", "Test Test Test" );
        REPLACE_TEST( "Raptor Raptors Raptoring", "<Raptor>:w*", 1, "Test", "Test Tests Testing" );
        REPLACE_TEST( "Raptor Raptors Raptoring", "<<<R>a>ptor>:w*", 3, "C", "Captor Captors Captoring" );
        REPLACE_TEST( "Raptor Raptors Raptoring", "<<<R>a>ptor>:w*", 2, "4", "4ptor 4ptors 4ptoring" );

      #define PUT_TEST( text, re, rtext, ctext )              \
        result = regexp3( text, re );                         \
        total++;                                              \
        if( strcmp( putCatch( str, rtext ), ctext ) != 0 ){   \
          printf( "%s:%d Error on " text ", " re "\n",        \
                  __FILE__, __LINE__ );                       \
          printf( "result    >>%s<<\n"                        \
                  "expected  >>%s<<\n", str, ctext );         \
          errs++;                                             \
        }

        PUT_TEST( "a", "<a>", "#1", "a" );
        PUT_TEST( "a", "<a>", "#x", "x" );
        PUT_TEST( "a", "<a>", "#xx", "xx" );
        PUT_TEST( "a", "<a>", "###1##", "#a#" );
        PUT_TEST( "a", "<a>", "[#0][#1][#2#3#1000000]", "[][a][]" );
        PUT_TEST( "aa", "<aa>", "#1", "aa" );
        PUT_TEST( "a a a", "<a>", "#1#2#3", "aaa" );
        PUT_TEST( "abcd", "<a|b|c|d>", "#4 #3 #2 #1", "d c b a" );
        PUT_TEST( "1 2 3 4 5 6 7 8 9", "<1|2|3|4|5|6|7|8|9>", "#5 #6 #7 #8 #9 #1 #2 #3 #4", "5 6 7 8 9 1 2 3 4" );
        PUT_TEST( "Raptor Test", "<aptor|est>", "C#1 F#2", "Captor Fest" );
        PUT_TEST( "Raptor Test", "<aptor|est>", "C#5 F#2", "C Fest" );
        PUT_TEST( "Raptor Test", "<aptor|est>", "C#a F#2", "Ca Fest" );
        PUT_TEST( "Raptor Test", "<aptor|est>", "C#0 F#2", "C Fest" );
        PUT_TEST( "Raptor Test", "<aptor|est>", "C#43 F#43", "C F" );
        PUT_TEST( "Raptor Test", "<aptor|est>", "C##43 ##F#43##", "C#43 #F#" );
        PUT_TEST( "Raptor Test", "<aptor|est>", "C##43 ##1##2", "C#43 #1#2" );
        PUT_TEST( "Raptor Test", "<aptor|est>", "##Raptor ##Test", "#Raptor #Test" );
        PUT_TEST( "Raptor Test Fest", "<Raptor> <Test>", "#1_#2", "Raptor_Test" );
    < src..

*** backreferences

    Con las capturas en pleno funcionamiento ya podemos implementar un
    constructor bastante util, mejor conocido como @e(backreferences). Su poder
    consinte en solicitar la coincidencia del texto de una captura en la cadena.

    Esta sera su sintaxis

    ..example >
      @id
    < example..

    donde @'c(@@) es el identificador del constructor, e @c(id) la posicion de
    la captura con respecto a la regexp, por ejemplo

    ..src > c
      regexp3( "12-06-12", "#^:d:d<:-|/>:d:d@1:d:d" );
    < src..

    la regexp nos  permite validar una cadena de formato fecha, en la que
    especificamos que el separador enre cifras puede ser @c(-) o @c(/) y debe
    ser el mismo en las dos posiciones donde aparece.

    Para lograrlo capturamos el primer separador con este constructor
    @c(<:-|/>). Con repecto a la expresion esta es la primer captura, por lo
    tanto podemos solicitar una referencia hacia atras (backreference) con el
    constructor @c(@@1). solicita la aparicion de la primer
    captura.

    Si la exprecion fuese

    ..src > c
      regexp3( "12-06-12", "#^<:d:d><:-|/><:d:d>@2<:d:d>" );
    < src..

    La captura a cargo del separador, seria la segunda captura con respecto a su
    aparicion en la exprecion por lo tanto la referencia hacia hatras es
    @c(@@2). Con la exprecion

    ..src > c
      regexp3( "12-06-12", "#^<:d:d<:-|/>:d:d@2:d:d>" );
    < src..

    ocurre lo mismo, la primer captura es la que esta al exterior, y la segunda
    la encargada del separador.

    Obviamene la captura debe preceder a la referencia hacia atras y la
    referencia no puede estar dentro de la captura a la que refiere.

    Vamos al codigo.

    El tipo @c(BACREF) precente en el codigo desde tiempos inmemoriales,
    ejercera como identificador del nuevo constructor, basta con entrenar al
    motor para que reconosca la nueva sintaxis, por supuesto esto ocurre en
    @c(tracker)

    ..src > c
      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case ':': trackByLen( rexp, track, 2, META    ); break;
        case '.': trackByLen( rexp, track, 1, POINT   ); break;
        case '@': trackByLen( rexp, track, 1 +                                          // ➊
                              countCharDigits( rexp->ptr + 1 ),
                                              BACKREF ); break;
        case '(': cutTrack  ( rexp, track,    GROUP   ); break;
        case '<': cutTrack  ( rexp, track,    HOOK    ); break;
        case '[': cutTrack  ( rexp, track,    SET     ); break;
        default :
          if( (point = trackerPoint( "(<[@:.?+*{-#", rexp->ptr + 1, rexp->len - 1 )) ){ // ➋
            switch( *point ){
            case '(': case '<': case '[': case '@': case ':': case '.':                 // ➌
              trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;
            case '?': case '+': case '*': case '{': case '-': case '#':
              if( point - rexp->ptr == 1 ){
                if( *point == '-' ) trackByLen( rexp, track, 3, RANGEAB );
                else                trackByLen( rexp, track, 1, SIMPLE  );
              } else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  );
            }
          } else trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

        getLoops( rexp, track );
        getMods ( rexp, track );
        return TRUE;
      }
    < src..

    Si aparece el signo del @c(@@) ➊, la longitud del constructor es, el signo
    @c(1) mas los digitos que tenga a continuacion. Agregamos el signo a la
    cadena de rastreo ➋, y colocamos el caso junto a los demas constructores no
    @c(SIMPLE) ➌.

    Si no queremos que el constructor se maneje como una simple busqueda de
    texto, tenemos que especificar la reaccion en @c(match).

    ..src > c
      static int match( struct RE *rexp ){
        switch( rexp->type ){
        case POINT  : return text.pos < text.len;
        case SET    : return matchSet    ( *rexp );
        case BACKREF: return matchBackRef(  rexp );   // ➊
        case RANGEAB: return matchRange( rexp, text.ptr[text.pos]  );
        case META   : return matchMeta ( rexp, text.ptr[text.pos]  );
        default     : return matchText ( rexp, text.ptr + text.pos );
        }
      }
    < src..

    hay lo tienes, el caso es lo suficientemente extenso para necesitar su
    propia funcion: @c(matchBackRef) ➊.

    ..src > c
      static int matchBackRef( struct RE *rexp ){
        int backRefId    = atoi( rexp->ptr + 1 );     // ➊
        int backRefIndex = lastIdCatch( backRefId );  // ➋
        if( gpsCatch( backRefIndex ) == 0 ||
            strncmp( text.ptr + text.pos, gpsCatch( backRefIndex ), lenCatch( backRefIndex ) ) != 0 )
          return FALSE;                               // ➌
        else return lenCatch( backRefIndex );         // ➍
      }
    < src..

    La variable @c(backRefId) almacena el identificador de la captura ➊,
    buscamos el indice de la ultima captura con dicho identificador y lo
    almacenamos en @c(backRefIndex) ➋. Si la captura no existe (apunta a null) o
    el texto que contiene no coincide con la cadena, regeresamos @c(FALSE) ➌. En
    otro caso tenemos una coincidencia, y regeresamos la longitud de la captura ➍.

    Ya que el @c(id) de uno captura no proporciona su ubicacion dentro de las
    capturas, en ➋ hacemos uso de la funcion auxiliar @c(lastIdCatch) que
    reccore el indice de capturas en busca de la ultima coindicencia del
    @c(id), porque obviamente una referencia hacia atras requiere una captura
    previa...

    ..src > c
      static int lastIdCatch( int id ){
        for( int index = Catch.index - 1; index > 0; index-- )
          if( Catch.id[ index ] == id ) return index;

        return MAX_CATCHS;
      }
    < src..

    ... un momento, entoces podria hacer referencia a una captura de indice
    superior al de ciclo actual que coincida con el del ciclo anterior?

    ..src > c
      regexp3( "abcdefghijk", "<:a><:a>@3<:a>" );
    < src..

    @e(no), esta ruta de ejecucion jamas dara una coincidencia. La referencia
    aun no existe, pero si lo intentas con rutas de ejecucion distintas, es posible

    ..src > c
      regexp3( "abXdeXf", "<:a><:a>@3<:a>|<:a><:a><:a>" );
    < src..

    complicado sera escribir un patron como este de forma accidental.

    Uno eres ya con el codigo? Con el esquema actual, donde @c(tracker) se
    encarga de optener todos las constructores, como reacciona @c(matchSet) si
    hay una expresion tipo @c([@@100])?

    Con las siguientes pruebas terminamos las pruebas al motor (en su vercion
    ascii). 1022 pruebas en total!

    ..src > c
      PUT_TEST( "nasciiboy@gmail.com", "<[_A-Za-z0-9:-]+(:.[_A-Za-z0-9:-]+)*>:@<[A-Za-z0-9]+>:.<[A-Za-z0-9]+><(:.[A-Za-z0-9]{2})*", "[#1][#2][#3]", "[nasciiboy][gmail][com]" );
      PUT_TEST( "<mail>nasciiboy@gmail.com</mail>", "<[_A-Za-z0-9:-]+(:.[_A-Za-z0-9:-]+)*>:@<[A-Za-z0-9]+>:.<[A-Za-z0-9]+><(:.[A-Za-z0-9]{2})*", "[#1][#2][#3]", "[nasciiboy][gmail][com]" );
      PUT_TEST( "u.s.r_43@ru.com.jp", "<[_A-Za-z0-9:-]+(:.[_A-Za-z0-9:-]+)*>:@<[A-Za-z0-9]+>:.<[A-Za-z0-9]+><(:.[A-Za-z0-9]{2})*", "[#1][#2][#3]", "[u.s.r_43][ru][com]" );
      PUT_TEST( "07-07-1777", "<0?[1-9]|[12][0-9]|3[01]><[/:-\\]><0?[1-9]|1[012]>@2<[12][0-9]{3}>", "d:#1 m:#3 y:#4", "d:07 m:07 y:1777" );
      PUT_TEST( "fecha: 07-07-1777", "<0?[1-9]|[12][0-9]|3[01]><[/:-\\]><0?[1-9]|1[012]>@2<[12][0-9]{3}>", "d:#1 m:#3 y:#4", "d:07 m:07 y:1777" );

      NTEST( "31/13-1331", "<0?[1-9]|[12][0-9]|3[01]><[/:-\\]><0?[1-9]|1[012]>@2<[12][0-9]{3}>", 0 );
      NTEST( "71-17/1177", "<0?[1-9]|[12][0-9]|3[01]><[/:-\\]><0?[1-9]|1[012]>@2<[12][0-9]{3}>", 0 );

      NTEST( "",  "@1",  0 );
      NTEST( "a", "@1",  0 );
      NTEST( "a", "@a",  0 );
      NTEST( "A", "@100", 0 );
      NTEST( "1", "@1",  0 );
      NTEST( "",  "[@1]",  0 );
      NTEST( "a", "[@1]",  0 );
      NTEST( "a", "[@a]",  1 );
      NTEST( "A", "[@100]", 0 );
      NTEST( "1", "[@1]",  1 );
      NTEST( "@", "[@1]",  1 );
      NTEST( "1@@a", "[a@1]",  4 );
      NTEST( "",  "[^@1",  0 );
      NTEST( "a", "[^@1]",  1 );
      NTEST( "a", "[^@a]",  0 );
      NTEST( "A", "[^@100]", 1 );
      NTEST( "1", "[^@1]",  0 );
      NTEST( "@", "[^2@]",  0 );

      NTEST( "",  "(@1)",  0 );
      NTEST( "a", "(@1)",  0 );
      NTEST( "a", "(@a)",  0 );
      NTEST( "A", "(@100)", 0 );
      NTEST( "1", "(@1)",  0 );
      NTEST( "",  "([@1])",  0 );
      NTEST( "a", "([@1])",  0 );
      NTEST( "a", "([@a])",  1 );
      NTEST( "A", "([@100])", 0 );
      NTEST( "1", "([@1])",  1 );

      NTEST( "a", "<a>@1",  0 );
      NTEST( "a", "<a>@1?", 1 );
      NTEST( "a", "<a>@1*", 1 );
      NTEST( "a", "<a>@1+", 0 );
      NTEST( "a", "<a>@1{1}", 0 );
      NTEST( "aa", "<a>@1",  1 );
      NTEST( "aa", "<a>@1?", 1 );
      NTEST( "aa", "<a>@1+", 1 );
      NTEST( "aa", "<a>@1*", 1 );
      NTEST( "aa", "<a>@1{1}", 1 );
      NTEST( "aaaaa", "<a>@1",  2 );
      NTEST( "aaaaa", "<a>@1?", 3 );
      NTEST( "aaaaa", "<a>@1+", 1 );
      NTEST( "aaaaa", "<a>@1*", 1 );
      NTEST( "aaaaa", "<a>@1{1}", 2 );

      NTEST( "a-a", "<a|:d|o_O!>-@1",  1 );
      NTEST( "1-1", "<a|:d|o_O!>-@1", 1 );
      NTEST( "o_O!-o_O!", "<a|:d|o_O!>-@1", 1 );

      NTEST( "ae_ea", "<a><e>_@2@1", 1 );
      NTEST( "ae_ea", "<<a><e>>_@2@1", 0 );
      NTEST( "ae_aae", "<<a><e>>_@2@1", 1 );
      NTEST( "ae_eaae_ea", "<a><e>_@2@1", 2 );
      NTEST( "ae_eaae_ea", "<<a><e>>_@2@1", 0 );
      NTEST( "ae_aaeae_aae", "<<a><e>>_@2@1", 2 );
      NTEST( "ae_aaeae_aa1", "<<a><e>>_@2@1", 1 );

      NTEST( "aaaaa", "@1<a>", 0 );
      NTEST( "aaaaa", "@1<a>|<a>", 3 );
      NTEST( "xxaxa", "@1<a>|<x>", 3 );
      NTEST( "xxax", "@1<a>|<x>", 3 );
      NTEST( "x1xax", "@1<a>|<x>1", 2 );
      NTEST( "x1xaxa", "@1<a>|<x>1", 2 );
      NTEST( "x1xaaa", "@1<a>|<x>1", 3 );

      NTEST( "012345678910012345678910", "<0><1><2><3><4><5><6><7><8><9><10>@1@2@3@4@5@6@7@8@9@10@11", 1 );

    < src..

    Uno eres con el codigo ya... de lo contrario

    ..src > c
      #include <ctype.h>
      #include <string.h>
      #include <stdlib.h>

      #define TRUE                 1
      #define FALSE                0
      #define MAX_CATCHS          16
      #define INF         1073741824 // 2^30

      #define MOD_ALPHA            1
      #define MOD_OMEGA            2
      #define MOD_LONLEY           4
      #define MOD_FwrByChar        8
      #define MOD_COMMUNISM       16

      struct CATch {
        char *ptr[ MAX_CATCHS ];
        int   len[ MAX_CATCHS ];
        int   id [ MAX_CATCHS ];
        int   idx;
        int   index;
      } static Catch;

      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      } static text;

      enum TYPE { PATH, GROUP, HOOK, SET, BACKREF, META, RANGEAB, POINT, SIMPLE };

      struct RE {
        char          *ptr;
        int            len;
        enum     TYPE  type;
        unsigned char  mods;
        unsigned int   loopsMin, loopsMax;
      };

      static int  walker       ( struct RE  rexp                                        );
      static int  trekking     ( struct RE *rexp                                        );
      static int  looper       ( struct RE *rexp                                        );
      static int  cutTrack     ( struct RE *rexp  , struct RE *track,          int type );
      static int  tracker      ( struct RE *rexp  , struct RE *track                    );

      static int  walkMeta     ( char      *str                                         );
      static int  walkSet  ( char      *str                                         );
      static void trackByLen   ( struct RE *rexp  , struct RE *track, int len, int type );
      static char *trackerPoint( char      *points, char      *track, int len           );
      static void getMods      ( struct RE *rexp  , struct RE *track                    );
      static void getLoops     ( struct RE *rexp  , struct RE *track                    );
      static void fwrTrack     ( struct RE *track ,                   int len           );

      static int  match        ( struct RE *rexp );
      static int  matchBracket ( struct RE  rexp );
      static int  matchBackRef ( struct RE *rexp );
      static int  matchRange   ( struct RE *rexp, char  chr );
      static int  matchMeta    ( struct RE *rexp, char *txt );
      static int  matchText    ( struct RE *rexp, char *txt );

      static int countCharDigits( char *str );

      static void openCatch    ( int  *index );
      static void closeCatch   ( int   index );
      static int  lastIdCatch  ( int   id    );

      int totalCatch();
      char *gpsCatch( int index );
      int   lenCatch( int index );
      char *cpyCatch( char * str, int index );
      char *rplCatch( char * newStr, char * rplStr, int id );
      char *putCatch( char * newStr, char * putStr );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;
        text.len     = strlen( txt );
        Catch.ptr[0] = txt;
        Catch.len[0] = text.len;
        Catch.id [0] = 0;
        Catch.index  = 1;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        rexp.mods    = 0;

        if( text.len == 0 || rexp.len == 0 ) return 0;

        getMods( &rexp, &rexp );

        for( int forward, i = 0, loops = rexp.mods & MOD_ALPHA ? 1 : text.len; i < loops; i += forward ){
          forward    = 1;
          Catch.idx  = 1;
          text.pos   = 0;
          text.ptr   = txt   + i;
          text.len   = Catch.len[0] - i;

          if( walker( rexp ) ){
            if     (  rexp.mods & MOD_OMEGA    ){ if( text.pos == text.len ) return TRUE; }
            else if(  rexp.mods & MOD_LONLEY   )                             return TRUE;
            else if( (rexp.mods & MOD_FwrByChar) || text.pos == 0 )          result++;
            else   {  forward = text.pos;                                    result++; }
          }
        }

        return result;
      }

      static int walker( struct RE rexp ){
        struct RE track;
        while( cutTrack( &rexp, &track, PATH ) )
          if( track.len && trekking( &track ) ) return TRUE;

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;
        int iCatch = MAX_CATCHS, oCindex = Catch.index, oCidx = Catch.idx, oTpos = text.pos;

        while( tracker( rexp, &track ) ){
          if( track.type == HOOK ) openCatch( &iCatch );

          if( track.len == 0 || looper( &track ) == FALSE ){
            text.pos    = oTpos;
            Catch.index = oCindex;
            Catch.idx   = oCidx;
            return        FALSE;
          } else if( track.type == HOOK ) closeCatch( iCatch );
        }

        return TRUE;
      }

      static int looper( struct RE *rexp ){
        int steps, loops = 0;

        switch( rexp->type ){
        case HOOK: case GROUP: case PATH:
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:
          while( loops < rexp->loopsMax && text.pos < text.len && (steps = match( rexp )) ){
            text.pos += steps;
            loops++;
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;
      }

      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( !rexp->len ) return FALSE;

        *track      = *rexp;
        track->type = type;
        if( type != PATH ) fwrTrack( track, 1 );

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          i += walkMeta( rexp->ptr + i );

          switch( rexp->ptr[i] ){
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          case '[': i += walkSet( rexp->ptr + i ); break;
          }

          switch( type ){
          case HOOK    : cut = deep == 0; break;
          case GROUP   : cut = deep == 0; break;
          case SET : cut =              rexp->ptr[i] == ']'; break;
          case PATH    : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );
        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len ){
          switch( *rexp->ptr ){
          case ':': trackByLen( rexp, track, 2, META    ); break;
          case '.': trackByLen( rexp, track, 1, POINT   ); break;
          case '@': trackByLen( rexp, track, 1 +
                                countCharDigits( rexp->ptr + 1 ),
                                                BACKREF ); break;
          case '(': cutTrack  ( rexp, track,    GROUP   ); break;
          case '<': cutTrack  ( rexp, track,    HOOK    ); break;
          case '[': cutTrack  ( rexp, track,    SET ); break;
          default :
            if( (point = trackerPoint( "(<[@:.?+*{-#", rexp->ptr + 1, rexp->len - 1 )) ){
              switch( *point ){
              case '(': case '<': case '[': case '@': case ':': case '.':
                trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;
              case '?': case '+': case '*': case '{': case '-': case '#':
                if( point - rexp->ptr == 1 ){
                  if( *point == '-' ) trackByLen( rexp, track, 3, RANGEAB );
                  else                trackByLen( rexp, track, 1, SIMPLE  );
                } else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  );
              }
            } else trackByLen( rexp, track, rexp->len, SIMPLE  );
          }

          getLoops( rexp, track );
          getMods ( rexp, track );
          return TRUE;
        }

        return FALSE;
      }

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
        *track       = *rexp;
        track->type  = type;
        track->len   = len;
        fwrTrack( rexp, len );
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }

      static int walkSet( char *str ){
        int i = 0;
        while( TRUE )
          switch( str[ i ] ){
          case ']': return i;
          case ':': i += 2; break;
          default : i++   ; break;
          }
      }

      static int walkMeta( char *str ){
        for( int i = 0; ; i += 2 )
          if( str[i] != ':' ) return i;
      }

      static void fwrTrack( struct RE *track, int len ){
        track->ptr += len; track->len -= len;
      }

      static void getMods( struct RE *rexp, struct RE *track ){
        int inMods = *rexp->ptr == '#', pos = 0;

        while( inMods )
          switch( rexp->ptr[ ++pos ] ){
          case '^': track->mods |=  MOD_ALPHA     ; break;
          case '$': track->mods |=  MOD_OMEGA     ; break;
          case '?': track->mods |=  MOD_LONLEY    ; break;
          case '~': track->mods |=  MOD_FwrByChar ; break;
          case '*': track->mods |=  MOD_COMMUNISM ; break;
          case '/': track->mods &= ~MOD_COMMUNISM ; break;
          default : inMods       =  FALSE         ; break;
          }

        fwrTrack( rexp, pos );
      }

      static void getLoops( struct RE *rexp, struct RE *track ){
        track->loopsMin = 1; track->loopsMax = 1;
        int len = 0;

        if( rexp->len )
          switch( *rexp->ptr ){
          case '?' : len = 1; track->loopsMin = 0; track->loopsMax =   1; break;
          case '+' : len = 1; track->loopsMin = 1; track->loopsMax = INF; break;
          case '*' : len = 1; track->loopsMin = 0; track->loopsMax = INF; break;
          case '{' :
            track->loopsMin = atoi( rexp->ptr + 1 ) ;
            if( rexp->ptr[ 1 + countCharDigits( rexp->ptr + 1 ) ] == ',' )
              track->loopsMax = atoi( strchr( rexp->ptr, ',' ) + 1 );
            else
              track->loopsMax = track->loopsMin;

            len = strchr( rexp->ptr, '}' ) - rexp->ptr + 1;
          }

        fwrTrack( rexp, len );
      }

      static int countCharDigits( char *str ){
        for( int digits = 0; ; digits++ )
          if( isdigit( *str++ ) == 0 ) return digits;
      }

      static int match( struct RE *rexp ){
        switch( rexp->type ){
        case POINT  : return text.pos < text.len;
        case SET: return matchBracket( *rexp );
        case BACKREF: return matchBackRef(  rexp );
        case RANGEAB: return matchRange( rexp, text.ptr[text.pos]  );
        case META   : return matchMeta ( rexp, text.ptr + text.pos );
        default     : return matchText ( rexp, text.ptr + text.pos );
        }
      }

      static int cmpChrCommunist( char a, char b){
        a = tolower(a);
        b = tolower(b);
        return a == b;
      }

      static char * strnChrCommunist( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( cmpChrCommunist( str[i], chr ) ) return str + i;

        return 0;
      }

      static int strnCmpCommunist( char *s, char *t, int n ){
        for( ; cmpChrCommunist( *s, *t ); s++, t++ )
          if( *s == '\0' || --n <= 0 ) return 0;

        return *s - *t;
      }

      static char * strnChr( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( str[ i ] == chr ) return str + i;

        return 0;
      }

      static int matchText( struct RE *rexp, char *txt ){
        if( rexp->mods & MOD_COMMUNISM )
          return    strnCmpCommunist( txt, rexp->ptr, rexp->len )  == 0 ? rexp->len : 0;
        else return strncmp         ( txt, rexp->ptr, rexp->len )  == 0 ? rexp->len : 0;
      }

      static int matchRange( struct RE *rexp, char chr ){
        if( rexp->mods & MOD_COMMUNISM ){
          chr = tolower( chr );
          return chr >= tolower( rexp->ptr[ 0 ] ) && chr <= tolower( rexp->ptr[ 2 ] );
        }

        return chr >= rexp->ptr[ 0 ] && chr <= rexp->ptr[ 2 ];
      }

      static int matchMeta( struct RE *rexp, char *txt ){
        switch( rexp->ptr[1] ){
        case 'a' : return  isalpha( *txt ) != 0;
        case 'A' : return !isalpha( *txt ) != 0;
        case 'd' : return  isdigit( *txt ) != 0;
        case 'D' : return !isdigit( *txt ) != 0;
        case 'w' : return  isalnum( *txt ) != 0;
        case 'W' : return !isalnum( *txt ) != 0;
        case 's' : return  isspace( *txt ) != 0;
        case 'S' : return !isspace( *txt ) != 0;
        default  : return *txt == rexp->ptr[1];
        }
      }

      static int matchBracket( struct RE rexp ){
        struct RE track;
        int result  = 0, reverse = *rexp.ptr == '^';

        if( reverse ) fwrTrack( &rexp, 1 );

        while( tracker( &rexp, &track ) ){
          switch( track.type ){
          case RANGEAB: case META: case POINT:
            result = match( &track ); break;
          default:
            if( track.mods & MOD_COMMUNISM )
                 result = strnChrCommunist( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
            else result = strnChr         ( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
          }

          if( result ) return reverse ? FALSE : result;
        }

        return reverse ? TRUE : FALSE;
      }

      static int matchBackRef( struct RE *rexp ){
        int backRefId    = atoi( rexp->ptr + 1 );
        int backRefIndex = lastIdCatch( backRefId );
        if( gpsCatch( backRefIndex ) == 0 ||
            strncmp( text.ptr + text.pos, gpsCatch( backRefIndex ), lenCatch( backRefIndex ) ) != 0 )
          return FALSE;
        else return lenCatch( backRefIndex );
      }

      static void openCatch( int *index ){
        if( Catch.index < MAX_CATCHS ){
          *index = Catch.index++;
          Catch.ptr[ *index ] = text.ptr + text.pos;
          Catch.id [ *index ] = Catch.idx++;
        }
      }

      static void closeCatch( int index ){
        if( index < MAX_CATCHS )
          Catch.len[ index ] = &text.ptr[ text.pos ] - Catch.ptr[ index ];
      }

      static int lastIdCatch( int id ){
        int lastId = MAX_CATCHS;
        for( int index = 1; index < Catch.index; index++ )
          if( Catch.id[ index ] == id ) lastId = index;

        return lastId;
      }

      int totalCatch(){ return Catch.index - 1; }

      char * gpsCatch( int index ){
        return ( index > 0 && index < Catch.index ) ? Catch.ptr[ index ] : 0;
      }

      int lenCatch( int index ){
        return ( index > 0 && index < Catch.index ) ? Catch.len[ index ] : 0;
      }

      char * cpyCatch( char * str, int index ){
        if( index > 0 && index < Catch.index ){
          strncpy( str, Catch.ptr[ index ], Catch.len[ index ] );
          str[ Catch.len[ index ] ] = '\0';
        } else *str = '\0';

        return str;
      }

      char * rplCatch( char * newStr, char * rplStr, int id ){
        char *oNewStr = newStr, *text = Catch.ptr[ 0 ];
        strcpy( newStr, text );

        for( int index = 1; index < Catch.index; index++ )
          if( Catch.id[ index ] == id ){
            newStr += Catch.ptr[ index ] - text;
            strcpy( newStr, rplStr );
            newStr += strlen( rplStr );
            text    = Catch.ptr[ index ] + Catch.len[ index ];
            strcpy( newStr, text );
          }

        return oNewStr;
      }

      char * putCatch( char * newStr, char * putStr ){
        int  index; char *pos, *oNewStr = newStr;
        strcpy( newStr, putStr );

        while( (pos = strchr( putStr, '#' )) ){
          if( pos[ 1 ] == '#' ){
            newStr += pos + 1 - putStr;
            putStr  = pos + 2;
          } else {
            index   = atoi( pos + 1 );
            newStr += pos - putStr;
            cpyCatch( newStr, index );
            newStr += lenCatch( index );
            putStr  = pos + 1 + countCharDigits( pos + 1 );
          }

          strcpy( newStr, putStr );
        }

        return oNewStr;
      }
    < src..

*** Stand Alone Complex

    Que mejor tributo al libro C de k&r y al mismo lenguaje C podriamos hacer,
    si no es eliminar toda dependencia externa. A que me refiero con externa?
    Pues a eliminar de nuestra libreria todo el codigo fuera del nucleo duro de
    C, es decir, las llamadas a librerias estandar:

    ..src > c
      #include <ctype.h>
      #include <string.h>
      #include <stdlib.h>
    < src..

    Pero antes, separemos la implementacion de la libreria de su interfaz. El
    esfuerzo es minimo, cambiamos el nombre al fichero @f(regexp3.h) a
    @f(regexp3_ascii.c) y creamos una interfaz solo con lo necesario para el
    usuario en un nuevo fichero @c(regexp3.h):

    ..src > c
      #ifndef REGEXP3_H
      #define REGEXP3_H
      /*************************************************************************
       * <Recursive Regexp Raptor (regexp3) regexp library.>
       * https://github.com/nasciiboy/RecursiveRegexpRaptor
       * Copyright (C) <2016>  <nasciiboy>
       *
       * This program is free software: you can redistribute it and/or modify
       * it under the terms of the GNU General Public License as published by
       * the Free Software Foundation, either version 3 of the License, or
       * (at your option) any later version.
       *
       * This program is distributed in the hope that it will be useful,
       * but WITHOUT ANY WARRANTY; without even the implied warranty of
       * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
       * GNU General Public License for more details.
       *
       * You should have received a copy of the GNU General Public License
       * along with this program.  If not, see <http://www.gnu.org/licenses/>.
       ************************************************************************/

      int  regexp4( char *txt, char *re, int txtLen );

      int   totCatch();
      char *gpsCatch( int index );
      int   lenCatch( int index );
      char *cpyCatch( char *str, int index );
      char *rplCatch( char *newStr, char *rplStr, int id );
      char *putCatch( char *newStr, char *putStr );

      #endif
    < src..

    agregamos la referencia a la interfaz en @c(regexp3_ascii.c) con la
    directiva

    ..src > c
      #include "regexp3.h"
    < src..

    @f(test.c) dejara de tener acceso a @c(string.h), incluimos esta directiva
    en @f(test.c)

    ..src > c
      #include <string.h>
    < src..

    Y comprobamos que todo sigua funcionando. Ahora para compilar

    ..src > sh
      gcc -Wall test.c regexp3_ascii.c
    < src..

    ejecutamos

    ..src > c
      ./a.out
    < src..

    Una ves comprobamos que todo esta correcto (si no es asi al final de la
    seccion encontraras todo el codigo) procedemos a erradicar todo el codigo impuro.

    Utilizamos @c(<ctype.h>)

    para

    ..src > c
      isalpha();
      isdigit();
      isalnum();
      isspace();
    < src..

    @c(<string.h>)

    para

    ..src > c
      strlen();
      strchr();
      strcpy();
      strncpy();
      strncmp();
    < src..

    y @c(<stdlib.h>)

    para

    ..src > c
      atoi();
    < src..

    Vamos a agrupar las nuevas definiciones dentro del fichero @f(charUtils.h)
    junto a

    - @c(cmpChrCommunist)
    - @c(strnChrCommunist)
    - @c(strnCmpCommunist)
    - @c(countCharDigits)


    esta sera tu prueba final, has de afrontarlo solo. No habra mas
    explicacones, solo algunos consejos:

    La funcion de reemplazo puede tener un nombre similar al original, solo
    necesitas o agregar o convertir a mayuscula una letra, por ejemplo: para
    substituir a @c(strcpy) podrias utilizar @c(strCpy), @c(isdigit) por
    @c(isDigit), y asi sucesivamente.

    Substituye una funcion a la vez, comprobando que todo continua en
    funcionamiento. A medida que completes las funciones de un encabezado
    deshaste de el.

    En algunos casos la nueva fucion no necesita cumplir todos los casos del
    original. por ejemplo @c(atoi) es capaz de indentificar un entero con valor
    negativo, nuestra implementacion no necesita dicha capacidad.

    Segun cada situacion podrias @"(mejorar) el retorno de algunas funciones o
    ajustarlas a la necesidad del motor.

    Suerte! Esto es todo, para esta implementacion (aun falta dar soporte a
    caracteres con codificacion utf-8 y optimizar la forma de recorrer la
    cadena)

    Acontinuacion dejo el codigo definitiva de @e(regexp3) (version ascii)

    esta seria @f(regexp3_ascii.c)

    ..src > c
      #include "regexp3.h"
      #include "charUtils.h"

      #define TRUE                 1
      #define FALSE                0
      #define MAX_CATCHS          16
      #define INF         1073741824 // 2^30

      #define MOD_ALPHA            1
      #define MOD_OMEGA            2
      #define MOD_LONLEY           4
      #define MOD_FwrByChar        8
      #define MOD_COMMUNISM       16

      struct CATch {
        char *ptr[ MAX_CATCHS ];
        int   len[ MAX_CATCHS ];
        int   id [ MAX_CATCHS ];
        int   idx;
        int   index;
      } static Catch;

      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      } static text;

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char          *ptr;
        int            len;
        enum     TYPE  type;
        unsigned char  mods;
        unsigned int   loopsMin, loopsMax;
      };

      static int  walker    ( struct RE  rexp );
      static int  trekking  ( struct RE *rexp );
      static int  looper    ( struct RE *rexp );
      static int  tracker   ( struct RE *rexp, struct RE *track );
      static int  cutTrack  ( struct RE *rexp, struct RE *track, int type );

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type );
      static void getMods   ( struct RE *rexp, struct RE *track );
      static void getLoops  ( struct RE *rexp, struct RE *track );
      static void fwrTrack  ( struct RE *track, int len );

      static int  walkMeta       ( char *str );
      static int  walkSet        ( char *str );
      static int  countCharDigits( char *str );
      static char *trackerPoint  ( char *points, char *track, int len );

      static int  match       ( struct RE *rexp );
      static int  matchSet    ( struct RE  rexp );
      static int  matchBackRef( struct RE *rexp );
      static int  matchRange  ( struct RE *rexp, int   chr );
      static int  matchMeta   ( struct RE *rexp, int   chr );
      static int  matchText   ( struct RE *rexp, char *txt );

      static void openCatch    ( int *index );
      static void closeCatch   ( int  index );
      static int  lastIdCatch  ( int  id    );

      int regexp3( char *txt, char *re ){
        struct RE    rexp;
        int result   = 0;
        text.len     = strLen( txt );
        Catch.ptr[0] = txt;
        Catch.len[0] = text.len;
        Catch.id [0] = 0;
        Catch.index  = 1;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strLen( re );
        rexp.mods    = 0;

        if( text.len == 0 || rexp.len == 0 ) return 0;

        getMods( &rexp, &rexp );

        for( int forward, i = 0, loops = rexp.mods & MOD_ALPHA ? 1 : text.len; i < loops; i += forward ){
          forward    = 1;
          Catch.idx  = 1;
          text.pos   = 0;
          text.ptr   = txt   + i;
          text.len   = Catch.len[0] - i;

          if( walker( rexp ) ){
            if     (  rexp.mods & MOD_OMEGA    ){ if( text.pos == text.len ) return TRUE; }
            else if(  rexp.mods & MOD_LONLEY   )                             return TRUE;
            else if( (rexp.mods & MOD_FwrByChar) || text.pos == 0 )          result++;
            else   {  forward = text.pos;                                    result++; }
          }
        }

        return result;
      }

      static int walker( struct RE rexp ){
        struct RE track;
        for( const int oCindex = Catch.index, oCidx = Catch.idx, oTpos = text.pos;
             cutTrack( &rexp, &track, PATH );
             Catch.index = oCindex, Catch.idx = oCidx, text.pos = oTpos )
          if( track.len && trekking( &track ) ) return TRUE;

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;
        while( tracker( rexp, &track ) )
          if( track.len == 0 || looper( &track ) == FALSE ) return FALSE;

        return TRUE;
      }

      static int looper( struct RE *rexp ){
        int iCatch, steps, loops = 0;

        switch( rexp->type ){
        case HOOK:
          openCatch( &iCatch );
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          if( loops >= rexp->loopsMin ) closeCatch( iCatch );
          break;
        case GROUP: case PATH:
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:
          while( loops < rexp->loopsMax && text.pos < text.len && (steps = match( rexp )) ){
            text.pos += steps;
            loops++;
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;
      }

      static int cutTrack( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track      = *rexp;
        track->type = type;
        if( type != PATH ) fwrTrack( track, 1 );

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          i += walkMeta( rexp->ptr + i );

          switch( rexp->ptr[i] ){
          case '<': case '(': deep++; break;
          case '>': case ')': deep--; break;
          case '[': i += walkSet( rexp->ptr + i ); break;
          }

          switch( type ){
          case HOOK : cut = deep == 0; break;
          case GROUP: cut = deep == 0; break;
          case SET  : cut =              rexp->ptr[i] == ']'; break;
          case PATH : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = &rexp->ptr[i] - track->ptr;
            fwrTrack( rexp, i + 1 );
            return TRUE;
          }
        }

        fwrTrack( rexp, rexp->len );
        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        char *point;

        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case ':': trackByLen( rexp, track, 2, META    ); break;
        case '.': trackByLen( rexp, track, 1, POINT   ); break;
        case '@': trackByLen( rexp, track, 1 +
                              countCharDigits( rexp->ptr + 1 ),
                                              BACKREF ); break;
        case '(': cutTrack  ( rexp, track,    GROUP   ); break;
        case '<': cutTrack  ( rexp, track,    HOOK    ); break;
        case '[': cutTrack  ( rexp, track,    SET     ); break;
        default :
          if( (point = trackerPoint( "(<[@:.?+*{-#", rexp->ptr + 1, rexp->len - 1 )) ){
            switch( *point ){
            case '(': case '<': case '[': case '@': case ':': case '.':
              trackByLen( rexp, track, point - rexp->ptr, SIMPLE  ); break;
            case '?': case '+': case '*': case '{': case '-': case '#':
              if( point - rexp->ptr == 1 ){
                if( *point == '-' ) trackByLen( rexp, track, 3, RANGEAB );
                else                trackByLen( rexp, track, 1, SIMPLE  );
              } else trackByLen( rexp, track, (point - rexp->ptr) - 1, SIMPLE  );
            }
          } else trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

        getLoops( rexp, track );
        getMods ( rexp, track );
        return TRUE;
      }

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
        *track       = *rexp;
        track->type  = type;
        track->len   = len;
        fwrTrack( rexp, len );
      }

      static void fwrTrack( struct RE *track, int len ){
        track->ptr += len; track->len -= len;
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strChr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }

      static int walkSet( char *str ){
        int i = 0;
        while( TRUE )
          switch( str[ i ] ){
          case ']': return i;
          case ':': i += walkMeta( str + i ); break;
          default : i++   ; break;
          }
      }

      static int walkMeta( char *str ){
        for( int i = 0; ; i += 2 )
          if( str[i] != ':' ) return i;
      }

      static void getMods( struct RE *rexp, struct RE *track ){
        int inMods = *rexp->ptr == '#', pos = 0;

        while( inMods )
          switch( rexp->ptr[ ++pos ] ){
          case '^': track->mods |=  MOD_ALPHA     ; break;
          case '$': track->mods |=  MOD_OMEGA     ; break;
          case '?': track->mods |=  MOD_LONLEY    ; break;
          case '~': track->mods |=  MOD_FwrByChar ; break;
          case '*': track->mods |=  MOD_COMMUNISM ; break;
          case '/': track->mods &= ~MOD_COMMUNISM ; break;
          default : inMods       =  FALSE         ; break;
          }

        fwrTrack( rexp, pos );
      }

      static void getLoops( struct RE *rexp, struct RE *track ){
        track->loopsMin = 1; track->loopsMax = 1;
        int len = 0;

        if( rexp->len )
          switch( *rexp->ptr ){
          case '?' : len = 1; track->loopsMin = 0; track->loopsMax =   1; break;
          case '+' : len = 1; track->loopsMin = 1; track->loopsMax = INF; break;
          case '*' : len = 1; track->loopsMin = 0; track->loopsMax = INF; break;
          case '{' :
            track->loopsMin = aToi( rexp->ptr + 1 ) ;
            if( rexp->ptr[ 1 + countCharDigits( rexp->ptr + 1 ) ] == ',' )
              track->loopsMax = aToi( strChr( rexp->ptr, ',' ) + 1 );
            else
              track->loopsMax = track->loopsMin;

            len = strChr( rexp->ptr, '}' ) - rexp->ptr + 1;
          }

        fwrTrack( rexp, len );
      }

      static int match( struct RE *rexp ){
        switch( rexp->type ){
        case POINT  : return text.pos < text.len;
        case SET    : return matchSet    ( *rexp );
        case BACKREF: return matchBackRef(  rexp );
        case RANGEAB: return matchRange( rexp, text.ptr[text.pos]  );
        case META   : return matchMeta ( rexp, text.ptr[text.pos]  );
        default     : return matchText ( rexp, text.ptr + text.pos );
        }
      }

      static int matchText( struct RE *rexp, char *txt ){
        if( rexp->mods & MOD_COMMUNISM )
          return    strnEqlCommunist( txt, rexp->ptr, rexp->len ) ? rexp->len : 0;
        else return strnEql         ( txt, rexp->ptr, rexp->len ) ? rexp->len : 0;
      }

      static int matchRange( struct RE *rexp, int chr ){
        if( rexp->mods & MOD_COMMUNISM ){
          chr = toLower( chr );
          return chr >= toLower( rexp->ptr[ 0 ] ) && chr <= toLower( rexp->ptr[ 2 ] );
        } else
          return chr >=          rexp->ptr[ 0 ]   && chr <=          rexp->ptr[ 2 ];
      }

      static int matchMeta( struct RE *rexp, int chr ){
        switch( rexp->ptr[1] ){
        case 'a' : return  isAlpha( chr );
        case 'A' : return !isAlpha( chr );
        case 'd' : return  isDigit( chr );
        case 'D' : return !isDigit( chr );
        case 'w' : return  isAlnum( chr );
        case 'W' : return !isAlnum( chr );
        case 's' : return  isSpace( chr );
        case 'S' : return !isSpace( chr );
        default  : return rexp->ptr[1] == chr;
        }
      }

      static int matchSet( struct RE rexp ){
        struct RE track;
        int result  = 0, reverse = *rexp.ptr == '^';

        if( reverse ) fwrTrack( &rexp, 1 );

        while( tracker( &rexp, &track ) ){
          switch( track.type ){
          case RANGEAB: case META: case POINT:
            result = match( &track ); break;
          default:
            if( track.mods & MOD_COMMUNISM )
                 result = strnChrCommunist( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
            else result = strnChr         ( track.ptr, text.ptr[ text.pos ], track.len  ) != 0;
          }

          if( result ) return reverse ? FALSE : result;
        }

        return reverse ? TRUE : FALSE;
      }

      static int matchBackRef( struct RE *rexp ){
        int backRefId    = aToi( rexp->ptr + 1 );
        int backRefIndex = lastIdCatch( backRefId );
        if( gpsCatch( backRefIndex ) == 0 ||
            strnEql( text.ptr + text.pos, gpsCatch( backRefIndex ), lenCatch( backRefIndex ) ) == FALSE )
          return FALSE;
        else return lenCatch( backRefIndex );
      }

      static int lastIdCatch( int id ){
        for( int index = Catch.index - 1; index > 0; index-- )
          if( Catch.id[ index ] == id ) return index;

        return MAX_CATCHS;
      }

      static void openCatch( int *index ){
        if( Catch.index < MAX_CATCHS ){
          *index = Catch.index++;
          Catch.ptr[ *index ] = text.ptr + text.pos;
          Catch.id [ *index ] = Catch.idx++;
        } else *index = MAX_CATCHS;
      }

      static void closeCatch( int index ){
        if( index < MAX_CATCHS )
          Catch.len[ index ] = &text.ptr[ text.pos ] - Catch.ptr[ index ];
      }

      int totCatch(){ return Catch.index - 1; }

      char * gpsCatch( int index ){
        return ( index > 0 && index < Catch.index ) ? Catch.ptr[ index ] : 0;
      }

      int lenCatch( int index ){
        return ( index > 0 && index < Catch.index ) ? Catch.len[ index ] : 0;
      }

      char * cpyCatch( char * str, int index ){
        if( index > 0 && index < Catch.index )
          strnCpy( str, Catch.ptr[ index ], Catch.len[ index ] );
        else *str = '\0';

        return str;
      }

      char * rplCatch( char * newStr, char * rplStr, int id ){
        char *oNewStr = newStr, *text = Catch.ptr[ 0 ];
        strCpy( newStr, text );

        for( int index = 1; index < Catch.index; index++ )
          if( Catch.id[ index ] == id ){
            newStr += Catch.ptr[ index ] - text;
            strCpy( newStr, rplStr );
            newStr += strLen( rplStr );
            text    = Catch.ptr[ index ] + Catch.len[ index ];
            strCpy( newStr, text );
          }

        return oNewStr;
      }

      char * putCatch( char * newStr, char * putStr ){
        int  index; char *pos, *oNewStr = newStr;
        strCpy( newStr, putStr );

        while( (pos = strChr( putStr, '#' )) ){
          if( pos[ 1 ] == '#' ){
            newStr += pos + 1 - putStr;
            putStr  = pos + 2;
          } else {
            index   = aToi( pos + 1 );
            newStr += pos - putStr;
            cpyCatch( newStr, index );
            newStr += lenCatch( index );
            putStr  = pos + 1 + countCharDigits( pos + 1 );
          }

          strCpy( newStr, putStr );
        }

        return oNewStr;
      }
    < src..

    y esto @f(charUtils.h)

    ..src > c
      #ifndef CHARUTILS_H
      #define CHARUTILS_H

      static int isDigit( int c ){ return c >= '0' && c <= '9'; }
      static int isUpper( int c ){ return c >= 'a' && c <= 'z'; }
      static int isLower( int c ){ return c >= 'A' && c <= 'Z'; }
      static int isAlpha( int c ){ return isLower( c ) || isUpper( c ); }
      static int isAlnum( int c ){ return isAlpha( c ) || isDigit( c ); }
      static int isSpace( int c ){ return c == ' ' || (c >= '\t' && c <= '\r'); }
      static int toLower( int c ){ return isLower( c ) ? c + 32 : c; }

      static int strLen( char *str ){
        for( char *i = str; ; i++ )
          if( *i == 0 ) return i - str;
      }

      static void strCpy( char *dest, char *src ){
       while( (*dest++ = *src++) );
      }

      static void strnCpy( char *dest, char *src, int n ){
        while( n > 0 && (*dest++ = *src++) ) n--;

        *dest = '\0';
      }

      static char * strChr( char *str, int chr ){
        while( *str && *str != chr ) str++;

        return *str ? str : 0;
      }

      static char * strnChr( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( str[ i ] == chr ) return str + i;

        return 0;
      }

      static int strnEql( char *s, char *t, int n ){
        for( ; *s == *t; s++, t++ )
          if( *s == '\0' || --n <= 0 ) return 1;

        return 0;
      }

      static int cmpChrCommunist( char a, char b){
        a = toLower(a);
        b = toLower(b);
        return a == b;
      }

      static char * strnChrCommunist( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( cmpChrCommunist( str[i], chr ) ) return str + i;

        return 0;
      }

      static int strnEqlCommunist( char *s, char *t, int n ){
        for( ; cmpChrCommunist( *s, *t ); s++, t++ )
          if( *s == '\0' || --n <= 0 ) return 1;

        return 0;
      }

      static int aToi( char *str ){
        int uNumber = 0;
        while( isDigit( *str ) )
          uNumber = 10 * uNumber + ( *str++ - '0' );

        return uNumber;
      }

      static int countCharDigits( char *str ){
        for( int digits = 0; ; digits++ )
          if( isDigit( *str++ ) == 0 ) return digits;
      }

      #endif
    < src..

    todo en una misma carpeta junto con la interfaz @f(regexp3.h) y las pruebas
    @f(test.c).

* Regexp3 (UTF-8)

  Esta seccion amplia la libreria, para ofrecer soporte basico a caracteres
  unicode con codificacion utf-8, ademas se incorpora el
  modificador @e(final imaginario).

** utf-8
** codigo
** xx.*yy
* regexp4

  Houston, tenemos un problema...

  regexp3 tiene poco mas de 500 lineas de codigo en C puro. El resto de
  implementaciones en C y C++, parten de las 6000 lineas de codigo, sin incluir
  todas las librerias de las que dependen. Sin duda alguna el raptor dejara en
  ridiculo los 60 años previos de desarrollo en en area y a los cientos de
  ingenieros involucrados, no?

  Un buen sujeto que se hace llamar @b(dark100) creo un entorno que mide el
  rendimiento de varios motores regexp (puede encantrarse
  @l(http://sljit.sourceforge.net/regex_perf.html<>aqui)).

  Me tome la libertad (tras algunas modificaciones) de incluir al Raptor
  (regexp3 vercion ascii) en la prueba.

  Puedes encontrar el codigo en
  @l(https://github.com/nasciiboy/RecursiveRegexpRaptor-vs-Benchmarks), solo
  descarga una copia (@l(https://github.com/nasciiboy/RecursiveRegexpRaptor-vs-Benchmarks/archive/master.zip<>aqui)) o clona el repositorio con

  ..src > sh
    git clone https://github.com/nasciiboy/RecursiveRegexpRaptor-vs-Benchmarks.git
  < src..

  Para compilar basta un @$(make) y luego un @$(./runtest)

  Las librerias en competicion son:

  - @l(http://www.pcre.org/<>PCRE2 10.10)
  - @l(https://github.com/laurikari/tre/<>tre 0.8.0)
  - @l(http://www.geocities.jp/kosako3/oniguruma/<>Oniguruma 5.9.6)
  - @l(https://github.com/google/re/<>re2 by Google)
  - @l(http://sljit.sourceforge.net/pcre.htm/<>PCRE2 10.10 with sljit JIT compiler support)


  El numero de coincidencias se encuentra entre parentesis. El ultimo campo de
  la tabla corresponde a la exprecion, el primer lugar la syntaxis estandar
  basada den perl y despues la syntaxis personalizada de regexp3

  ..sec > x86-64 bit Intel Cerelon 847 1.1GHz (GCC 6.2.1, Linux)

    | PCRE       | PCRE-DFA   | TRE        | Onig-uruma | RE2        | PCRE-JIT   | regexp3    | Regular expression                                            |
    |============+============+============+============+============+============+============+===============================================================|
    | 4364 ms    | 5152 ms    | 6641 ms    | 2202 ms    | 7566 ms    | 1086 ms    | 1756 ms    | .∣\n                                                          |
    | (20045118) | (20045118) | (20045118) | (20045118) | (20045118) | (20045118) | (20045118) +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | .                                                             |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 2837 ms    | 4292 ms    | 4693 ms    | 2243 ms    | 5748 ms    | 946 ms     | 1849 ms    | \w                                                            |
    | (14751878) | (14751878) | (14751878) | (14751878) | (14751878) | (14751878) | (14750958) +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | :w                                                            |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 67 ms      | 69 ms      | 1058 ms    | 116 ms     | 235 ms     | 58 ms      | 1755 ms    | \d                                                            |
    | (27084)    | (27084)    | (27084)    | (27084)    | (27084)    | (27084)    | (27084)    +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | :d                                                            |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 2992 ms    | 3280 ms    | 4634 ms    | 1851 ms    | 6016 ms    | 895 ms     | 1869 ms    | \S                                                            |
    | (15451664) | (15451664) | (15451664) | (15451664) | (15451664) | (15451664) | (15451664) +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | :S                                                            |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 896 ms     | 1089 ms    | 1897 ms    | 762 ms     | 1774 ms    | 388 ms     | 4583 ms    | [.\s]+                                                        |
    | (3430783)  | (3430783)  | (991813)   | (3430783)  | (3430783)  | (3430783)  | (3430783)  +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | [:.:s]+                                                       |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 173 ms     | 238 ms     | 1407 ms    | 222 ms     | 430 ms     | 46 ms      | 4174 ms    | [\n.]+                                                        |
    | (438367)   | (438367)   | (438367)   | (438367)   | (438367)   | (438367)   | (438367)   +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | [\n:.]+                                                       |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 365 ms     | 451 ms     | 498 ms     | 405 ms     | 747 ms     | 136 ms     | 1721 ms    | e                                                             |
    | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | e                                                             |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 1234 ms    | 1187 ms    | 496 ms     | 878 ms     | 749 ms     | 203 ms     | 26751 ms   | (((((e)))))                                                   |
    | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | <<<<<e>>>>>                                                   |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 1908 ms    | 1908 ms    | 497 ms     | 1162 ms    | 765 ms     | 321 ms     | 84651 ms   | ((((((((((e))))))))))                                         |
    | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  | (1781425)  +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | <<<<<<<<<<e>>>>>>>>>>                                         |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 11 ms      | 50 ms      | 1021 ms    | 53 ms      | 8 ms       | 51 ms      | 4714 ms    | Twain                                                         |
    | (2388)     | (2388)     | (2388)     | (2388)     | (2388)     | (2388)     | (2388)     +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | Twain                                                         |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 14 ms      | 50 ms      | 1010 ms    | 53 ms      | 8 ms       | 51 ms      | 9531 ms    | (Twain)                                                       |
    | (2388)     | (2388)     | (2388)     | (2388)     | (2388)     | (2388)     | (2388)     +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | <Twain>                                                       |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 198 ms     | 294 ms     | 1311 ms    | 399 ms     | 261 ms     | 53 ms      | 4792 ms    | (?i)Twain                                                     |
    | (2657)     | (2657)     | (2657)     | (2657)     | (2657)     | (2657)     | (2657)     +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | #*Twain                                                       |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 615 ms     | 534 ms     | 1913 ms    | 348 ms     | 260 ms     | 67 ms      | 25165 ms   | ((T∣t)(w∣W)(a∣A)i([a-z]∣1))                                   |
    | (2427)     | (2427)     | (2427)     | (2427)     | (2427)     | (2427)     | (2427)     +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | <<T∣t><w∣W><a∣A>i<[a-z]∣1>>                                   |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 1434 ms    | 2351 ms    | 1581 ms    | 50 ms      | 350 ms     | 49 ms      | 7466 ms    | [a-z]shing                                                    |
    | (1877)     | (1877)     | (1877)     | (1877)     | (1877)     | (1877)     | (1877)     +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | [a-z]shing                                                    |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 73 ms      | 78 ms      | 1598 ms    | 121 ms     | 225 ms     | 9 ms       | 9074 ms    | Huck[a-zA-Z]+∣Saw[a-zA-Z]+                                    |
    | (396)      | (396)      | (396)      | (396)      | (396)      | (396)      | (396)      +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | Huck[a-zA-Z]+∣Saw[a-zA-Z]+                                    |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 1748 ms    | 6371 ms    | 4376 ms    | 154 ms     | 10241 ms   | 5 ms       | 15469 ms   | [a-q][^u-z]{13}x                                              |
    | (4929)     | (4929)     | (4929)     | (4929)     | (4929)     | (4929)     | (4929)     +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | [a-q][^u-z]{13}x                                              |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 97 ms      | 104 ms     | 2764 ms    | 140 ms     | 229 ms     | 85 ms      | 22447 ms   | Tom∣Sawyer∣Huckleberry∣Finn                                   |
    | (3015)     | (3015)     | (3015)     | (3015)     | (3015)     | (3015)     | (3015)     +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | Tom∣Sawyer∣Huckleberry∣Finn                                   |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 101 ms     | 107 ms     | 2789 ms    | 142 ms     | 229 ms     | 83 ms      | 38332 ms   | (Tom∣Sawyer∣Huckleberry∣Finn)                                 |
    | (3015)     | (3015)     | (3015)     | (3015)     | (3015)     | (3015)     | (3015)     +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | <Tom∣Sawyer∣Huckleberry∣Finn>                                 |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 612 ms     | 902 ms     | 3178 ms    | 660 ms     | 326 ms     | 244 ms     | 17300 ms   | [hHeELlLlOo][hHeELlLlOo][hHeELlLlOo][hHeELlLlOo][hHeELlLlOo]  |
    | (534)      | (534)      | (534)      | (534)      | (534)      | (534)      | (534)      +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | [hHeELlLlOo][hHeELlLlOo][hHeELlLlOo][hHeELlLlOo][hHeELlLlOo]  |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 205 ms     | 260 ms     | 1773 ms    | 229 ms     | 309 ms     | 46 ms      | 13979 ms   | Tom.{10,25}river∣river.{10,25}Tom                             |
    | (2)        | (2)        | (2)        | (2)        | (2)        | (2)        | (2)        +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | <Tom([^(river∣\n)]){10,25}river∣river([^(Tom∣\n)]){10,25}Tom> |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 135 ms     | 250 ms     | 1119 ms    | 92 ms      | 101 ms     | 54 ms      | 4067 ms    | ing[^a-zA-Z]                                                  |
    | (85956)    | (85956)    | (85956)    | (85956)    | (85956)    | (85956)    | (85956)    +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | ing[^a-zA-Z]                                                  |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 1499 ms    | 2389 ms    | 1836 ms    | 95 ms      | 377 ms     | 58 ms      | 7917 ms    | [a-zA-Z]ing[^a-zA-Z]                                          |
    | (85823)    | (85823)    | (85823)    | (85823)    | (85823)    | (85823)    | (85823)    +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | [a-zA-Z]ing[^a-zA-Z]                                          |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 3954 ms    | 5586 ms    | 2081 ms    | 2377 ms    | 389 ms     | 231 ms     | 55897 ms   | ([a-zA-Z]+ing)                                                |
    | (95863)    | (95863)    | (95863)    | (95863)    | (95863)    | (95863)    | (95863)    +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | <([^(ing∣:A)])+ing(([^(ing∣:A)])*ing)*>                       |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|
    | 3052 ms    | 3676 ms    | 2925 ms    | 543 ms     | 343 ms     | 106 ms     | 27720 ms   | ([A-Za-z]awyer∣[A-Za-z]inn)\s                                 |
    | (313)      | (313)      | (313)      | (313)      | (313)      | (313)      | (313)      +---------------------------------------------------------------|
    |            |            |            |            |            |            |            | <[A-Za-z]awyer∣[A-Za-z]inn>:s                                 |
    |------------+------------+------------+------------+------------+------------+------------+---------------------------------------------------------------|


  (；一_一)!, antes de continuar necesito aclarar un par de puntos, a exepcion
  de regexp3 y tre, el resto de librerias utilazan programacion
  multihilo. Descartando nuestra libreria el resto necesita llamadas de
  inicializacion, comprobacion de errores y liberacion de recursos, el tiempo
  necesario para estos ritos no es parte del tiempo de busqueda.

  El primer dato que podemos extraer es que nuestra libreria realiza el mismo
  numero de capturas que el resto, dato que confirma su eficacia.

  La segunda conclucion @e(el tiempo) solo aplicable a regexp3 deja claro que
  segun el tiempo necesario depende de la complejidad de la exprecion, las
  expreciones donde se solicita la captura son considerablemete mas lentas que
  sus equivalentes sin captura o directamente sin agrupacion

  la prueba

  ..example >
    <<<<<<<<<<e>>>>>>>>>>
  < example..

  es en particular lamentable, regexp3 necesita mas de 84 segundos, tre que no
  es multihilo 0.497 segundos, el mejor tiempo por parte de PCRE-JIT es de 0.321
  segundos.

  Me estas diciendo que el resto de implementaciones utilizan determinacion y
  amor para ser asi de veloces, je, no, la diferencia radica en como evaluan la
  exprecion. En la mayoria de los casos un algoritmo recursivo es mas lento que
  un algoritmo iterativo, pero en caso del raptor la funte principal de lentitud
  corre a cargo del metodo en que se generan los constructores.

  Para resolvel la exprecion regexp3 optiene constructor a constructor (tipo,
  longitud, ciclos, mods) uno a uno, asta que el tipo del constructor puede
  buscarse en el texto. Este proceso se repite una y otra vez, @e(caracter a
  caracter).

  En cambio el resto de librerias, intes de iniciar la busqueda, genera un
  "mapa" de todos los constructores (con todas sus caracteristicas) y luego se
  dedica exclusivamente a compararlo con cada caracter.

  De forma generica el resto de librerias siguen el siguiente proceso

  1. Solicitar un contenedor para una exprecion

  2. Compilar la exprecion y colocarla en el contenedor

  3. Comprobar que el proceso de compilacion fue exitoso

  4. Buscar la exprecion compilada

  5. Analizar el resultado de la busqueda

  6. Liberar los recursos utilizados

** El raptor necesita un mapa
** Lista de instrucciones
** showTable
** interprete
** good by cruel regexp
* fuentes

  https://blog.staffannoteberg.com/2013/01/30/regular-expressions-a-brief-history/

  https://en.wikipedia.org/wiki/Regular_expression

  https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular

  https://es.wikipedia.org/wiki/Grep

  https://es.wikipedia.org/wiki/ASCII

  https://es.wikipedia.org/wiki/UTF-8

  https://es.wikipedia.org/wiki/Byte

  Mastering Regular Expressions, 2nd Edition By Jeffrey E. F. Friedl
  https://se.ifmo.ru/~ad/Documentation/Mastering_RegExp/mastregex2-CHP-4-SECT-3.html
