#+TITLE:  Recursive Regexp Raptor
#+AUTHOR:  nasciiboy
#+LANGUAGE:  es
#+DATE:
#+OPTIONS: *:nil  ^:nil f:nil num:nil html-postamble:nil html-style:nil html-scripts:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="worg-data/worg.css" />

#+BEGIN_QUOTE
  «La conciencia es el patron que se forma cuando apredemos a mirar hacia atras
  de nosotros mismos, incluso antes de nuestra propia existencia.»
#+END_QUOTE

* Introduccion

  Al igual que muchos de mis predecesores, quede fascinado por la utilidad de
  las expresiones regulares.

  Probablemente no hayas encontrado informacion sobre como construir un motor de
  expresiones regulares (ni sobre su funcionamiento) o la disponible se enfoque
  solamente en fundamentos matematicos, para los cuales el autor no muestra un
  metodo para transladarlos al mundo real (@e(codigo)).

  Has acudido al codigo de alguna implementacion en busca de conocimiento
  practico?  Y... encotraste codigo rebuscado y mistico repartido en infinidad
  de ficheros, llenos de macros, guiones bajos y variables cripticas.

  Pues bien, este libro va de construir un motor de expresiones regulares paso a
  paso, con mucho codigo y poca teoria. Nada de cerraduras de Kleene, NFA o
  DFA. Principalmente por que el autor no tiene ni idea de matematicas y su
  conocimiento se limita a un par de libros de programacion en lenguaje
  C/C++... ¯\_(ツ)_/¯

  El autor de este libro reconoce que este precedente no genera mucha
  expectativa, pero confia plenamente en la simplesa de su implementacion,
  fundamentada en cientos de horas frente a un par de monitores.

  Para afrontar la construccion de este particular motor de expreciones
  regulares escrito en lenguaje C, se asume que tienes conocimientos intermedios
  de programacion, particularmente con algun lenguaje basado en C y que dispones
  de las siguientes herramientas:

  - Un buen compilador de C (C99) (@e(GNU GCC) o @e(LLVM)).

  - @e(GNU Emacs) o algun simple "editor" de texto.

  - Un terminal con un interprete de comandos (como bash) o un entrorno que te
    permita enviar ordenes al compilador, ejecutar programas y ver su salida.

  - Buena musica! Programar sin musica no vale la pena!

** Sobre el libro... y otras cosas

   El libro se divide en cuatro secciones:

   - [[*RegExp]] expone una breve explicacion de lo que son las expresiones
     regulares y su sintaxis.

   - [[*Regexp3 (ASCII)]] muestra como imprementar un motor de expresiones regulares
     basado en el sistema de codificacion de caracteres @A(ASCII).

   - [[*Regexp3%20(UTF-8)][*Regexp3 (UTF-8)]] toma el codigo e ideas expuestas en [[*Regexp3 (ASCII)]]
     agregando algunas utilidades basicas para manejar la codificacion de
     caracteres @A(UTF-8)

   - Finalmente la seccion [[*Regexp4]] se centra en mejorar el desempeño del motor
     implementando una "tabla de instrucciones", se modifican elementos de la
     sintaxis y se agregan nuevas caracteristicas.

*** otras cosas

    Este libro asi como todo el codigo que en el aparece esta cubierto por
    licencias con derechos de izquierda (Copyleft).

    Para el libro se utiliza la licencia GNU FDL version 1.3.

    Para el codigo se utiliza la licencia GNU GPL version 3.

    El libro deberia estar acompañado por copias de ambas licencias, en caso
    contrario puede optener una copia desde
    [[https://www.gnu.org/licenses/fdl-1.3.html]] y
    [[https://www.gnu.org/licenses/gpl.html]]

    En esencia para el codigo fuente tienes:

    - la libertad para utilizar el software para cualquier proposito,
    - la libertad para modificar el software para que se adapte a tus necesidades,
    - la libertad para compartir el software con tus amigos y vecinos, y
    - la libertad para compartir los cambios que tu hagas.


    Estas libertades se aplican tambien al libro. Puedes copiar y redistribuir
    el trabajo, con o sin modificaciones y de forma comercial o no comercial.

    Todo aquel que obtenga una copia de este material tiene derecho a conservar
    las mismas condicines de uso, es decir, tanto el original como las versiones
    modificadas tendran la misma licencia.

    El codigo de este libro se encuentra alojado en
    [[https://github.com/nasciiboy/raptor-book]], bajo el sistema de control de
    versiones @$(git).

    Puedes clonar el repositorio con el comando:

    #+BEGIN_SRC sh
      git clone https://github.com/nasciiboy/raptor-book.git
    #+END_SRC

    Cualquir duda o contrubucion sera bien resivida en el correo electronico
    [[mailto:nasciiboy@gmail.com]].

    El codigo fuente del manual esta escrito con un lenguaje de marcas ligeras
    aun en desorrollo llamado morg. Tambien se ofrecen versiones en html (libre
    de javascrip) y en formato ebook (de momento generadas mediante org-mode).

*** Como leer el libro

    @e(Si, en este libro no hay ningun acento) (y probablemente tenga una
    terrible ortografia y/o redaccion). El autor considera que la mejor forma de
    leer cualquier documento es en formato de texto plano (dentro de @e(Emacs))
    pues permite entre otras cosas:

    - Preservar el material atraves de los tiempos

    - Facil difucion. No cuenta con ningun ridiculo sistema de "proteccion"

    - Adaptarlo a diversos formatos con el minimo esfuerzo

    - Realizar busquedas eficientes. Punto donde los acentos son un
      inconveniente

    - La interaccion directa con la interfaz humano-maquina mas eficiente, el
      teclado


    Respecto al codigo, en cada seccion se agregan funcionalidades de forma
    incremental y cada seccion depende de la anterior. Por lo general se
    presenta todo el codigo necesario al inicio del tema, para luego examinar
    los puntos relevantes.

    Dentro del codigo no se incluye ningun comentario que explique la finalidad
    de ninguna declaracion.

    Supuestamente cuando se escribe codigo con una estructura razonable, nombres
    descriptivos y que puede leerse de forma descendente, no es necesaria
    ninguna aclaracion. Obviamente, se presupone que el codigo aqui expuesto
    cumple estos requisitos...

    Actualmente la libreria sigue en desarrollo en dos repositorios

    [[https://github.com/nasciiboy/RecursiveRegexpRaptor]] alias Regexp3. El punto
    de partida de la libreria. Es interesante ver los cambios entre cada version
    en particular el codigo inicial.

    Para optener una copia del repositorio

    #+BEGIN_SRC sh
      git clone https://github.com/nasciiboy/RecursiveRegexpRaptor.git
    #+END_SRC

    [[https://github.com/nasciiboy/RecursiveRegexpRaptor-4]] alias Regexp4. En su
    base contiene a Regexp3, con la diferencia de ser mas eficiente respecto al
    consumo de CPU.

    Para optener una copia del repositorio

    #+BEGIN_SRC sh
      git clone https://github.com/nasciiboy/RecursiveRegexpRaptor-4.git
    #+END_SRC

    Al momento de escribir estas lineas, el codigo de este libro y el del
    repositorio difieren de forma evidente. En la practica, cada modificacion
    por minuscula que sea, obliga a revisar todo el codigo del libro, ajustar
    explicaciones y realizar nuevas pruebas. Ya que el motor cumple su mision
    perfectamente y el codigo es coherente con sigo mismo, la construccion de
    @e(regexp3) cubre hasta el commit
    @c(e6f7c7f5ee916fb25a4b6931e6fb4fb6b142188a).

    Como programadores, nuestro codigo refleja el nivel de conocimiento,
    experiencia, creencias, manias, dedicacion y otros tantos aspectos
    inherentes al aleatorio recorrido que transitamos. Aun no considero que el
    motor este concluido, pese a esto, es mi mayor orgullo como programador,
    espero que sea de utilidad y puedas aprender algun nuevo truco.

    Al terminar este manual, tendras un motor regexp tan potente como para
    implementar un editor de flujos similar a @$(sed), aun asi, date una vuelta
    por el repositorio para ver si he mejorado el codigo o despues de revisar
    por enesima ocacion alguna funcion he perdido el rumbo.

    Si te consideras intrepido, pasa de esto y ve directamente al repo!

    Happy Hacking!

* RegExp

  Una Expresion regular es una secuencia de caracteres que define un patron de
  busqueda. Son mejor conocidas por las contracciones @e(RegExp), @e(RegEx) y
  @e(RE) del original @q(Regular Expressions) en ingles. La aplicacion principal
  de las @e(RegExp) es localizar patrones para filtrar informacion, validar
  datos y manipular texto.

  Se originaron en 1956, cuando el matematico @e(Stephen Kleene) describio los
  @e(lenguajes regulares) utilizando su propia notacion matematica llamada
  @e(conjuntos regulares).

  En 1968, @e(Ken Thompson) pionero de Unix publico el articulo @q(Regular
  Expression Search Algorith) que contenia la descripcion tecnica de un
  compilador de expresiones regulares junto con codigo en Algol-60, mas tarde,
  implementaria por vez primera en un programa informatico el uso de expresiones
  regulares con la notacion de Kleene, especificamente en el editor de texto
  @$(QED). El objetivo era que el usuario pudiese hacer comparacion de patrones
  avanzados en archivos de texto. En 1969 esta capacidad fue incorporada al
  editor @$(ed) (creacion de Thompson), en forma del comando @c(g/re/p) que
  proviene de «globally/regular expresion/print» y significa «@e(g)lobally
  search a @e(r)egular @e(e)xpression and @e(p)rint» (has una busqueda global
  para las lineas que coincidan con la expresion regular e imprimelas).

  El comando @c(g/re/p) dio como resultado el programa independiente @$(grep)
  (tambien obra de Thompson), lanzado en la cuarta edicion de Unix en 1973. Sin
  embargo, grep no tenia una implementacion completa de expresiones regulares,
  no fue hasta el año 1979, en la septima edicion de Unix que el programa
  @$(egrep) (extended grep) (creacion de @e(Alfred Aho)) logro traducir cualquier expresion
  regular a su correspondiente algoritmo DFA.

  Alrededor de la misma epoca en la que Thompson desarrollo @$(QED), un grupo de
  investigadores, puso en marcha una herramienta basada en Expresiones
  Regulares, en esta ocacion su funcion fue el analisis lexico en el diseño de
  compiladores.

  En la decada de los 70's muchas variaciones de las regexp implementadas en
  Unix se incorporaron a programas como @$(vi), @$(lex), @$(sed), @$(awk),
  @$(expr), @$(emacs), etc.

  En la decada de los 80's, las expresiones regulares mas complejas aparecieron
  en el lerguaje de programacio @e(Perl), derivadas de la biblioteca @e(regexp)
  de @e(Henry Spencer) (1986).

  Inevitablemente la Jihad RegExp se extendio a la mayoria de lenguajes de
  programacion, shell's, bases de datos, servidores web, editores de texto,
  navegadores de ficheros y un variado numero de programas en forma de pequeñas
  utilidades.

** Sintaxis RegExp

   Las RegExp estan formadas por una serie de constructores que pueden
   convinarse libremente entre si. Como no podria ser de otra forma los
   constructores no son mas que una serie de caracteres (numeros, letras o
   signos de puntuacion) a los que se atribuye un comportaminto especifico.

   La sintaxis de los constructores puede variar de un motor/programa/lenguaje a
   otro, sin embargo por lo general se siguen las siguientes convenciones:

*** Caracter

    Se consideran caracteres todos los numeros, letras o signos de puntuacion
    cuyo unico significado es la coincidencia con el propio caracter.

    Dentro del motor su evaluacion es secuencial. Es decir, un patron compuesto
    unicamente por caracteres solo puede coincidir si cada uno de sus elementos
    esta precente en el texto de busqueda, de forma secuencial. En terminos
    simples esto significa que cualquier palabra esta conformada por sus
    constructores @e(caracter)

    #+BEGIN_SRC c
      "palabra" ==  'p', 'a', 'l', 'a', 'b', 'r', 'a'
    #+END_SRC

    De forma explicita el patron de busqueda @c(palabra) dice al motor lo
    siguiente: Busca el constructor de tipo caracter @c(p), si lo encuentras
    avanza una posicion dentro del texto de busqueda y comparalo con el
    constructor de tipo caracater @c(a), si lo encuentras avanza una posicion
    dentro del texto de busqueda y compararlo con el constructor de tipo
    caracter @c(l), ..., si llegas hasta el ultimo constructor tipo caracter
    (ultima @c(a)) el patron a sido localizado, de otra forma no hay
    coincidencia.

*** Conjunto

    El constructor @e(Conjunto) permite agrupar una serie de constructores
    caracter para compararlos con una posicion especifica del texto de busqueda.

    Los constructores se delimitan dentro de los signos "especiales" '[' y ']'.

    La expresion:

    #+BEGIN_SRC c
      "199[56789]"
    #+END_SRC

    le indica lo siguiente al motor: Busca el constructor de tipo caracter
    @c(1), si lo encuentras avanza una posicion dentro del texto de busqueda y
    comparalo con el constructor que de tipo caracter @c(9), si lo encuentras
    avanza una posicion dentro del texto de busqueda y compararlo con el
    constructor de tipo caracter @c(9), si lo encuentras avanza una posicion
    dentro del texto de busqueda y comparalo con alguno de estos constructores
    de tipo caracter @c(5), @c(6), @c(7), @c(8) o @c(9), Si el caracter del
    texto  coincide con alguno  de estos caracteres se ha encontrado el patron,
    de otro modo la busqueda ha fallado.

    Es decir el patron @c(199[56789]) coincide con las siguientes cadenas de
    caracteres: @c("1995"), @c("1996"), @c("1997"), @c("1998") o @c("1999")

*** Rangos

    Un conjunto agrupa una serie de constructores caracter, pues bien, cuando
    los miembros dichos del conjunto forman una secuencia alfabetica entre @c(a)
    y @c(z), entre @c(A) y @c(Z)) o entre @c(0) y @c(9), es posible abreviar
    dicha secuencia, uniendo el elemento inicial con el elemento final de la
    secuencia mediante el signo '-', por ejemplo la exprecion

    #+BEGIN_SRC c
      "199[56789]"
    #+END_SRC

    es equivalente a la exprecion:

    #+BEGIN_SRC c
      "199[5-9]"
    #+END_SRC

    la exprecion

    #+BEGIN_SRC c
      "Unidad-[ABCDEFGHIJK]"
    #+END_SRC

    es equivalente a

    #+BEGIN_SRC c
      "Unidad-[A-K]"
    #+END_SRC

    el signo @c(-) no tiene efecto fuera del constructor agrupacion, por lo que
    se interpreta como un simple caracter @c(-)

*** Conjunto inverso

    La utlima facilidad que proporciona el constructor conjunto consiste en
    coincidir solo si ninguno de sus elementos esta precente en el texto de
    busqueda, es decir @e(invierte) el resultado de la busqueda. La forma de
    indicar al motor este comportamiento es colocar el signo @c(^) como primer
    elemento del constructor conjunto. Por ejemplo la expresion

    #+BEGIN_SRC c
      "<[^>]>"
    #+END_SRC

    Es util para localizar @e(etiquetas) de un solo caracter por ejemplo
    @c(<A>), @c(<B>), @c(<C>), @c(<D>), @c(<E>), etc.

*** Punto

    El constructor punto representado por el signo @c(.) se utiliza para
    realizar una coincidencia con cualquier caracter presente en el texto de
    busqueda.

    Por lo general se suele excluir el caracter @c(\n) (salto de linea). la
    razon de este comportamiento es solamente por practicidad aunque
    conceptualmente no existe un motivo para ello.

    El constructor punto no tiene efecto dentro de un conjunto, en su lugar se
    evalua como @e(el caracter) @c(.). No tiene sentido que un conjunto coincida
    con cualquier caracter.

*** Cuantificación

    Por defecto, el motor asume un constructor ha de estar presente almenos una
    vez, no obstante es posible especificar cuantas veces consecutivas puede
    aparecer un constructor. Para esto se hace uso de los @e(cuantificadores)
    que mas que un "constructor", @e(son una caracteristica de un constructor).

    Los cuantificadores se colocan justo al final del cosntructor al que han de
    aplicarse. El constructor alternacion, que veremos mas adelante no es
    compatible con los cuantificadores.

    - @c(?) ::

      El constructor puede aparecer cero o una vez. Por ejemplo, @c(ob?scuro) se
      corresponde con @c(oscuro) y @c(obscuro).

    - @c(+) ::

      El elemento debe aparecer al menos una vez. Por ejemplo, @c(ho+la) describe
      el patron infinito @c(hola), @c(hoola), @c(hooola), @c(hoooola), ...,

    - @c(*) ::

      El elemento puede aparecer cero, una, o más veces. Por ejemplo, @c(0*42) se
      corresponde con @c(42), @c(042), @c(0042), @c(00042), ...,

    - @c({n}) ::

      El elemento debe aparecer exactamente @m(n) veces. Por ejemplo
      @c([0-9]{3}) se corresponden con cualquier cifra de tres digitos como
      @c(007), @c(747), @c(777), ...,

    - @c({a,b}) ::

      El elemento debe aparecer un minimo de @m(a) veces y un maximo de @m(b)
      veces.

*** Alternación

    Como ya vimos la agrupacion permite la busqueda de mas de un constructor
    caracter para una posicion especifica. El constructor alternacion se
    comporta de forma idetica, solo que en lugar de manejar constructores
    caracter maneja expreciones delimitadas una de otra por el signo @c(|):

    #+BEGIN_SRC c
      exp1|exp2|exp3|...
    #+END_SRC

    en este caso el termino @e(exprecion) se refiere a una RegExp en si.

    La busqueda de expresiones se realiza de forma secuencial, de izquierda a
    derecha hasta localizar alguna expresion o hasta agotar las
    alternativas. Por ejemplo

    #+BEGIN_SRC c
      "Raptor|T Rex|Triceratops"
    #+END_SRC

    genera los patrones de busqueda @c(Raptor), @c(T Rex) y @c(Triceratops)

    Como ya se menciono en el apartado anterior, los cuantificadores no se
    aplican a este constructor. Para cuantificar las arternativas deben
    encontrarse dentro de una agrupacion.

*** Agrupación

    Una agrupacion permite definir el ámbito y la precedencia de los demás
    constructores. Las agrupaciones se delimitan dentro de las signos @c[(] y
    @c[)]. Por ejemplo:

    #+BEGIN_SRC c
      "(p|m)adre"
    #+END_SRC

    es equivalente a

    #+BEGIN_SRC c
      "padre|madre"
    #+END_SRC

    y

    #+BEGIN_SRC c
      "(des)?amor"
    #+END_SRC

    se corresponde con @c(amor) y con @c(desamor).

*** Metacaracteres

    Para el motor los signos @c(.), @c[(], @c[)], @c(|), @c([), @c(]), @c(+),
    @c(?), @c({), @c(}), ..., etc. tiene un significado especial, ya sea como
    delimitadores, como cuantificadores o como constructores. Como hacer para
    buscar estos signos como simples caracteres?

    Podriamos colocarlos detro de un conjuto de caracteres, asi:

    #+BEGIN_SRC c
      "[()|+]"
    #+END_SRC

    pero existen casos complejos como:

    #+BEGIN_SRC c
      "[]]"
    #+END_SRC

    cual signo @c(]) marca el limite del conjunto?

    Para evitar casos ambiguos se hace uso del constructor @e(metacaracter) que
    despoja de su significado @e(especial) a los signos antes mencionados.

    El constructor metacaracter suele estar formado por dos signos, el signo que
    indica que se trata de un metacaracter y el signo al que se aplica. Por lo
    general el signo utilizado como indicador es @c(\).

    Ahora podemos solucionar el ejemplo anterior, pasaria a ser:

    #+BEGIN_SRC c
      "[\]]"
    #+END_SRC

    que ocurre si se aplica @c(\) a un caracter sin significado especial, por
    ejemplo, a @c(d)?

    #+BEGIN_SRC c
      "\d"
    #+END_SRC

    existen dos posibilidades:

    1. El motor interpreta @c(d) como un caracter.

    2. El motor otorga un significado especial al caracter, como podria ser la
       busqueda de un patron especifico, en cuyo caso, el significado puede
       variar de una implementacion a otra.


    Cuando el caso es el segundo, la mayoria de los motores cosidera que el
    metacaracer @c(\d) (digit) equivalente al conjunto @c([0-9]).

    Aqui una lista de los significados comunes de algunos metacaracters

    - @c(\d) ==> @c([0-9])
    - @c(\D) ==> @c([^0-9])
    - @c(\a) ==> @c([a-bA-B])
    - @c(\A) ==> @c([^a-bA-B])
    - @c(\w) ==> @c([a-bA-B0-9])
    - @c(\W) ==> @c([^a-bA-B0-9])
    - @c(\s) ==> @c([ \t-\r])
    - @c(\S) ==> @c([^ \t-\r])


    Finalmente, podemos utilizar metacaracteres para representar signos no
    impribibles como pueden ser nueva linea, tabulador, retroceso, campana,
    etc.

*** Modiicadores

    Aunque no se definen como tal, los modificadores son una forma de alterar el
    comportamiento del motor al momento de efectuar la busqueda de un patron.

    Pongamos como ejemplo los dos modificadores mas comunes:

    - @c(^) :: colocar este signo @e(al inicio) de la expresion le indica al
               motor: la busqueda solo sera valida si el patron se encuentra al
               inicio del texto.

    - @c($) :: colocar este signo @e(al final) de la expresion le indica al
               motor: la busqueda solo sera valida si el patron se encuentra al
               final del texto.


    ambos modificadores pueden combinarse dentro de la expresion, indicando: la
    busqueda sera valida si el patron inicia el la posicion inicial del texto y
    finaliza en la ultima posicion.

    Los modificadores al igual que los metacaracteres dependen unicamente de lo
    que especifique cada implementacion.

* Regexp3 (ASCII)
** Herramientas

   Asi que, te has decidido a leer este libro y tienes la suficiente experiencia
   como para escribir, compilar y ejecutar un programa en C.

   No voy a decirte el sistema bajo el que deberias programar, tampoco si es
   mejor utilizar un editor, un IDE o Emacs, ni cual compilador, shell o mapeo
   de teclado sea el mas apropiado. Seguramente has elegido tus herramientas
   tras una profunda refleccion, luego evaluar todas las posibilidades y no por
   que alguien te impuso su uso...

   No obstante y solamente por motivos informativos, te presento la configuracion
   que utilizo y el porque:

   - Como sistema operativo @e(GNU) con @e(Linux). No fue hasta que llegue a la
     distribucion @e(Debian), que conoci lo que era la informatica, lo util de
     los repositorios de software y la existencia del movimiento @e(software
     libre).

   - Como entorno de escritorio grafico @e(Gnome Shell). Es simple, sobrio,
     bonito y eficaz.

   - Donde hay un prompt hay felicidad! No hay mejor herramienta para interactuar
     con el sistema, que una terminal.

     En particular me gusta @e(Konsole), parte del proyecto KDE. Tiene pestañas
     multiples, pueden desabilitarse el menu y la barra de despalazamiento, para
     ocupar la pantalla completa sin distracciones, ademas la configuracion del
     teclado es muy flexible.

   - Quien hace aparecer el prompt es @e(fish), un interpre de comandos con
     colorines y un sistema de autocompletado fantanstico.

   - Para compilar programas C, @e(GCC) el compilador de GNU. Ademas suelo pedir
     una segunda opinion al compilador @e(clang) (LLVM).

   - Como sistema de control de versiones @e(git). Conocer los comandos basicos
     es mas que suficiente.

   - Los sonidos del mundo son muy aburridos. @e(moc) (Music On Console) se
     encarga del amenizar el ambiente con buena musica.

   - La pieza sobre la que gira mi flujo de trabajo se llama @e(GNU Emacs), un
     interprete de Emacs Lisp, que tambien suele utilizarse como editor de texto
     (risas). En serio no compliques tu vida con molestos IDEs llenos de botones,
     menus y mierdas graficas. Todo es mejor en texto plano!

   - Finalmente utilizo el mapeo de teclado @e(programmer dvorak) con una ligera
     modificacion (los dos control, mayus, @ y \) y una configuracion de al menos
     dos monitores.

** Mr. Raptor

   #+BEGIN_QUOTE
     Disponer del codigo fuente de un programa no garantiza que seamos capaces
     de compreder su funcionamiento. Si para entender un proyecto es necesario
     asistir a su construccion y tener presente todos su detalles ocultos,
     probablemente cuando los desarrolles pasen a otro proyecto nadie este
     dispuesto (o sea capaz) de continuar con el desarrollo.

     Por ello no es suficiente disponer del codigo, ademas, debe ser simple y
     directo, para que otros sean capaces de comprender su funcionamiento.

     El primer paso para lograr este objetivo es dar nombres claros y concisos
   #+END_QUOTE

   De donde surge el nombre del motor?

   La primer version funcional simplemente se llamaba @f(regexp). Pese a ser un
   nombre conciso, ya no estaba disponible, lo cual me obligo a ser un poco mas
   creativo.

   El nombre debia destacar las cualidades del proyecto. Si el motor sobresale
   en algun aspecto es por no tener un manejo explicito de memoria, en su lugar,
   optiene memoria llamando a funciones y llamando a funciones de forma
   recursiva... ya esta, @e(RE²) (Recursive Regexp), un momento, nooo, google ya
   utiliza este nombre para su motor RegExp @e(RE2), bueno, otra caracteristica
   tendra... el codigo es compacto, si, es tan compacto que ha de ser
   ridiculamente eficiente, lo cual lo hace ridiculamente veloz, veloz, veloz,
   rapido, Raptor, @e(Recursive Regexp Raptor), je, que creativo, no puede ser
   RE³ o lo asociaran con google, su alias sera @e(regexp3) (es mas comodo
   escribir @c(#include "regexp3.h") que @c(#include "RecursiveRegexpRaptor.h"),
   ademas, deja clara su funcion y tiene una longitud similar al de otras
   librerias de C como @c(stdlib), @c(stdio) o @c(ctype)).

   Una ves desvelado el misterio demos paso a la construccion.

** El truco

   He tratado de mantener el codigo lo mas simple y compacto posible, centrando
   la atencion en los puntos importantes. En la practica esto repercute en tres
   puntos a cosiderar:

   - No se utiliza la sintaxis regexp estadar, tampoco la que maneja Perl. En su
     lugar se opta por la que es mas facil de programar e interpretar.

   - El motor asume que la expresion que resive tiene una sintaxis correcta.

     En la practica es igual de complejo constuir una programa encargado solo de
     verificar y mostrar los errores de sintaxis, a uno que simplemente busca la
     exprecion. Sin demasiado esfuerzo, se opta por la segunda opcion, ademas,
     se esta contruyendo un motor RegExp @e(en C), si los datos de entrada son
     inapropiados, lo minimo que merece el programador es un ciclo de ejecucion
     infinito.

   - El manejo de memoria no se realiza de forma explicita, en su lugar se acude
     a la recursividad.


   En cualquer punto podras ser capas de reforsar el codigo si asi lo
   deseas. Sin embargo te recomiendo esperar hasta que el programa realice todas
   las funciones que necesites.

** La Sintaxis

   La version final de @c(regexp3) (ASCII) soporta los siguientes constructores:

   - Alternacion @c(|)

   - Agrupacion @c[()]. Para "capturar" la coincidencia del patron dentro de la
     la cadena de texto, se utiliza @c(<>)

   - Los cuantificadores son

     - @c(?) cero o una vez

     - @c(+) una o mas veces

     - @c(*) cero o mas veces

     - @c({n}) @m(n) veces

     - @c({a,b}) un rango de veces

   - Los conjuntos @c([]).

     - Para negar un conjunto el primer elemento debe ser @c(^)

   - Lon rangos se especifican con el signo @c(-) y son validos fuera de un
     conjunto, el decir @c(-) es un signo especial para el motor. Si queremos
     despojarlo de su significado tenemos que incluirlo en un metacaracter
     @c(:-).

   - Punto @c(.). Un punto dentro de un conjunto, no pierde su
     significado. Para buscar el caracter @c(.) debemos incluirlo en un
     metacaracter @c(:.).

   - El metacaracter se conforma de dos caracteres el signo @c(:) y el
     metacaracter.

   - Los modificadores de comportamiento se aplican de forma global o local y se
     especifican con el signo @c(#) seguido por los modificadores.

     Para modificar el comportamiento @e(global) de la exprecion, el modificador
     se coloca al inicio de la exprecion antes de cualquier constructor.

     Para modificar el comportamiento de un constructor en especifico @c(#) se
     coloca al final del constructor. Si se aplica un cuantificador al
     constructor, el modificador debe especificarse despues de este.

** El algoritmo
*** Como interpretar la regexp

    Una expresion regular es una serie de instrucciones detalladas no ambiguas,
    que describen un patron de busqueda a un interprete (motor) de expresiones
    regulares.

    El patron de la regexp sigue una [[*Sintaxis%20RegExp][sintaxis]] donde la unidad fundamental se
    llama constructor. Estas unidades cual si fuesen bloques de construccion
    pueden conbinarse y agruparse para formar un patron de busqueda mas complejo
    segun las reglas y posicion de cada constructor.

    En principio, un motor regexp solo necesita dos datos de entrada: la regexp
    y una cadena de texto sobre la cual efectuar la busqueda del patron.

    Una vez el motor tiene estos dos datos, debe @e(optener) el primer
    constructor de la regexp y comparar todas sus combinaciones posibles en la
    cadena, tomando como posicion de referencia el primer caracter de la cadena.

    Si todas las combinaciones fallan, el motor mueve la posicion de referencia
    al segundo caracter de la cadena y de nuevo prueba todas las combinaciones
    del primer constructor. Si el primer constructor coincide con la cadena el
    motor avanza atraves de regexp y cadena, optiene el siguiente constructor y
    lo compara con la nueva posicion de la cadena. Si el constructor no
    coincide, el motor vuelve al ultimo recorrido completo e intenta (si existe)
    una combinacion diferente. De lo contrario, intentara nuevamente con el
    primer constructor en la siguiente posicion de la cadena.

    Si se llega al final de la cadena sin antes agotar los constructores
    signica que el patron de busqueda no esta precente.

    Si se agotan los contructores el motor informara que existe una
    coincidencia.

    Es importante resaltar que el avance tanto en la exprecion como en la cadena
    se realiza de izquierda a derecha. Esto proboca que el motor regrese la
    coincidencia en la cadena mas a la izquierda de la combinacion de
    constructores en la regexp mas a la izquierda.

    Resumiento los puntos claves de los parrafos anteriores:

    1. Se analiza el texto y la regexp de izquierda a derecha.

    2. Se optiene el primer constructor de la regexp y se prueban todas sus
       combinaciones en la posicion actual de la cadena.

    3. Si el patron del constructor coincide con la cadena se avanza atraves de
       regexp y cadena.

    4. Si el patron del constructor no se encuenta en la cadena, el motor vuelve
       al ultimo recorrido completo e intenta otra ruta.

    5. Si no hay otra ruta el motor avanza una posicion en la cadena e intenta
       con la regexp apartir del primer constructor

    6. Si se agotan los constructores tenemos una coincidencia.

    7. Si se agota la cadena no tenemos ninguna coincidencia.


    El @e(punto dos), da a entender que un constructor tiene varias
    combinaciones posibles. A saber los constructores son @e(agrupacion),
    @e(alternacion), @e(conjunto), @e(rango), @e(punto), @e(metacaracter) y
    @e(caracter). Analicemos cada constructor.

    Una @e(agrupacion) contiene un numero indeterminado de combinaciones
    posibles, ya que puede @"(agrupar) a cualquier otro constructor, incluso
    otras agrupaciones.

    Una @e(alternacion) permite recorrer multiples @e(rutas) de ejecucion hasta
    que alguna coincida, cada una de estas "rutas" puede estar formada por
    expreciones de complejidad arbitraria.

    Los @e(conjuntos) solo pueden contener @e(rangos), @e(metacaracteres) y
    @c(caracteres).

    @e(caracteres), @e(metacaracteres) y @e(punto) no pueden contener a ningun
    otro constructor.

    El @e(caracter) solo tiene una combinacion posible, el mismo. El @e(punto)
    puede coincidir con cualquier caracter. Un @e(conjunto) puede coincidir con
    un caracter que este dentro de su conjunto de elementos y la coincidencia de
    un @e(metacaracter) depende de la implementacion de cada motor.

    La conclusion es: si el constructor es distinto de @e(caracter) tendremos
    que probar todas sus posibles combinaciones.

    El @e(tercer punto) dice que el motor avanza atravez de regexp y cadena, es
    decir, si el constructor coincide con @m(n) caracteres de la cadena, el
    siguiente constructor se compara @m(n) caracteres despues de la comparacion
    anterior.

    Imaginemos que tenemos un ciclo de busqueda donde los constructores y la
    cadena se corresponden correctamente:

    #+BEGIN_EXAMPLE
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲       ▲▲     ▲▲         ▲▲     ▲
                  │Α     Ω││Α   Ω││Α       Ω││Α   Ω│
      constructor [ cons1 ][cons2][  cons3  ][cons4]...
    #+END_EXAMPLE

    @c(Α) (Alfa) señala el punto inicial de la cadena donde se compara el
    constructor y @c(Ω) (Omega) señala los @m(n) caracteres que abarca la
    (posible) coincidencia.

    Puede observarse, que cada constructor es independiente uno de otro, es el
    motor quien se encarga de coordinar la posicion de la cadena donde se
    compara un constructor en especifico. El recorrido atravez de ambos, como
    indica el @e(punto uno) siempre se realiza de izquierda a derecha.

    El @e(punto cuatro) dice que si la comparacion falla, el motor vuelve al
    ultimo recorrido completo e intenta @e(otra ruta). Esto da a entender que el
    motor lleva un registro de la posicion en la cadena y el numero de
    constructor que se utiliza para cada comparacion e incluso que el motor debe
    conocer la existencia de distintas rutas de ejecucion. Veamos detenidamente
    este punto.

    Si tenemos una serie de constructores de tipo caracter y la coincidencia del
    ultimo constructor falla (@c(x) != @c(5))

    #+BEGIN_EXAMPLE
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲▲▲▲▲△
                  ││││││
      constructor 01234x6789
    #+END_EXAMPLE

    cual seria la ultima ruta de ejecucion completa? Correcto, niguna. En esta
    exprecion (@c(01234x6789)) regresar al constructor anterior @c(4) (la ultima
    ruta completa) no tiene sentido, pues para completar la ruta el constructor
    tipo caracter @c(x) ha de coincidir, es decir, no existe otra ruta de
    ejecucion posible.

    Veamos otro caso:

    #+BEGIN_EXAMPLE
      cadena      0123x56789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲▲▲▲△
                  │││││
      constructor 0││3│
                   ││ │
                   ││[456789]
                  (12)
    #+END_EXAMPLE

    la regexp es @c{0(12)[456789]}, ¿cual seria la ultima ruta de ejecucion
    completa? Correcto, niguna. Al igual que la exprecion anterior solo existe
    @e(una ruta) de ejecucion... porque? un conjunto contiene multiples
    elementos posibles de coincidencia, no multiples rutas de ejecucion. Si
    ninguno de sus elementos coincide no hay un punto al cual regresar, esto
    mismo aplica a las agrupaciones.

    Entoces? el unico constructor que permite multiples rutas de ejecucion es la
    @e(alternacion).

    Cuando el motor "ve" una exprecion del tipo @c(1234x|12345), se dice a si
    mismo: uh, tengo un par de rutas @c(1234x) y @c(12345), debo almacerar la
    posicion inicial e intertar con la primer ruta, si esta falla restaurar la
    posicion inicial e intentar con la segunda ruta..

    la primer ruta de ejecucion sera

    #+BEGIN_EXAMPLE
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲▲▲▲▲△
                  ││││││
      constructor 01234x
    #+END_EXAMPLE

    el patron falla al comparar el quinto constructor caracter (dentro del
    constructor alternacion). Luego el motor prueba con la segunda ruta de
    ejecucion

    #+BEGIN_EXAMPLE
      cadena      0123456789:;<=>?@ABCDEFGHIJKLMNOPQ...
                  ▲▲▲▲▲▲
                  ││││││
      constructor 012345
    #+END_EXAMPLE

    en esta ocacion, todos los constructores miembro del constructor alternacion
    coinciden, luego entonces, al no existir mas constructores en la exprecion
    @c(1234x|12345) el motor informa la coincidecia.

    Esto implica que el motor optiene los constructores de la exprecion
    @c(1234x|12345) de la siguiente forma

    #+BEGIN_EXAMPLE
      regexp          "1234x|12345"

      constructor:     1234x|12345       tipo: alternacion
      almacenar posicion de inicio

      generar          RUTA1 y comparar con la posicion de inicio
      constructor:     1                 tipo: caracter
      constructor:      2                tipo: caracter
      constructor:       3               tipo: caracter
      constructor:        4              tipo: caracter
      constructor:         x             tipo: caracter

      si la primer ruta falla
      generar                RUTA2 y comparar con la posicion de inicio
      constructor:           1           tipo: caracter
      constructor:            2          tipo: caracter
      constructor:             3         tipo: caracter
      constructor:              4        tipo: caracter
      constructor:               5       tipo: caracter
    #+END_EXAMPLE

    (º-°)ง un momento, dices que la exprecion

    #+BEGIN_SRC c
      "abc"
    #+END_SRC

    para el motor es (la C es por "constructror")

    #+BEGIN_EXAMPLE
      [C-caracter][C-caracter][C-caracter]
    #+END_EXAMPLE

    que

    #+BEGIN_SRC c
      "a[bcdefghi]c"
    #+END_SRC

    para el motor es

    #+BEGIN_EXAMPLE
      [C-caracter][C-conjunto][C-caracter]
    #+END_EXAMPLE

    que

    #+BEGIN_SRC c
      "(a[bcdefghi])c"
    #+END_SRC

    es

    #+BEGIN_EXAMPLE
      [C-agrupacion][C-caracter]
    #+END_EXAMPLE

    y que

    #+BEGIN_SRC c
      "(a[12345]|c[12345])|e"
    #+END_SRC

    es

    #+BEGIN_EXAMPLE
      [C-alternacion]
    #+END_EXAMPLE

    Eso es correcto! El motor debe identificar los constructores @e(de primer
    nivel) (por llamarlos de algun modo) y luego, si es el caso optener
    constructores apartir de estos.

    Ademas, se debe tener en cuenta que siempre existe almenos una ruta de
    ejecucion, @e(la regexp en si). Solo cuando existe una alternacion en el
    primer nivel habra mas de una ruta de ejecucion ... y, el motor solo ve las
    alternaciones cuando se encuentran en el primer nivel, en decir, no estan
    dentro de una agrupacion. Por tanto la primer accion del motor es comprobar
    si existe mas de una ruta de ejecucion o lo que es lo mismo, averiguar si el
    primer constructor es una alternacion.

    (º-°)ง espera, como se puede coordinar el avance entre los constructores de
    primer nivel y sus componentes, si los tienen? Sencillo, los constructores
    miembro desconocen el nivel al que pertenecen, el motor realiza una nueva
    busqueda con los constructores miembros a partir de un punto concreto en la
    cadena como si fuesen una exprecion autonoma, si hay una coincidencia el
    motor informa el resultado y su longitud a quien solicite la
    consulta. Veremos este mecanismo en la codificacion del motor.

    (º-°)ง cuando se realiza este proceso? cuando el constructor es de tipo
    agrupacion o alternacion, puesto que en ambos casos estos constructores
    pueden contener expresiones formadas por cualquier tipo y cantidad de
    constructores.

*** Pseudocodigo

    #+BEGIN_SRC
      El motor recibe la regexp y la cadena de caracteres

      Un bucle recorre la cadena de izquierda a derecha, un caracter a la vez.

      | Realizamos una busqueda del patron en la posicion actual de la cadena
      |
      | Un bucle recorre la regexp de izquierda a derecha opteniendo los
      | constructores
      |
      | | Si el constructor es de tipo alternacion almacenamos la posicion de
      | | inicio en la cadena y recorremos las rutas
      | |
      | | Si el constructor es de tipo agrupacion recorremos sus constructores
      | | miembro
      | |
      | | El resto de constructores pueden buscarse directamente en la cadena
      | |
      | | | Si hay coincidencia, movemos la cadena las n posiciones que abarca
      | | | el patron
      | |
      | | | Si no hay coincidencia la ruta termina con fallo.
      | |
      | | | Si no hay mas rutas la busqueda terimina con fallo.
      |
      | Si llegamos al final del bucle hay una coincidencia
    #+END_SRC

*** Diagrama

    #+BEGIN_EXAMPLE
          ┌──────┐
          │inicio│
          └──────┘
              │◀───────────────────────────────────┐
              ▼                                    │
      ┌────────────────┐                           │
      │bucle por cadena│                           │
      └────────────────┘                           │
              │                                    │
              ▼                                    │
       ┌─────────────┐  no   ┌─────────────┐       │
      <│fin de cadena│>────▶<│buscar regexp│>──────┘
       └─────────────┘       └─────────────┘  no coincide
              │ si                  │ coincide
              ▼                     ▼
      ┌────────────────┐    ┌────────────────┐
      │informar: no    │    │informar:       │
      │hay coincidencia│    │hay coincidencia│
      └────────────────┘    └────────────────┘
              │                     │
              │◀────────────────────┘
              ▼
            ┌───┐
            │fin│
            └───┘
    #+END_EXAMPLE

    En esta version de @c(buscar regexp) todos los constructores se optienen por
    una sola funcion:

    #+BEGIN_EXAMPLE
                                                                  ┌───────────────────────────────┐
      ┏━━━━━━━━━━━━━┓                                             ▼                               │
      ┃buscar regexp┃                                   ┌───────────────────┐                     │
      ┗━━━━━━━━━━━━━┛                                   │Optener constructor│                     │
                                                        └───────────────────┘                     │
                                                                  │                               │
                                                                  ▼                               │
                                                          ┌───────────────┐  no  ┌─────────────┐  │
                                                         <│hay constructor│>────▶│terminar: la │  │
                                                          └───────────────┘      │ruta coincide│  │
                                                                  │ si           └─────────────┘  │
                                    ┌──────────┬────────┬─────────┼───────────┬──────────┐        │
                                    ▼          ▼        ▼         ▼           ▼          ▼        │
                              ┌───────────┐┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐  │
                              │alternacion││conjunto││punto││metacaracter││caracter││agrupacion│  │
                              └───────────┘└────────┘└─────┘└────────────┘└────────┘└──────────┘  │
                                    │          │        │         │           │          │        │
                                    ▼          └────────┴─────────┼───────────┘          └────────┤
                             ┌──────────────────┐                 │                               │
                  ┌──────────│ guardar posicion │                 ▼               no              │
                  │          └──────────────────┘       ┌──────────────────┐   coincide           │
                  │          ┌──────────────────┐      <│buscar constructor│>─────────┐           │
                  ▼◀─────────│restaurar posicion│◀──┐   └──────────────────┘          │           │
           ┌───────────────┐ └──────────────────┘   │             │ coincide          │           │
           │recorrer rutas │                        │             ▼                   ▼           │
           └───────────────┘                        │    ┌──────────────────┐ ┌────────────────┐  │
                  │                                 │    │avanzar por cadena│ │terminar, ruta  │  │
                  ▼                                 │    └──────────────────┘ │sin coincidencia│  │
              ┌────────┐   si     ┌─────────────┐   │             │           └────────────────┘  │
             <│hay ruta│>───────▶<│buscar regexp│>──┘             └───────────────────────────────┘
              └────────┘          └─────────────┘ no coincide
                  │ no           coincide │
                  ▼                       ▼
      ┌─────────────────────────┐ ┌─────────────┐
      │terminar sin coincidencia│ │terminar, la │
      └─────────────────────────┘ │ruta coincide│
                                  └─────────────┘
    #+END_EXAMPLE

    bonito diseño (funciona!), aun asi buscar el constructor @e(alternacion) en
    cada bucle atravez de la regexp es un desperdicio de recursos, @e(el
    constructor alternacion solo es visible (al motor) si esta fuera de
    cualquier otro constructor) (en la practica, eso siginifica estar fuera del
    constructor agrupacion).

    #+BEGIN_EXAMPLE
                    ┌──────────────────┐
                    │ guardar posicion │                                 ┏━━━━━━━━━━━━━┓
                    └──────────────────┘                                 ┃buscar regexp┃
               ┌────────────▶│                                           ┗━━━━━━━━━━━━━┛
               │             ▼
               │      ┌───────────────┐
               │      │recorrer rutas │
               │      └───────────────┘
               │             │                         ┌─────────────────────────────────┐
               │             ▼                         ▼                                 │
               │         ┌────────┐   si     ┌───────────────────┐                       │
               │        <│hay ruta│>────────▶│obtener constructor│                       │
               │         └────────┘          └───────────────────┘                       │
               │             │ no                      │                                 │
               │             ▼                         ▼                                 │
               │ ┌─────────────────────────┐   ┌───────────────┐  no  ┌─────────────┐    │
               │ │terminar sin coincidencia│  <│hay constructor│>────▶│terminar: la │    │
               │ └─────────────────────────┘   └───────────────┘      │ruta coincide│    │
               │                                       │ si           └─────────────┘    │
               │                    ┌────────┬─────────┼───────────┬──────────┐          │
               │                    ▼        ▼         ▼           ▼          ▼          │
      ┌──────────────────┐      ┌────────┐┌─────┐┌────────────┐┌────────┐┌──────────┐    │
      │restaurar posicion│      │conjunto││punto││metacaracter││caracter││agrupacion│    │
      └──────────────────┘      └────────┘└─────┘└────────────┘└────────┘└──────────┘    │
               ▲                    │        │         │           │          │          │
               │                    └────────┴─────────┼───────────┘          │          │
               │                                       ▼                      ▼          │
       ┌────────────────┐    no coincide     ┌──────────────────┐      ┌─────────────┐   │
       │terminar: ruta  │◀────────┬─────────<│buscar constructor│>  ┌─<│buscar regexp│>  │
       │sin coincidencia│         │          └──────────────────┘   │  └─────────────┘   │
       └────────────────┘         │                    │ coincide   │         │          │
                                  └──────────────────┈┈│┈┈──────────┘         │ coincide │
                                                       ▼                      │          │
                                              ┌──────────────────┐            └──────────┤
                                              │avanzar por cadena│                       │
                                              └──────────────────┘                       │
                                                       │                                 │
                                                       └─────────────────────────────────┘
    #+END_EXAMPLE

** codigo
*** interfaz

    En el lenguaje de programacion C, las funciones dividen un programa extenso
    en pequeños fragmentos que realizan tareas concretas y dan la posibilidad de
    construir sobre lo que otros ya han hecho (... eso suena a @e(sotfware
    libre)).

    En esencia y segun los gurus del mundo de la programacion, una buena funcion
    debe cumplir almenos estos principios

    - debe hacer una sola cosa
    - tener un nombre que describa su funcion
    - no necesitar mas de tres tres argumentos, de preferencia ninguno.


    en realidad la lista es mas extensa y detallada (lo suficiente como para
    escribir un libro), almenos interare seguir estas normas en la medida de lo
    posible, que tampoco es que existan muchos ejemplos de buen gusto en lo que
    a programar en lenguaje C se refiere..

    Para cumplir el primer punto debemos preguntar ¿Que es lo que hace un motor
    regexp?

    - Buscar la coincidencia de un patron en una cadena.

    - Mostrar el fragmento de la cadena que corresponda al patron.

    - Localizar todas las coincidencias de un patron.

    - Capturar todas las coincidencias.

    - Mostrar las coincidencias

    - Permitir modificar las coincidencias


    Compactar todas estas tareas en una sola funcion, no es prudente (eso no
    evita que algunas implementaciones lo intenten). @e(Recursive Regexp Raptor)
    hereda una interfaz que ha sobrevidido sin cambio alguno durante miles de
    millones de años

    #+BEGIN_SRC c
      unsigned int regexp3( char *txt, char *re );
    #+END_SRC

    Lo que intenta transmitir el prototipo de funcion es:

    Hola soy un motor de expreciones regulares, me llamo @e(Recursive Regexp
    Raptor) pero tu puedes llamarme @c(regexp3), para invocarme tienes que darme
    una regexp en forma de cadena de caracteres (argumento @c(re)) y una cadena
    de caracteres donde buscar el patron (argumento @c(txt)). Con mis
    habilidades de raptor descubrire cuantas veces se encuetra el patron en la
    cadena y te informare de esto regresando el conteo de coincidencias, si no
    hay coincidencias regreso 0 (cero).

    Podriamos decir que cumple las tres reglas

    - Hace una cosa, contabilizar las coincidencias del patron.

    - tiene un nombre descriptivo... bueno el nombre no es muy explicito que
      digamos, pero almenos tiene la palabra regexp.

    - no necesita mas de 3 parametros (@c(2 < 3)).


    El resto de la interfaz, esta relacionado con el manejo y la manipulacion de
    capturas. Se veran a su debido tiempo segun avance el desarrollo del motor,
    por el momento nos centraremos en el metodo para optener los constructores
    de la exprecion.

*** constructores

    Es una lastima no poder conectarnos directamente a la maquina y transmitirle
    los algotirmos mentales de cada problema que hemos resuelto. Peor aun,
    tenemos serias deficiencias para transmitir dichas soluciones de forma
    detallada, coherente y no ambigua, que es precisamente en lo que consiste la
    programacion.

    Mientras esperamos la llegada de la [[https://es.wikipedia.org/wiki/Singularidad_tecnol%C3%B3gica][singularidad]] y con la poca habilidad
    expresiva que poseeo hare lo posible para plasmar un procedimiento logico
    de codificacion... alla vamos...

    La regexp tiene una sintaxis bien definida que nos ayuda a identificar el
    tipo, patron y alcance de cada constructor. Una vez se ha identificado el
    constructor es necesario almacenar sus caracteristicas de forma conveniente.

    Para nuestra fortuna C nos permite manejar un grupo de variables
    relacionadas (las caracteristicas) como una unidad, en lugar de como
    entidades dispersas. Este tipo de dato compuesto por datos de tipos
    diversos, recive el nombre de estructura (@c(struct))

    De momento, la estructura que almacena la informacion de nuestra regexp solo
    necita dos datos:

    1. El contenido (instruciones) del constructor.

       El motor recive la regexp en formato cadena de caracteres. A medida que
       analiza la cadena debe marcar el @e(alcance) de cada constructor, es
       decir, el punto de inicio (@c(char *ptr)) y su longutid (@c(int len)).

    2. Un identificador del tipo de constructor que estamos manejando (@c(enum
       TYPE type))

    #+BEGIN_SRC c
      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };
    #+END_SRC

    Cada elemento de la enumeracion @c(TYPE) se corresponde con un constructor:

    - @c(PATH) para el constructor @e(alternacion).

      El motor puede utilizara este identificador a modo de comodin para una
      expresion sin analizar, ya que cualquier expresion puede considerarse como
      una alternacion de una sola ruta...

    - @c(GROUP) para el constructor agrupacion

    - @c(HOOK). En la mayoria de implementaciones regexp, cuando una agrupacion
      coincide con un fragmento de la cadena, el motor debe almacenar una
      referenecia a dicho fragmento. En nuestra implementacion la captura de una
      agrupacion debe indicarse explicitamente.

      segun el traductor @c(HOOK) significa gancho y se ofrece como una opcion
      para traducir @"(captura) o @"(pesca).

    - @c(BACKREF). @e(Backreference) (retroreferencia o referencia anterior)

      Una vez se ha realizado la captura de una seccion de la cadena, con este
      constructor podemos solicitar la coincidencia de dicha seccion, en una
      posicicion mas adelante en la cadena

    - @c(SET) para conjunto de caracteres

    - @c(RANGEAB) un rango de caracteres.

      En realidad este no es un constructor, pero ya que un rango de caracteres
      posee una estructura especifica, hacemos uso de un idintificador a modo de
      facilidad.

      Una ventaja de esta aproximacion es permitir el uso de rangos fuera de un
      conjunto.

    - @c(META) para metacaracter

    - @c(POINT) para punto

    - @c(SIMPLE) para caracter.

      Dada la estructura del tipo @c(RE) y la naturaleza de este constructor, es
      posible tratar una secuencia de constructores caracter como una simple
      cadena de caracteres.


    Si analizamos el [[*Diagrama][diagrama de flujo]], es evidente que la complejidad del
    problema se concentra en optener los constructores mas que en el recorrido
    atraves de la cadena. Vamos a concentrarnos en ese aspecto, lo primero sera
    poder optener el constructor alternacion, los caracteres y las agrupaciones,
    en ese orden.

    Luego podremos realizar busquedas sencillas en una posicicion especifica de
    la cadena, mas tarde la busqueda se extendera por toda la longitud de la
    cadena.

    Las palabras @"(recorrido), @"(ruta), @"(caminar) o @"(segmento) son
    habituales cuando se explica el funcionamiento de un motor regexp. En
    nuestra implementacion Los nombres de variables y funciones adoptaran esta
    tematica simpre que sea apropiado.

    Con esto en mente y simplificando (mucho) el diagrama

    #+BEGIN_EXAMPLE
                   ┌───────┐
                   │regexp3│
                   └───┬───┘
                       │◀──────────────────────────────┐
                       ▼                               │
                    ┌──────┐                           │
                    │walker│                           │
                    └──┬───┘                           │
                       │                               │
                       ▼                               │
                   ┌────────┐                          │
                   │trekking│                          │
                   └───┬────┘                          │
        ┌──────┬───────┼─────┬──────┬───────┬──────┐   │
        ▼      ▼       ▼     ▼      ▼       ▼      ▼   │
      ┌───┐┌───────┐┌────┐┌─────┐┌──────┐┌─────┐┌────┐ │
      │SET││RANGEAB││META││POINT││SIMPLE││GROUP││HOOK│ │
      └───┘└───────┘└────┘└─────┘└──────┘└─────┘└────┘ │
        └──────┴───────┼─────┴──────┘       └──────┴───┘
                       ▼
                    ┌─────┐
                    │match│
                    └─────┘
    #+END_EXAMPLE

    La funcion @c(regexp3) es la funcion disponible al usuario. Se encargara de
    recivir, inicializar los datos, y realizar consultas de coindencia en cada
    posicion de la cadena.

    La funcion @c(walker) (caminante) recive la regexp, optiene y recorre cada
    ruta de ejecucion. Si alguna ruta coincide retorna verdadero, en caso
    contrario retorna falso

    La funcion @c(trekking) (senderista) optiene los constructores de una ruta,
    segun el tipo del constructor se realiza una consulta a @c(match) para
    buscar un patron directamente en la cadena, o a @c(walker) para generar
    nuevas subrutas de ejecucion y luego optener sus contructores.  @c(trekking)
    devuelve verdadero si todos los constructores coinciden, de lo contrario
    devuelve falso.

*** path

    #+BEGIN_SRC c
      #include <stdio.h>
      #include <string.h>

      #define TRUE  1
      #define FALSE 0

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int  walker ( struct RE  rexp );
      static int  cutPath( struct RE *rexp, struct RE *track );

      unsigned int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.len     = strlen( re );
        rexp.type    = PATH;

        return walker( rexp );
      }

      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker INIT", rexp.len, rexp.ptr );
        while( cutPath( &rexp, &track ) )
          printf( "%-20s >>%.*s<<\n", "walker PATH", track.len, track.ptr );

        return FALSE;
      }

      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;

        for( int i = 0, deep = 0; i < rexp->len; i++ ){
          if( rexp->ptr[ i ] ==  '(' )  deep++;
          if( rexp->ptr[ i ] ==  ')' )  deep--;
          if( rexp->ptr[ i ] ==  '|' && deep == 0 ){
            track->len  = i;
            rexp->ptr  += i + 1;
            rexp->len  -= i + 1;
            return TRUE;
          }
        }

        rexp->ptr += rexp->len;
        rexp->len  = 0;

        return TRUE;
      }
    #+END_SRC

    Esta es la primer version de nuestro motor, la unica caracteristica que
    posee es optener las rutas de ejecucion de la exprecion que recive. Coloca
    el codigo dentro de un fichero al que deberas llamar @f(regexp3.h), luego
    crea un fichero de nombre @f(test.c) y coloca lo siguiente

    #+BEGIN_SRC c
      #include "regexp3.h"

      int main(){
        regexp3( "", "ruta1|ruta2|ruta3" );

        return 0;
      }
    #+END_SRC

    en este fichero aplicaremos diversas pruebas al motor para virificar el
    correcto funcionamiento de cada caracteristica que vallamos agregando.

    Compila el codigo con el siguiete comando

    #+BEGIN_SRC sh
      gcc -Wall test.c
    #+END_SRC

    y ejecuta la prueba con

    #+BEGIN_SRC sh
      ./a.out
    #+END_SRC

    el resultado de la exprecion @c("ruta1|ruta2|ruta3") es el siguiente

    #+BEGIN_EXAMPLE
      walker INIT          >>ruta1|ruta2|ruta3<<
      walker PATH          >>ruta1<<
      walker PATH          >>ruta2<<
      walker PATH          >>ruta3<<
    #+END_EXAMPLE

    Antes de realizar nada @c(walker) muestra la exprecion inicial, luego,
    optiene y despliega de izquierda a derecha las rutas de ejecucion de la
    expresion.

    Vamos con la explicacion del codigo en @f(regexp3.h)

    #+BEGIN_SRC c
      #include <stdio.h>   // ➊
      #include <string.h>  // ➋

      #define TRUE  1      // ➌
      #define FALSE 0      // ➍

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };  // ➎

      struct RE {          // ➏
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int walker ( struct RE  rexp );                    // ➐
      static int cutPath( struct RE *rexp, struct RE *track );  // ➑
    #+END_SRC

    se utiliza @c(stdio) para mostrar la informacon ➊, @c(string) ➋ para
    optener la longitud de la cadena que contiene la regexp.

    C, por defecto no tiene constantes que definan verdadero o falso. Reparamos
    esta carencia mediante las constantes de macro @c(TRUE) ➌ (veradero) y
    @c(FALSE) ➍ (falso).

    Luego con la enumeracion @c(TYPE) generamos constantes que representan los
    diversos tipos de constructor ➎.

    La estructura @c(RE) ➏ sera el contenedor de los constructores.

    En C, antes de utilizar una funcion tenemos que escribir su definicion, o
    declarar un prototipo de funcion y realizar la definicion mas adelante. Se
    opta por declarar los prototipos para que la lectura del codigo fluya de
    forma descendente ➐➑ segun se van utilizando las funciones.

    #+BEGIN_SRC c
      unsigned int regexp3( char *txt, char *re ){
        struct RE    rexp;             // ➊
        rexp.ptr     = re;             // ➋
        rexp.len     = strlen( re );   // ➌
        rexp.type    = PATH;           // ➍

        return walker( rexp );         // ➎
      }
    #+END_SRC

    @c(regexp3) la funcion principal del motor, solicita una instancia de la
    estructura @c(RE) y apropiadamente la llama @c(rexp) (Regular EXPresion)
    ➊.

    Inicializamos el contenedor @c(rexp) con los datos que contiene @c(char
    *re):

    1. El inicio de la expresion apunta al inicio de la cadena ➋.

    2. La longitud de la expresion es la longitud de la cadena ➌.

    3. Ya que toda regexp sin importar la cantidad y tipos de constructores que
       la conforman contiene almenos una ruta de ejecucion, asignamos el tipo
       (generico) @c(PATH) ➍.


    La funcion termina devolviendo el valor de la consulta a @c(walker), quien
    de momento se limita a recorrer, generar y mostrar las rutas de ejecucion de
    la exprecion ➎.

    Es importante resaltar que @e(ninguna funcion modifica ni la exprecion, ni
    la cadena de busqueda). El recorrido, comparacion y generacion de
    constructores siempre se realiza mediante referencias a puntos en cadena y
    regexp, el unico defecto de este enfoque, es un eficiente manejo de
    recursos... je!.

    #+BEGIN_SRC c
      static int walker( struct RE rexp ){
        struct RE track;                                                      // ➊

        printf( "%-20s >>%.*s<<\n", "walker INIT", rexp.len, rexp.ptr );      // ➋
        while( cutPath( &rexp, &track ) )                                     // ➌
          printf( "%-20s >>%.*s<<\n", "walker PATH", track.len, track.ptr );  // ➍

        return FALSE;                                                         // ➎
      }
    #+END_SRC

    @c(walker) debe optener (y mas adelante buscar) las rutas de ejecucion, lo
    cual logra con un bucle @c(while) y la fucion @c(cutPath) ➌.

    En lenguaje comun, la funcion dice: tomo una regexp (@c(rexp)), la corto en
    secciones @c(PATH) (@c(cutPath)), una a la vez, cada seccion se almacena en
    el contenedor @c(track) ➊, para comprobar que el resultado es correcto se
    muestra su contenido ➍. Este ciclo continua hasta agotar la regexp
    (@c(while)). Si el ciclo termina sin la coincidencia de ninguna ruta, la
    regexp (como conjunto) no coincide ➎.

    La funcion auxiliar @c(cutPath) se encarga de cortar la ruta mas a la
    izquierda de una expresion. Si solo hay una ruta, el corte abarca la
    expresion entera.

    #+BEGIN_SRC c
      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;  // ➊

        *track = *rexp;                     // ➋

        for( int i = 0, deep = 0; i < rexp->len; i++ ){  // ➌
          if( rexp->ptr[ i ] ==  '(' )  deep++;          // ➍
          if( rexp->ptr[ i ] ==  ')' )  deep--;          // ➎
          if( rexp->ptr[ i ] ==  '|' && deep == 0 ){     // ➏
            track->len  = i;                // ➐
            rexp->ptr  += i + 1;            // ➑
            rexp->len  -= i + 1;            // ➒
            return TRUE;
          }
        }

        rexp->ptr += rexp->len;             // ➓
        rexp->len  = 0;                     // ⓫

        return TRUE;
      }
    #+END_SRC

    Antes de realizar nada debemos comprobar que la regexp tiene algo que
    cortar, o dicho de otra manera, tiene una longitud mayor a cero ➊. Podemos
    configurar el codigo de 2 maneras:

    #+BEGIN_SRC c
      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len > 0 ){
          // acciones
          return TRUE;
        }

        return FALSE;
      }
    #+END_SRC

    o

    #+BEGIN_SRC c
      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        // acciones
        return TRUE;
      }
    #+END_SRC

    ambas son validas, elijo la segunda, el codigo tiene dos lineas y un nivel
    de anidamiento menos. En cuanto a la comprobacion de la segunda opcion
    @c(==) y no @c(<=), se debe a que supongo (remarcando @e(supongo)) que
    @c(==) es mas eficiente que @c(<=), ademas, nunca deberia presentarse un
    caso en el cual la expresion tenga longitud negativa, o no? digo, como un
    miembro de la raza mas desarrollada de este pequeño planeta azul podria
    cometer un error al codificar algo tan sencillo... (¬‿¬)!

    Realizamos un ciclo que recorre la exprecion en busca del operador @c(|) ➏,
    si se encuentra fuera de una agrupacion ➍➎ tenemos nuestra ruta. Recordemos
    que el operador @c[(] abre una agrupacion y @c[)] la cierra, a si mismo una
    agrupacion puede agrupar otras agrupaciones, es decir, existen distintos
    niveles de anidamiento o "profundidad". Nuestra funcion solo se interesa en
    las rutas de primer nivel (@c(deep == 0)).

    Ahora, independientemente del punto donde este (o no) el operador @c(|), la
    seccion (@c(track)) inicia donde inicia la regexp (@c(rexp)), tiene la misma
    longitud (a menos que el ciclo demuestre lo contrario) y se asume que sean
    del mismo tipo (@c(PATH)).

    asi, en lugar de tener

    #+BEGIN_SRC c
      track->ptr  = rexp->ptr;
      track->len  = rexp->len;
      track->type = rexp->type;
    #+END_SRC

    tenemos @c(*track = *rexp) ➋.

    Si encontramos el operador @c(|), se modifica la longitud de la seccion ➐ a
    la vez que se "corta" de la expresion ➐➑, el @c(+ 1) es para descartar el
    signo @c(|), pues una vez optenemos el constructor, este deja de tener
    utilidad.

    #+BEGIN_EXAMPLE
      cutPath llamada uno
      expresion  "ruta1|ruta2|ruta3"
      seccion    "ruta1"
      retono     TRUE

      cutPath llamada dos
      expresion        "ruta2|ruta3"
      seccion          "ruta2"
      retono     TRUE

      cutPath llamada tres
      expresion              "ruta3"
      seccion                "ruta3"
      retono     TRUE

      cutPath llamada cuatro
      expresion                    ""
      seccion
      retono     FALSE
    #+END_EXAMPLE

    como muestra el ejemplo, en la tercer llamada a @c(cutPath), la seccion es
    igual a la expresion. El corte deja el punto de inicio de la exprecion en la
    ultima posicion ➓ con una longitud de cero caracteres ⓫.

*** simple & group

    Al igual que en la seccion anterior el codigo se presenta al inicio. Es
    recomendable que antes de pasar a la explicacion lo analices por tu cuenta,
    identifiques las diferencias con la ultima version e incluso lo modifiques y
    sigas tu propia ruta de desarrollo.

    #+BEGIN_SRC c
      #include <stdio.h>
      #include <string.h>

      #define TRUE  1
      #define FALSE 0

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int walker  ( struct RE  rexp );
      static int trekking( struct RE *rexp );
      static int cutPath ( struct RE *rexp, struct RE *track );
      static int tracker ( struct RE *rexp, struct RE *track );

      static char *strnchr( char *str, int chr, int n );

      unsigned int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.len     = strlen( re );
        rexp.type    = PATH;

        return walker( rexp );
      }

      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker INIT", rexp.len, rexp.ptr );
        while( cutPath( &rexp, &track ) ){
          printf( "%-20s >>%.*s<<\n", "walker PATH", track.len, track.ptr );
          trekking( &track );
        }

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){
          if ( track.type == GROUP  ){
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            walker( track );
          } else if( track.type == SIMPLE ){
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
          }
        }

        return TRUE;
      }

      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;

        for( int i = 0, deep = 0; i < rexp->len; i++ ){
          if( rexp->ptr[ i ] ==  '(' )  deep++;
          if( rexp->ptr[ i ] ==  ')' )  deep--;
          if( rexp->ptr[ i ] ==  '|' && deep == 0 ){
            track->len  = i;
            rexp->ptr  += i + 1;
            rexp->len  -= i + 1;
            return TRUE;
          }
        }

        rexp->ptr += rexp->len;
        rexp->len  = 0;

        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;

        if( rexp->ptr[ 0 ] == '(' ){
          for( int deep = 1, i = 1; i < rexp->len; i++ ){
            if( rexp->ptr[ i ] ==  '(' ) deep++;
            if( rexp->ptr[ i ] ==  ')' ) deep--;

            if( deep == 0 ){
              track->type = GROUP;
              track->ptr++;
              track->len  = rexp->ptr + i - track->ptr;
              rexp->len  -= i + 1;
              rexp->ptr  += i + 1;
              return TRUE;
            }
          }
        }

        track->type = SIMPLE;

        char *point;
        if( (point = strnchr( rexp->ptr, '(', rexp->len )) )
          track->len = point - track->ptr;

        rexp->len  -= track->len;
        rexp->ptr  += track->len;

        return TRUE;
      }

      static char * strnchr( char *str, int chr, int n ){
        for( int i = 0; i < n && str[ i ]; i++ )
          if( str[ i ] == chr ) return str + i;

        return 0;
      }
    #+END_SRC

    compila y ejecuta la prueba nuevamente:

    #+BEGIN_SRC sh
      gcc -Wall test.c && ./a.out
    #+END_SRC

    la expresion @c("ruta1|ruta2|ruta3") produce esta salida

    #+BEGIN_EXAMPLE
      walker   INIT        >>ruta1|ruta2|ruta3<<
      walker   PATH        >>ruta1<<
      trekking SIMPLE      >>ruta1<<
      walker   PATH        >>ruta2<<
      trekking SIMPLE      >>ruta2<<
      walker   PATH        >>ruta3<<
      trekking SIMPLE      >>ruta3<<
    #+END_EXAMPLE

    La diferencia con la version anterior radica en que ahora somos capaces de
    identificar cadenas de caracteres de tipo @c(SIMPLE) (uno o mas
    constructores caracter).

    Veamos el resultado de enviar una prueva con un par de agrupaciones. En el
    fichero @f(test.c) modifica la funcion principal para que diga lo siguiente:

    #+BEGIN_SRC c
      int main(){
        // regexp3( "", "ruta1|ruta2|ruta3" );
        regexp3( "", "a(b|c)|A(B|C)" );
        return 0;
      }
    #+END_SRC

    tras compilar y realizar la prueba, obtenemos:

    #+BEGIN_EXAMPLE
      walker   init        >>a(b|c)|A(B|C)<<
      walker   PATH        >>a(b|c)<<         ➊
      trekking SIMPLE      >>a<<              ➋
      trekking GROUP       >>b|c<<            ➌
      walker   init        >>b|c<<            ➍
      walker   PATH        >>b<<              ➎
      trekking SIMPLE      >>b<<              ➏
      walker   PATH        >>c<<              ➐
      trekking SIMPLE      >>c<<              ➑
      walker   PATH        >>A(B|C)<<         ➒
      trekking SIMPLE      >>A<<
      trekking GROUP       >>B|C<<
      walker   init        >>B|C<<
      walker   PATH        >>B<<
      trekking SIMPLE      >>B<<
      walker   PATH        >>C<<
      trekking SIMPLE      >>C<<
    #+END_EXAMPLE

    lo que el motor esta haciendo es optener la primer ruta de ejecucion
    @c[a(b|c)] ➊, luego se encuentra con el constructor @c(SIMPLE) @c(a) ➋, a
    continuacion optiene la aprupacion @c[(b|c)] ➌ y se envia a @c(walker) ➍ que
    optiene posibles rutas ejecucion ➎➐. Envia las rutas de la agrupacion a
    @c(trekking) y este optiene los constructores caracter correspondientes a
    las rutas @c(b) y @c(c) ➏➑. Esto concluye el recorrido por el primer
    constructor de tipo ruta de @"(primer nivel), ya que el siguiente
    constructor tiene la misma estructura @c[A(B|C)] ➒ las acciones siguen el
    mismo orden.

    Quiza la anterior explicacion no sea suficiente para visualizar el recorrido
    atraves de la expresion, asi que aqui esta la informacion con un formato mas
    explicito (espero):

    #+BEGIN_EXAMPLE
      walker   init        >>a(b|c)|A(B|C)<<   ┌──▶ walker inicial
      walker   PATH        >>a(b|c)<<          ├─┬▶ walker primer ruta
      trekking SIMPLE      >>a<<               │ ├──> primer constructor : caracter
      trekking GROUP         >>b|c<<           │ └─┬> segundo constructor: agrupacion
      walker   init          >>b|c<<           │   ├──▶ walker recursivo
      walker   PATH          >>b<<             │   ├─┬▶ walker primer ruta
      trekking SIMPLE        >>b<<             │   │ └──> primer constructor : caracter
      walker   PATH            >>c<<           │   └─┬▶ walker segunda ruta
      trekking SIMPLE          >>c<<           │     └──> primer constructor : caracter
      walker   PATH               >>A(B|C)<<   └─┬▶ walker segunda ruta
      trekking SIMPLE             >>A<<          ├──> primer constructor : caracter
      trekking GROUP                >>B|C<<      └─┬> segundo constructor: agrupacion
      walker   init                 >>B|C<<        ├──▶ walker recursivo
      walker   PATH                 >>B<<          ├─┬▶ walker primer ruta
      trekking SIMPLE               >>B<<          │ └──> primer constructor : caracter
      walker   PATH                   >>C<<        └─┬▶ walker segunda ruta
      trekking SIMPLE                 >>C<<          └──> primer constructor : caracter
    #+END_EXAMPLE

    apliquemos una prueba distinta

    #+BEGIN_SRC c
      int main(){
        regexp3( "(a(b|c)|A(B|C))|1234(ea|eb|ec)" );

        return 0;
      }
    #+END_SRC

    optenemos

    #+BEGIN_EXAMPLE
      walker   init        >>(a(b|c)|A(B|C))|1234(ea|eb|ec)<<    ┌──▶ walker inicial
      walker   PATH        >>(a(b|c)|A(B|C))<<                   ├─┬▶ walker primer ruta
      trekking GROUP        >>a(b|c)|A(B|C)<<                    │ └─┬> primer constructor: agrupacion
      walker   init         >>a(b|c)|A(B|C)<<                    │   ├──▶ walker recursivo
      walker   PATH         >>a(b|c)<<                           │   ├─┬▶ walker primer ruta
      trekking SIMPLE       >>a<<                                │   │ ├──> primer constructor : caracter
      trekking GROUP          >>b|c<<                            │   │ └─┬> segundo constructor: agrupacion
      walker   init           >>b|c<<                            │   │   ├──▶ walker recursivo
      walker   PATH           >>b<<                              │   │   ├─┬▶ walker primer ruta
      trekking SIMPLE         >>b<<                              │   │   │ └──> primer constructor : caracter
      walker   PATH             >>c<<                            │   │   └─┬▶ walker segunda ruta
      trekking SIMPLE           >>c<<                            │   │     └──> primer constructor : caracter
      walker   PATH                >>A(B|C)<<                    │   └─┬▶ walker segunda ruta
      trekking SIMPLE              >>A<<                         │     ├──> primer constructor : caracter
      trekking GROUP                 >>B|C<<                     │     └─┬> segundo constructor: agrupacion
      walker   init                  >>B|C<<                     │       ├──▶ walker recursivo
      walker   PATH                  >>B<<                       │       ├─┬▶ walker primer ruta
      trekking SIMPLE                >>B<<                       │       │ └──> primer constructor : caracter
      walker   PATH                    >>C<<                     │       └─┬▶ walker segunda ruta
      trekking SIMPLE                  >>C<<                     │         └──> primer constructor : caracter
      walker   PATH                        >>1234(ea|eb|ec)<<    └─┬▶ walker segunda ruta
      trekking SIMPLE                      >>1234<<                ├──> primer constructor : caracter
      trekking GROUP                            >>ea|eb|ec<<       └─┬> segundo constructor: agrupacion
      walker   init                             >>ea|eb|ec<<         ├──▶ walker recursivo
      walker   PATH                             >>ea<<               ├─┬▶ walker primer ruta
      trekking SIMPLE                           >>ea<<               │ └──> primer constructor : caracter
      walker   PATH                                >>eb<<            ├─┬▶ walker segunda ruta
      trekking SIMPLE                              >>eb<<            │ └──> primer constructor : caracter
      walker   PATH                                   >>ec<<         └─┬▶ walker tercer ruta
      trekking SIMPLE                                 >>ec<<           └──> primer constructor : caracter
    #+END_EXAMPLE

    @e(Magnifico), un poco de codigo y algo de recursividad parecen poder
    reducir cualquier exprecion con tres tipos distintos de constructores:
    rutas, agrupaciones y carateres. Ejecuta algunas pruebas mas, por ejemplo:

    #+BEGIN_SRC c
      regexp3( "", "((a(b|c)|A(B|C))|1234(ea|eb|ec))|PATH2|PATH3|(((a(b|c)|A(B|C))|1234(ea|eb|ec))|PATH4B)|PATH5" );
    #+END_SRC

    no olvides que el motor espera que la sintaxis sea correcta, especialmente
    para las agrupaciones, los operadores de apertura y cierre @c[(] y @c[)]
    deben estar emparejados en el orden correcto.

    Sin mas demora e ignorando los nuevos prototipos de funcion, el primer
    cambio ocurre en @c(walker)

    #+BEGIN_SRC c
      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   INIT", rexp.len, rexp.ptr );
        while( cutPath( &rexp, &track ) ){
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          trekking( &track );  ➊
        }

        return FALSE;
      }
    #+END_SRC

    ahora cada ruta se envia a @c(trekking) ➊ con la mision de averiguar si la
    ruta se encuentra o no, apartir de la posicion actual de la cadena.

    #+BEGIN_SRC c
      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){     // ➊
          if ( track.type == GROUP  ){        // ➋
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );  // ➌
            walker( track );                  // ➍
          } else if( track.type == SIMPLE ){  // ➎
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr ); // ➏
          }
        }

        return TRUE;                          // ➐
      }
    #+END_SRC

    @c(trekking) puede resumirse de esta forma:

    1. se resive una ruta de ejecucion,
    2. se optienen y evalunan los constructores de la ruta ➊
    3. si todos los constructores coinciden, significa que la ruta coincide
       @c(TRUE) ➐.

    Cuando el constructor optenido es de tipo agrupacion (@c(GROUP)) ➋ lo
    enviamos a @c(walker) ➌, pues existe la posibilidad de que la agrupacion
    contenga un constructor tipo @c(PATH).

    Cuando el constructor optenido es de tipo caracter (@c(SIMPLE)) ➎ se puede
    evaluar directamente si coincide o no con la cadena, cosa que haremos mas
    adelante, mientras tanto es suficiente con desplegar el contenido y tipo de
    ambos segmentos ➍➏.

    Si examinas @c(trekking), podras ver que sigue el mismo esquema que
    @c(walker):

    #+BEGIN_SRC c
      retorno funcion( struct RE rexp ){
        struct RE track;

        while( cortarRexpAlmacetarEnTrack( &rexp, &track ){
          // acciones
        }

        return retorno;
      }
    #+END_SRC

    con dos pequeñas diferencias:

    - En @c(trekking) la expresion coincide si todos los constructores
      coinciden, mientras que en @c(walker) la expresion no coincide si ningun
      constructor coincide.

    - En @c(trekking) la expresion (@c(rexp)) es un puntero de la estructura
      @c(RE), en @c(walker) la expresion es una copia.


    Ademas, seguimos este esquema por varios y convenientes motivos:

    1. Para opteren los elementos de una expresion, lo minimo necesario, es: la
       expresion (@c(rexp)), el codigo que extraiga los elementos en orden
       (bucle y funcion) y un contenedor para almacenar el elemento en turno
       (@c(track)).

    2. Cuando llamamos a una funcion, podemos considerar a sus parametros como
       memoria @q(gratuita) libre de gestion, es decir, no necesitamos hacer una
       peticion explicita de memoria, como tampoco encargarnos de su liberacion.

       Este hecho es particularmente relevante cuando la solucion se implementa
       de manera recursiva, ya que dispondremos de tantas instancias de una
       variable como sean necesarias... mientras el hardware aguante, claro
       esta.

    3. Interpretamos la regexp como una sucesion de elementos, que contienen (o
       no) otros elementos. Sumar esta aproximacion, al primer y segundo punto,
       mas la forma de la funcion, es practicamente una invitacion para
       implementar el codigo de forma recursiva.


    (⌐□ل͜□) Desde luego, todo es tannn evidente... Nop, siendo honesto, solo lo
    fue tras un monton de pruebas y cambios, supongo que un libro es analogo a
    una pelicula o un album de musica, pues, detras del resultado final hay
    mucho material descartado, solo la mejor toma ve la luz. Si encuentras este
    material un producto de serie @e(b) o @e(z) imagina lo malo que es el
    borrador.

    Continuemos con el codigo. @c(trekking) utiliza una funcion auxiliar llamada
    @c(tracker) para cortar el constructor mas a la izquierda de la exprecion
    @c(rexp) y almacenarlo dentro de @c(track)

    #+BEGIN_SRC c
      static int tracker( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;  // 🅐

        *track = *rexp;                     // 🅑

        if( rexp->ptr[ 0 ] == '(' ){        // 🅒
          for( int deep = 1, i = 1; i < rexp->len; i++ ){    // 🅓
            if( rexp->ptr[ i ] ==  '(' ) deep++;
            if( rexp->ptr[ i ] ==  ')' ) deep--;

            if( deep == 0 ){                // 🅔
              track->type = GROUP;          // 🅕
              track->ptr++;                 // 🅖
              track->len  = rexp->ptr + i - track->ptr;      // 🅗
              rexp->len  -= i + 1;          // 🅘
              rexp->ptr  += i + 1;          // 🅙
              return TRUE;                  // 🅚
            }
          }
        }

        track->type = SIMPLE;               // 🅛

        char *point;
        if( (point = strnchr( rexp->ptr, '(', rexp->len )) ) // 🅜
          track->len = point - track->ptr;  // 🅝

        rexp->len  -= track->len;           // 🅞
        rexp->ptr  += track->len;           // 🅟

        return TRUE;                        // 🅠
      }
    #+END_SRC

    La funcion inicia comprobando si aun hay algo que cortar 🅐, si no es asi
    regresamos @c(FALSE).

    Luego hacemos una copia del contenido de @c(rexp) en @c(track) 🅑. El
    segmento a optener (en este momento) solo puede ser de tipo @c(GROUP) 🅕 o
    @c(SIMPLE) 🅚.

    En el primer caso, si la exprecion inicia con el operador @c[(] 🅒 realizamos
    un recorrido atraves de la expresion 🅓 hasta localizar el operador de cierre
    @c[)] correspondiente 🅔, asignamos el tipo @c(GROUP) 🅕, establecemos la
    longitud del segmento 🅖🅗, cortamos la expresion dejando la posicion de
    inicio luego del operador de cierre 🅘🅙 (el +1) y finalmente regeresamos
    @c(TRUE) 🅚.

    Habras notado que en 🅖 se realiza un @c(++) antes de opteren la longitud del
    segmento, su cometido es eliminar el operador de apertura @c[(] del
    segmento, por su parte, la operacion 🅗 tambien descarta el operador de
    cierre @c[)].

    En el segundo caso, si no no encontramos un operador de interes al inicio de
    la expresion, significa que el constructor mas a la izquierda es de tipo
    caracter 🅛. En esta situacion debemos averiguar la longitud del segmento 🅝,
    es decir, realizar una busqueda atraves de la expresion intentando encontrar
    un operador que señale el inicio de un constructor distinto 🅜. Una ves
    establecida la longitud del segmento, esta debe restarse de la longitud de
    la expresion 🅞🅟, finalmente regresamos @c(TRUE) 🅠.

    Observa que para este caso, si no se encuentra ningun operador, el segmento
    @c(track) tendra la misma longitud que la expresion (punto 🅑).

    Por cierto, hace falta explicar la funcion @c(strnchr). La libreria estandar
    @c(<string.h>) incluye una funcion llamada @c(strchr) su labor es localizar
    la primer ocurrencia de un caracter dentro de una cadena de caracteres y
    regresar un puntero con su ubicacion. No es conveniente utilizar @c(strchr)
    puesto que necesitamos mantener un rango de busqueda limitado a los @m(n)
    caracteres que corresponden a la longitud de nuestra expresion. Ya que en la
    libreria estandar no hay una funcion que realice lo que desamos,
    implementamos nuestra propia version.

    Visualmente nuestro codigo (quiza) seria asi:

    #+BEGIN_EXAMPLE
      ┏━━━━━━━━━━━┓                   ▸ regexp llama a walker.
      ┃           ┃
      ┃  regexp3  ┃                   ▸ walker optiene las rutas y las envia a trekking
      ┃           ┃
      ┗━━━━━━━━━━━┛                   ▸ trekking optiene los constructores
         ┃  ▲      GROUP                - si el tipo es GROUP lo envia a walker
         ┃  ┃  ┏━━━━━━━━━━━━┓           - si el tipo es SIMPLE no hay nada mas que hacer
         ▼  ┃  ▼            ┃
      ┏━━━━━━━━━━━┓   ┏━━━━━━━━━━━┓
      ┃           ┃◀━━┃           ┃
      ┃  walker   ┃   ┃ trekking  ┃━━▶ SIMPLE
      ┃           ┃━━▶┃           ┃
      ┗━━━━━━━━━━━┛   ┗━━━━━━━━━━━┛
    #+END_EXAMPLE

    ( ͡° ͜ʖ ͡°)ง? y si dentro de una agrupacion no existieran rutas seria posible
    que @c(trekking) presindiera de la llamada a @c(walker)?

    Exelente pregunta, en tal caso @c(trekking) podria hacerse cargo de optener
    los constructores dentro de la agrupacion de forma recursiva y el resultado
    seguiria siendo correcto, es mas si no existiese ninguna ruta @c(regexp3)
    podria consultar directamente a @c(trekking) sin pasar por @c(walker) pero
    tendriamos que implementar una nueva funcion, ehhmm, por ejemplo llamada
    @c(isPath) para poder averiguar si en la expresion existen rutas o no.

    Visualmente seria algo asi:

    #+BEGIN_EXAMPLE
      ┏━━━━━━━━━━━┓    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      ┃           ┃    ▼    ┏━━━━━━━━━━━┓  no            ┃
      ┃  regexp3  ┃━━━━━━━━▶┃  isPath   ┃━━━━━┓          ┃
      ┃           ┃         ┗━━━━━━━━━━━┛     ┃          ┃
      ┗━━━━━━━━━━━┛               ┃ yes       ┃          ┃
         ▲     ▲                  ┃           ┃          ┃
         ┃     ┃                  ▼           ┃          ┃
         ┃     ┃             ┏━━━━━━━━━━━┓    ▼    ┏━━━━━━━━━━━┓
         ┃     ┃             ┃           ┃━━━━━━━━▶┃           ┃
         ┃     ┗━━━━━━━━━━━━━┃  walker   ┃         ┃ trekking  ┃━━▶ SIMPLE
         ┃                   ┃           ┃◀━━━┳━━━━┃           ┃
         ┃                   ┗━━━━━━━━━━━┛    ┃    ┗━━━━━━━━━━━┛
         ┃                                    ┃
         ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    #+END_EXAMPLE

    @c(isPath) seria asi

    #+BEGIN_SRC c
      static int isPath( struct RE *rexp ){
        for( int i = 0, deep = 0; i < rexp->len; i++ )
          switch( rexp->ptr[i] ){
          case '(': deep++; break;
          case ')': deep--; break;
          case '|': if( deep == 0 ) return TRUE;
          }

        return FALSE;
      }
    #+END_SRC

    en esencia es una version reducida de la actual @c(walker). Si seguimos este
    esquema cuando existan 2 o mas rutas tendremos que hacer una llamada
    adicional (primero a @c(isPath) y luego a @c(walker)), sin mencionar que
    incementaria la complejidad/cantidad de codigo para resolver un problema ya
    resuelto. La unica razon para seguir este esquema es generar un registro
    eficiente del orden de evaluacion de los constructores, pero eso, mi
    estimado lector, sera implementado en la ultima seccion del libro.

*** hook

    Nuestro motor tendra la capacidad de almacenar el patron que se corresponda
    con el contenido de una agrupacion, sin embargo, en muchos (si no es que en
    la mayoria de los) casos, no se desea que el motor genere una captura cada
    vez que aparece una agrupacion. Por ello crearemos una variante del
    constructor @c(GROUP) de nombre @c(HOOK) (anzuelo).

    El "nuevo" costructor es identico en comportamiento y estructura a
    una agrupacion, con dos ligeras deferencias

    1. utilizaremos los operadores los @c(<) y @c(>) en lugar de @c[(] y @c[)]

    2. servira para indicarle explicitamente al motor que deseamos generar una
       captura.


    En esta seccion no implementaremos la funcionalidad de captura, nos
    limitaremos a agregar el codigo necesario para que el motor pueda
    identificar el nuevo constructor.

    #+BEGIN_SRC c
      #include <stdio.h>
      #include <string.h>

      #define TRUE  1
      #define FALSE 0

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
      };

      static int walker  ( struct RE  rexp );
      static int trekking( struct RE *rexp );
      static int cutPath ( struct RE *rexp, struct RE *track );
      static int tracker ( struct RE *rexp, struct RE *track );

      static char * trackerPoint( char *points, char *track, int len );

      unsigned int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.len     = strlen( re );
        rexp.type    = PATH;

        return walker( rexp );
      }

      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   INIT", rexp.len, rexp.ptr );
        while( cutPath( &rexp, &track ) ){
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          trekking( &track );
        }

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){
          if ( track.type == GROUP  ){
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            walker( track );
          } else if ( track.type == HOOK  ){
            printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
            walker( track );
          } else if( track.type == SIMPLE ){
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
          }
        }

        return TRUE;
      }

      static int cutPath( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;

        for( int i = 0, deep = 0; i < rexp->len; i++ ){
          switch( rexp->ptr[ i ] ){
          case '(': case '<': deep++; break;
          case ')': case '>': deep--; break;
          }

          if( rexp->ptr[ i ] ==  '|' && deep == 0 ){
            track->len  = i;
            rexp->ptr  += i + 1;
            rexp->len  -= i + 1;
            return TRUE;
          }
        }

        rexp->ptr += rexp->len;
        rexp->len  = 0;

        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;

        if( rexp->ptr[ 0 ] == '(' ){
          for( int deep = 1, i = 1; i < rexp->len; i++ ){
            if( rexp->ptr[ i ] ==  '(' ) deep++;
            if( rexp->ptr[ i ] ==  ')' ) deep--;

            if( deep == 0 ){
              track->type = GROUP;
              track->ptr++;
              track->len  = rexp->ptr + i - track->ptr;
              rexp->len  -= i + 1;
              rexp->ptr  += i + 1;
              return TRUE;
            }
          }
        } else if( rexp->ptr[ 0 ] == '<' ){
          for( int deep = 1, i = 1; i < rexp->len; i++ ){
            if( rexp->ptr[ i ] ==  '<' ) deep++;
            if( rexp->ptr[ i ] ==  '>' ) deep--;

            if( deep == 0 ){
              track->type = HOOK;
              track->ptr++;
              track->len  = rexp->ptr + i - track->ptr;
              rexp->len  -= i + 1;
              rexp->ptr  += i + 1;
              return TRUE;
            }
          }
        }

        track->type = SIMPLE;

        char *point;
        if( (point = trackerPoint( "(<", rexp->ptr + 1, rexp->len - 1 )) )
          track->len = point - track->ptr;

        rexp->len  -= track->len;
        rexp->ptr  += track->len;

        return TRUE;
      }

      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }
    #+END_SRC

    es necesario comprobar que el codigo no altere el comportamiento en la(?)
    prueba que ya tenemos

    #+BEGIN_SRC c
      regexp3( "", "a(b|c)|A(B|C)" );
    #+END_SRC

    compila y verifica que no haya cambios... bien? Ahora intenta con

    #+BEGIN_SRC c
      regexp3( "", "<a(b|c)|A(B|C)>|1234(ea|eb|ec)" );
    #+END_SRC

    a que funciona! Aqui el resultado (con ligeras modificaciones)

    #+BEGIN_EXAMPLE
      walker   init        >><a(b|c)|A(B|C)>|1234(ea|eb|ec)<<    ┌──▶ walker inicial
      walker   PATH        >><a(b|c)|A(B|C)><<                   ├─┬▶ walker primer ruta
      trekking HOOK         >>a(b|c)|A(B|C)<<                    │ └─┬> primer constructor: captura
      walker   init         >>a(b|c)|A(B|C)<<                    │   ├──▶ walker recursivo
      walker   PATH         >>a(b|c)<<                           │   ├─┬▶ walker primer ruta
      trekking SIMPLE       >>a<<                                │   │ ├──> primer constructor : caracter
      trekking GROUP          >>b|c<<                            │   │ └─┬> segundo constructor: agrupacion
      walker   init           >>b|c<<                            │   │   ├──▶ walker recursivo
      walker   PATH           >>b<<                              │   │   ├─┬▶ walker primer ruta
      trekking SIMPLE         >>b<<                              │   │   │ └──> optiene el constructor
      walker   PATH             >>c<<                            │   │   └─┬▶ walker segunda ruta
      trekking SIMPLE           >>c<<                            │   │     └──> optiene el constructor
      walker   PATH                >>A(B|C)<<                    │   └─┬▶ walker segunda ruta
      trekking SIMPLE              >>A<<                         │     ├──> primer constructor : caracter
      trekking GROUP                 >>B|C<<                     │     └─┬> segundo constructor: agrupacion
      walker   init                  >>B|C<<                     │       ├──▶ walker recursivo
      walker   PATH                  >>B<<                       │       ├─┬▶ walker primer ruta
      trekking SIMPLE                >>B<<                       │       │ └──> optiene el constructor
      walker   PATH                    >>C<<                     │       └─┬▶ walker segunda ruta
      trekking SIMPLE                  >>C<<                     │         └──> optiene el constructor
      walker   PATH                        >>1234(ea|eb|ec)<<    └─┬▶ walker segunda ruta
      trekking SIMPLE                      >>1234<<                ├──> primer constructor : caracter
      trekking GROUP                            >>ea|eb|ec<<       └─┬> segundo constructor: agrupacion
      walker   init                             >>ea|eb|ec<<         ├──▶ walker recursivo
      walker   PATH                             >>ea<<               ├─┬▶ walker primer ruta
      trekking SIMPLE                           >>ea<<               │ └──> optiene el constructor
      walker   PATH                                >>eb<<            ├─┬▶ walker segunda ruta
      trekking SIMPLE                              >>eb<<            │ └──> optiene el constructor
      walker   PATH                                   >>ec<<         └─┬▶ walker tercer ruta
      trekking SIMPLE                                 >>ec<<           └──> optiene el constructor
    #+END_EXAMPLE

    Vamos pues a examinar el codigo.

    El primer y poco interesante cambio se encuentra en @c(trekking), donde
    agregamos una condicion adicional para evaluar al nuevo constructor. Puedes
    ver que el codigo es identico al de la condicion @c(GROUP), solamente se a
    adaptado el mensaje de salida.

    Algo mas estimulante sucende en @c(cutTrack) dentro del bucle @c(for)

    #+BEGIN_SRC c
      for( int i = 0, deep = 0; i < rexp->len; i++ ){
        switch( rexp->ptr[ i ] ){
        case '(': case '<': deep++; break;
        case ')': case '>': deep--; break;
        }

        if( rexp->ptr[ i ] ==  '|' && deep == 0 ){
          track->len  = i;
          rexp->ptr  += i + 1;
          rexp->len  -= i + 1;
          return TRUE;
        }
      }
    #+END_SRC

    En la version anterior, teniamos una secuencia de @c(if)s para averiguar si
    estabamos o no dentro de una agrupacion, en cambio, ahora tenemos un solo
    @c(switch) que realiza la misma funcion en lugar de tener cuatro
    instrucciones @c(if) o @c(if)-@c(else), por ejemplo:

    #+BEGIN_SRC c
      if( rexp->ptr[ i ] == '(' ) deep++;
      if( rexp->ptr[ i ] == '<' ) deep++;
      if( rexp->ptr[ i ] == ')' ) deep--;
      if( rexp->ptr[ i ] == '>' ) deep--;
    #+END_SRC

    o

    #+BEGIN_SRC c
      if( rexp->ptr[ i ] == '(' ) deep++;
      else if( rexp->ptr[ i ] == '<' ) deep++;
      else if( rexp->ptr[ i ] == ')' ) deep--;
      else if( rexp->ptr[ i ] == '>' ) deep--;
    #+END_SRC

    Cuando se necesita evaluar el contenido de una variable y actuar segun casos
    especificos, un @c(switch) no solo es mas compacto y agradable a la vista,
    ademas es mas veloz. Dentro de un switch se realiza una sola evaluacion y
    luego se @e(salta) al caso, es decir el tiempo para realizar un switch es
    independiente del numero de casos (o eso dicen [[https://elbauldelprogramador.com/por-que-un-switch-es-mas-rapido-que-su-homologo-if-then-else/][aqui]])

    Siguendo el flujo de modificaciones llegamos a @c(tracker). La estrategia es
    la misma que en @c(trekking), copiar el codigo para @c(GROUP), ponerlo en la
    secuencia @c(if)-@c(else) y modificar operadores y tipo, en fin, nada
    nuevo...  ¡alto! El nuevo constructor trae con sigo nuevos operadores a
    identificar, tanto al inicio de su constructor, como al final de un segmento
    de tipo @c(SIMPLE).

    Podemos afrontar la nueva situacion con @c(strnchr) + una nueva variable +
    un par de @c(if)s, o modificar la funcion y darle un nombre mas adecuado:
    @c(trackerPoint).

    #+BEGIN_SRC c
      static char * trackerPoint( char *points, char *track, int len ){
        for( int pos = 0; pos < len; pos++ )
          if( strchr( points, track[ pos ] ) ) return track + pos;

        return 0;
      }
    #+END_SRC

    A diferencia de @c(strnchr), @c(trackerPoint) no se limita a la busqueda de
    solo un caracter, la nueva funcion realiza la busqueda de un conjunto de
    caracteres (en forma de cadena de caracteres).

    @c(points) es el conjuto de puntos (caracteres) a rastrear, @c(track) es la
    region donde se realiza la busqueda y @c(len) la longitud de la region. La
    funcion regresa la posicion de la primer coincidencia o un puntero nulo.

    esto es lo que hace

    - un bucle recorre la region (@c(track)) caracter a caracter,

    - con @c(strchr) buscamos el caracter en la cadena de rastreo
      (@c(points))

    - si hay coincidencia regresamos la posicion actual de la cadena.

    - si termina el ciclo regeresamos un puntero nulo.

**** Refactorizacion

     Dentro de @c(tracker), es posible identificar la sintaxis de todos los
     constructores, empleando instrucciones @c(if)-@c(else if)-@c(else
     if)-...-@c(else), simpre y cuando, tener un monton de codigo duplicado en
     una funcion obesa no genere ningun transtorno mental en nuestro ser.

     si vamos a @c(tracker) podemos ver que

     #+BEGIN_SRC c
       if( rexp->ptr[ i ] ==  '(' ) deep++;
       if( rexp->ptr[ i ] ==  ')' ) deep--;

       if( deep == 0 ){
         track->type = GROUP;
         track->ptr++;
         track->len  = rexp->ptr + i - track->ptr;
         rexp->len  -= i + 1;
         rexp->ptr  += i + 1;
         return TRUE;
       }
     #+END_SRC

     es casi identico a

     #+BEGIN_SRC c
       if( rexp->ptr[ i ] ==  '<' ) deep++;
       if( rexp->ptr[ i ] ==  '>' ) deep--;

       if( deep == 0 ){
         track->type = HOOK;
         track->ptr++;
         track->len  = rexp->ptr + i - track->ptr;
         rexp->len  -= i + 1;
         rexp->ptr  += i + 1;
         return TRUE;
       }
     #+END_SRC

     y similar a

     #+BEGIN_SRC c
       switch( rexp->ptr[ i ] ){
       case '(': case '<': deep++; break;
       case ')': case '>': deep--; break;
       }

       if( rexp->ptr[ i ] ==  '|' && deep == 0 ){
         track->len  = i;
         rexp->ptr  += i + 1;
         rexp->len  -= i + 1;
         return TRUE;
       }
     #+END_SRC

     en @c(cutPath).

     Tambien se repiten muchas lineas para "recorrer" el contenido de una
     expresion:

     #+BEGIN_SRC c
       rexp->ptr  += len;
       rexp->len  -= len;
     #+END_SRC

     ('̀-'́)ง Si funciona por que eliminar el codigo duplicado?

     Segun los gurus:

     - mas codigo son mas instrucciones a entender, no para nosotros, si para
       quien intente averiguar que es lo que estamos haciendo.

     - mas codigo expone al programa a mas puntos de fallo, mas puntos de fallo
       requieren mas pruebas, mas pruebas requieren mas trabajo, mas trabajo
       conduce al lado obscuro

     - cualquier modificacion ha de hacerse tantas ocaciones como duplicados
       existan

     - mayor esfuerzo para mantener coherentes las duplicidades.

     - cuanto mas grande es una funcion mas costosa es su ejecucion, en el caso
       de nuestro motor que se basa en recursividad el costo es aun mayor


     ┬┴┬┴┤ (ಠ├┬┴┬┴ debo ser honesto, eliminar el codigo duplicado fue una labor
     en la que tarde mas de un mes... Intenta resolver el problema por tu
     cuenta, despues comparalo con mi solucion:

     #+BEGIN_SRC c
       #include <stdio.h>
       #include <string.h>

       #define TRUE  1
       #define FALSE 0

       enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

       struct RE {
         char     *ptr;
         int       len;
         enum TYPE type;
       };

       static int  walker     ( struct RE  rexp );
       static int  trekking   ( struct RE *rexp );
       static int  tracker    ( struct RE *rexp, struct RE *track );
       static int  trackByType( struct RE *rexp, struct RE *track, int type );
       static void trackByLen ( struct RE *rexp, struct RE *track, int len, int type );
       static void fwrRexp    ( struct RE *rexp, int len );

       unsigned int regexp3( char *txt, char *re ){
         struct RE    rexp;
         rexp.ptr     = re;
         rexp.len     = strlen( re );
         rexp.type    = PATH;

         return walker( rexp );
       }

       static int walker( struct RE rexp ){
         struct RE track;

         printf( "%-20s >>%.*s<<\n", "walker   INIT", rexp.len, rexp.ptr );
         while( trackByType( &rexp, &track, PATH ) ){
           printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
           trekking( &track );
         }

         return FALSE;
       }

       static int trekking( struct RE *rexp ){
         struct RE track;

         while( tracker( rexp, &track ) ){
           switch( track.type ){
           case GROUP:
             printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
             walker( track );
             break;
           case HOOK :
             printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
             walker( track );
             break;
           default   :
             printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
           }
         }

         return TRUE;
       }

       static int trackByType( struct RE *rexp, struct RE *track, int type ){
         if( rexp->len == 0 ) return FALSE;

         *track = *rexp;
         track->type = type;

         for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
           switch( rexp->ptr[ i ] ){
           case '(': case '<': deep++; break;
           case ')': case '>': deep--; break;
           }

           switch( type ){
           case HOOK    : cut = deep == 0; break;
           case GROUP   : cut = deep == 0; break;
           case PATH    : cut = deep == 0 && rexp->ptr[i] == '|'; break;
           }

           if( cut ){
             track->len  = i;
             fwrRexp( rexp, i + 1 );
             if( type != PATH ) fwrRexp( track, 1 );
             return TRUE;
           }
         }

         fwrRexp( rexp, rexp->len );
         return TRUE;
       }

       static int tracker( struct RE *rexp, struct RE *track ){
         if( rexp->len == 0 ) return FALSE;

         switch( *rexp->ptr ){
         case '(': trackByType( rexp, track, GROUP ); break;
         case '<': trackByType( rexp, track, HOOK  ); break;
         default :
           for( int i = 1; i < rexp->len; i++ )
             switch( rexp->ptr[ i ] ){
             case '(': case '<':
               trackByLen( rexp, track, i, SIMPLE  ); return TRUE;
             }

           trackByLen( rexp, track, rexp->len, SIMPLE  );
         }

         return TRUE;
       }

       static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
         *track       = *rexp;
         track->type  = type;
         track->len   = len;
         fwrRexp( rexp, len );
       }

       static void fwrRexp( struct RE *rexp, int len ){
         rexp->ptr += len; rexp->len -= len;
       }
     #+END_SRC

     @c(cutPath) y el codigo duplicado en @c(tracker) se agruparon en una nueva
     funcion llamada @c(trackByType):

     #+BEGIN_SRC c
       static int trackByType( struct RE *rexp, struct RE *track, int type ){
         if( rexp->len == 0 ) return FALSE;            // ➊

         *track = *rexp;                               // ➋
         track->type = type;                           // ➌

         for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
           switch( rexp->ptr[ i ] ){                   // ➍
           case '(': case '<': deep++; break;
           case ')': case '>': deep--; break;
           }

           switch( type ){                             // ➎
           case HOOK    : cut = deep == 0; break;
           case GROUP   : cut = deep == 0; break;
           case PATH    : cut = deep == 0 && rexp->ptr[i] == '|'; break;
           }

           if( cut ){                                  // ➏
             track->len = i;                           // ➐
             fwrRexp( rexp, i + 1 );                   // ➑
             if( type != PATH ) fwrRexp( track, 1 );   // ➒
             return TRUE;
           }
         }

         fwrRexp( rexp, rexp->len );                   // ➓
         return TRUE;
       }
     #+END_SRC

     La funcion inicia de forma habitual, comprobando si la exprecion (no) esta
     vacia ➊.

     Se copia el contenido de la exprecion dentro de la seccion ➋ y se modifica
     el tipo del constructor ➌.

     Luego, inicia el recorrido atraves de la exprecion. Con ayuda de un
     @c(switch) ➍ examinamos el contenido de la posicion actual, en busca de
     operadores de agrupacion (con o sin captura) para conocer el nivel de
     anidamiento, segun el operador, se incrementa o decrementa el nivel de
     anidamiento.

     A continuacion con otro @c(switch) ➎ establecemos el valor de la variable
     @c(cut), su mision es servir de señal para realizar o no el corte de la
     seccion ➏. Asignamos el valor de @c(cut) mediente evaluaciones booleanas
     que dependen del tipo de corte, hasta ahora: @c(HOOK), @c(GROUP) y
     @c(PATH). En los primeros dos casos el corte se realiza cuando el nivel de
     anidamiento es igual a cero, en el caso de ser un corte tipo @c(PATH)
     ademas debemos estar sobre el operador @c(|).

     Si el corte ➏ se lleva a cabo, establecemos la longitud de la seccion ➐,
     que abarca desda la posicion 0 hasta el caracter previo a la posicion
     actual.

     Echando mano de una nueva funcion de nombre @c(fwrRexp) ➑ @e(recorremos) la
     posicion de inicio de la expresion. @c(fwrRexp) substituye las sentencias

     #+BEGIN_SRC c
       rexp->ptr  += rexp->len;
       rexp->len  -= rexp->len;
     #+END_SRC

     resive como parametros un puntero a la estructura @c(RE) y el numero de
     posiciones que vamos a @e(recorrer) el punto de inicio

     #+BEGIN_SRC c
       static void fwrRexp( struct RE *track, int len ){
         track->ptr += len; track->len -= len;
       }
     #+END_SRC

     de esta manera la sencencia @c[fwrRexp( rexp, i + 1 );] ➑, significa que
     recorremos el contenido de @c(rexp) en @c(i + 1) posiciones. El @c(+1) es
     para descartar el operador actual (@c[)], @c(>) o @c(|)) en la siguiente
     llamada a @c(cutByType).

     Tambiene tenemos una evaluacion que mueve el punto de inicio de la seccion
     @c(track) una posicion si el tipo de corte no es de tipo @c(PATH). Asi
     descartamos el operador de apertura de los cortes @c(HOOK) y @c(GROUP)

     visualmente esto es lo que ocurre en cortes de tipo @c(PATH)

     #+BEGIN_EXAMPLE
       ab(cdefghijklmnopqrstuv)|AB(CDEFGHIJKLMNOPQRSTUV)  ==> contenido en rexp
       ▲                      ▲ ▲                      ▲
       ┃   zona de interez    ┃ ┃   zona de interez    ┃
       ┃  contenido en track  ┃ ┃  contenido en track  ┃
       ┗━━━━━━━━━━━━━━━━━━━━━━┛ ┗━━━━━━━━━━━━━━━━━━━━━━┛
                               ▲▲
                              ┏┛┗━┓
                              ┃   ┃
                              i + 1
                                AB(CDEFGHIJKLMNOPQRSTUV)  ==> nuevo contenido en rexp
     #+END_EXAMPLE

     y esto en cortes de tipo agrupacion

     #+BEGIN_EXAMPLE
       (cdefghijklmnopqrstuv)...
       ▲▲                  ▲▲▲
       ┃┃ zona de interez  ┃┃┃
       ┃┃contenido en track┃┃┃
       ┃┗━━━━━━━━━━━━━━━━━━┛┃┗━━┓
       ┃▲                   i + 1 se descarta el signo de cierre
       ┃┃
       ┃┗━━┓ se descarta el signo de inicio
       0 + 1 == fwrRexp( track, 1 )
     #+END_EXAMPLE

     Cuando el bucle atravez de la exprecion concluye sin realizar ningun corte,
     la secccion @c(track) abarca todo la regexp @c(rexp) y la regexp queda
     vacia ➓.

     pasamos a los cambios en @c(trekking)

     #+BEGIN_SRC c
       static int trekking( struct RE *rexp ){
         struct RE track;

         while( tracker( rexp, &track ) ){
           switch( track.type ){
           case GROUP:
             printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
             walker( track );
             break;
           case HOOK :
             printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
             walker( track );
             break;
           default   :
             printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
           }
         }

         return TRUE;
       }
     #+END_SRC

     ehh, no hay mucha diferencia, pasamos de @c(if)s en serie a un @c(switch)
     con casos. El cambio mas interesante esta en su funcion auxiliar
     @c(tracker)

     #+BEGIN_SRC c
       static int tracker( struct RE *rexp, struct RE *track ){
         if( rexp->len == 0 ) return FALSE;

         switch( *rexp->ptr ){                                     // ➊
         case '(': trackByType( rexp, track, GROUP ); break;       // ➋
         case '<': trackByType( rexp, track, HOOK  ); break;       // ➌
         default :                                                 // ➍
           for( int i = 1; i < rexp->len; i++ )                    // ➎
             switch( rexp->ptr[ i ] ){                             // ➏
             case '(': case '<':
               trackByLen( rexp, track, i, SIMPLE  ); return TRUE; // ➐
             }

           trackByLen( rexp, track, rexp->len, SIMPLE  );          // ➑
         }

         return TRUE;
       }
     #+END_SRC

     Una vez mas, un @c(switch) es el protagonista del show. Como haciamos en la
     version anterior, el tipo de la seccion mas a la izquierda, depende del
     contenido de la primer posicion en la cadena miembro de @c(rexp) ➊.
     Actuamos segun el operador, para @c[(] hacemos un corte @c(GROUP) ➋, para
     @c(<) un corte @c(HOOK) ➌. El resto ➍ caen bajo un corte de tipo
     @c(SIMPLE) ➐➑, solo debemos averiguar la extension de esta seccion, para lo
     cual se realiza un recorrido por la expresion ➎, hasta dar con un operador
     ➏ de interes, de lo contrario la seccion abarca toda la expresion ➑.

     Es particularmente relevante utilizar @c(return TRUE) en ➐, un @c(break)
     saldria del @c(switch) pero no romperia con la ejecucion del ciclo @c(for),
     toma nota, sera relevante mas adelante.

     ✌(ﾟ∀ﾟ)✌ nada mal, un @c(for) + @c(switch) para substituir dos funciones
     @c(trackerPoint) y @c(strchr), encima el codigo paso de tener 138 lineas a
     123, 15 lineas menos en las que podemos implementar todo tipo de alocadas
     funcionalidades...

     Antes de pasar a otra cosa, aqui tenemos la funcion @c(trackByLen) que nos
     sirve para cortar las secciones por longitud (y tipo)

     #+BEGIN_SRC c
       static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
         *track       = *rexp;
         track->type  = type;
         track->len   = len;
         fwrRexp( rexp, len );
       }
     #+END_SRC

     reducir su funcionamiento es sencillo: copiar todo el contenido de @c(rexp)
     a @c(track), modificar el tipo, longitud y recorrer @c(rexp) @m(n)
     posiciones.

     Como siempre verificamos que la prueba optenga el mismo resultado. En la
     siguiente seccion activaremos pruebas que no requieran ver linea a linea lo
     la informacion que sale de motor.

*** match

    ( ︶︿︶) ... ... ... veamos, las secciones anteriores mostraron como
    optener algunos constructores de la regexp, uno a uno de forma consecutiva y
    de izquierda a derecha. Segun el algoritmo debemos comparar la posicion de
    inicio de la cadena con el primer constructor, si hay coincidencia avanzar
    atraves de ambos y repetir esta accion hasta agotar los constructores, la
    cadena o dejar de encontrar coincidencias. De estas tres opciones derivamos
    tres acciones:

    - Si agotamos los constructores, la regexp coincide

    - Si agotamos la cadena, la regexp no coincide

    - Si no hay coincidencia, probamos con otra ruta. Si no hay otra ruta
      iniciamos de nuevo en la siguiente posicion de la cadena


    Necesario es que el motor pueda @"(caminara) atraves de la cadena, es decir,
    avanzar en caso de coincidecia, retroceder en el caso contrario y continuar
    la busqueda en la siguiente posicion de la cadena. Podemos implementar todo
    lo anterior mediante aritmetica de punteros... o crear una estructura que
    almacene la posicion de inicio (un puntero), la posicion actual (el
    recorrido del motor) y la longitud de nuestra cadena:

    #+BEGIN_SRC c
      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      };
    #+END_SRC

    Al Dialogo |⌐■_■|=>

    Sin importar de cuanta recurisividad haga uso el motor, este siempre opera
    de forma secuencial, primero entre rutas y luego entre los demas
    constructores, como pues, ha de gestionarse la optencion de constructores?

    (ﾟヮﾟ)=> realizando comparaciones con el contenido de la cadena. Si el
    constructor de turno no coincide la optecion termina e intentamos con otra
    ruta, si no hay mas rutas la busqueda falla.

    De los tres constructores que podemos optener (alternacion, agrupacion y
    caracteres) cual se puede comparar con la cadena?

    (ﾟヮﾟ)=> Los constructores alternacion y agrupacion, son indicadores para el
    motor sobre el orden de evaluacion, por si mismos no contienen ningun patron
    a localizar en la cadena. La cadena esta compuesta por valores concretos, de
    momento el unico constructor que contiene este tipo de informacion son los
    caracteres o cadenas de caracteres.

    Oh, asi que la comparacion ocurre hasta que optenemos constructores de tipo
    caracter?

    (ﾟヮﾟ)=> Si, la coordinacion ocurre al comparar estos constructores, de
    ello depende continuar con la optecion de constructores y avanzar por la
    cadena o abortar el recorrido por la ruta/expresion

    Al Codigo |⌐■_■|=>

    (Esta ocacion solo mostrare las funciones a modificar, sera tu labor
    realizar los cambios. Comienza por agregar la estructura @c(TEXT) (y una
    instancia global de esta, llamada @c(text)) en la posicion del codigo que
    consideres conveniente, ya el compilador te dira si la ubicacion es correcta
    o no.)

    #+BEGIN_SRC c
      unsigned int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.len     = strlen( re );
        rexp.type    = PATH;
        text.ptr     = txt;            // ➊
        text.len     = strlen( txt );  // ➋
        text.pos     = 0;              // ➌

        return walker( rexp );
      }
    #+END_SRC

    Inicializamos los valores de la instancia global de la estructura
    @c(TEXT). El punto de inicio apunta al inicio de la cadena ➊, la longitud
    abarca toda la cadena ➋ y la posicion inicial de comparacion con el primer
    constructor, es el inicio de la cadena ➌.

    #+BEGIN_SRC c
      static int walker( struct RE rexp ){
        struct RE track;

        printf( "%-20s >>%.*s<<\n", "walker   INIT", rexp.len, rexp.ptr );
        for( const int oPos = text.pos; trackByType( &rexp, &track, PATH ); text.pos = oPos ){ // ➊
          printf( "%-20s >>%.*s<<\n", "walker   PATH", track.len, track.ptr );
          if( trekking( &track ) ) return TRUE;  // ➋
        }

        return FALSE;                            // ➌
      }
    #+END_SRC

    @c(walker) se encarga de recorrer las rutas de la expresion. Cuando una ruta
    coincida debemos informar la coincidiencia regresando @c(TRUE) ➋. Cuando se
    agoten las rutas regresamos @c(FALSE) ➌. Ahora, la busqueda atraves de las
    rutas mueve el punto de comparacion en la cadena, por ello antes de realizar
    ninguna busqueda almacenamos la posicion original, asi, cuando una ruta
    falle, podemos restaurar la posicion de origen para el siguiente recorrido ➊.

    Veamos el recorrido por los constructores de la ruta

    #+BEGIN_SRC c
      static int trekking( struct RE *rexp ){
        struct RE track;

        while( tracker( rexp, &track ) ){
          switch( track.type ){
          case GROUP:
            printf( "%-20s >>%.*s<<\n", "trekking GROUP", track.len, track.ptr );
            if( walker( track ) == FALSE ) return FALSE;    // ➊
            break;
          case HOOK :
            printf( "%-20s >>%.*s<<\n", "trekking HOOK", track.len, track.ptr );
            if( walker( track ) == FALSE ) return FALSE;    // ➋
            break;
          default   :
            printf( "%-20s >>%.*s<<\n", "trekking SIMPLE", track.len, track.ptr );
            if( text.pos < text.len && match( &track ) )    // ➌
              text.pos += track.len;                        // ➍
            else return FALSE;                              // ➎
          }
        }

        return TRUE;
      }
    #+END_SRC

    La ruta es su cojunto genera una coincidencia, solo si se agotan los
    constructores que la conforman. Si uno solo de sus constructores no esta
    presente dentro de la cadena, el recorrido falla ➊➋➎.

    Vamos al caso mas sencillo, el constructor caracter (@c(SIMPLE)) agrupado en
    @c(default).

    Tenemos una evaluacion con dos evaluaciones booleanas ➌, primero, antes de
    realizar la busqueda, la posicion en la cadena tiene que ser menor a su
    longitud, es decir, la cadena no ha llegado al final. Segundo la busqueda
    debe regresar un valor distinto de cero (el numero de caracteres de la
    coincidencia).

    El motor ya coordina el avance por la regexp, coordinar el avance en la
    cadena para la siguiente comparacion, requiere mover la cadena las @m(n)
    posiciones de la coincidencia, en este caso, eso es equivalente a sumar a la
    posicion de la cadena, la longitud del constructor ➍.

    En caso de que la comparacion falle terminamos el recorrido con un @c(return
    FALSE) ➎.

    Realizar la busqueda por las agrupaciones es mas sencillo, basta con una
    consulta a @c(walker) ➊➋, yo lo llamo @e(la magia de la recursividad).

    Pasemos con la funcion que da titulo a esta seccion

    #+BEGIN_SRC c
      static int match( struct RE *rexp ){
        int result = strncmp( text.ptr + text.pos, rexp->ptr, rexp->len ) == 0 ? rexp->len : 0; // ➊
        printf( "match    %-11s rexp[%.*s]\n"
                "         %-11s text[%.*s]\n",
                result ? "OK" : "FAIL", rexp->len, rexp->ptr, "", rexp->len, text.ptr + text.pos );
        return  result; // ➋
      }
    #+END_SRC

    @c(match) devuelve el numero de caracteres que coinciden en la posicion
    actual de la cadena, de 0 (no hay coincidencia) a los @m(n) caracteres que
    conforman el constructor ➊➋. El resto, es informacion para ver lo que
    sucede.

    (｀-´ﾒ) listo! Te preguntaras (o no) @c(text) la instancia de la estructura
    @c(TEXT) debe ser global? la respuesa es no, por dos poderosas razones:

    1. Una variable global es mas simple de manejar

    2. De otra forma, la variable debe "habitar" dentro de la funcion
       @c(regexp3), luego debe ser enviada por todas las funciones (por toda la
       recursividad) hasta llegar al punto de comparacion.


    Es posible que hayas caido en el camino... veamos si la salida de algunas
    pruebas ayudan en tu recuperacion.

    Modifica (copia o pega) lo siguiente en @f(test.c)

    #+BEGIN_SRC c
      int main(){
        if( regexp3( "ruta3", "ruta1|ruta2|ruta3") ) puts( "(\\/)(^-^)(\\/)" );
        else                                         puts( "t(-.-t)" );

        return 0;
      }
    #+END_SRC

    compila y ejecuta (@c(gcc -Wall test.c && ./a.out))

    esta es la salida

    #+BEGIN_EXAMPLE
      walker   INIT        >>ruta1|ruta2|ruta3<<
      walker   PATH        >>ruta1<<
      trekking SIMPLE      >>ruta1<<
      match    FAIL        rexp[ruta1]
                           text[ruta3] ➊
      walker   PATH        >>ruta2<<
      trekking SIMPLE      >>ruta2<<
      match    FAIL        rexp[ruta2]
                           text[ruta3] ➋
      walker   PATH        >>ruta3<<
      trekking SIMPLE      >>ruta3<<
      match    OK          rexp[ruta3]
                           text[ruta3] ➌
      (\/)(^-^)(\/)
    #+END_EXAMPLE

    magnifico, el motor reestablece la posicion de la ruta en cada comparacion
    (en realidad solo se modifica en la ultima prueba)

    Algo mas complejo

    #+BEGIN_SRC c
      int main(){
        if( regexp3( "123gh", "123(ab|cd|ef|gh)") ) puts( "(\\/)(^-^)(\\/)" );
        else                                        puts( "t(-.-t)" );

        return 0;
      }
    #+END_SRC


    este es el resultado (modifique la indentacion para mas claridad):

    #+BEGIN_EXAMPLE
      walker   init        >>123(ab|cd|ef|gh)<<     ┌──▶ walker inicial
      walker   PATH        >>123(ab|cd|ef|gh)<<     └─┬▶ walker primer ruta
      trekking SIMPLE      >>123<<                    ├─┬> primer constructor: caracter
      match    OK       rexp[123]                     │ └──▶ comparacion
                        text[123]                     │
      trekking GROUP           >>ab|cd|ef|gh<<        └─┬▶ segundo constructor: agrupacion
      walker   init            >>ab|cd|ef|gh<<          ├──▶ walker recursivo
      walker   PATH            >>ab<<                   ├─┬▶ walker primer ruta   ➊
      trekking SIMPLE          >>ab<<                   │ └─┬> primer constructor: caracter
      match    FAIL         rexp[ab]                    │   └──▶ comparacion
                            text[gh]                    │
      walker   PATH               >>cd<<                ├─┬▶ walker segunda ruta  ➋
      trekking SIMPLE             >>cd<<                │ └─┬> primer constructor: caracter
      match    FAIL            rexp[cd]                 │   └──▶ comparacion
                               text[gh]                 │
      walker   PATH                  >>ef<<             ├─┬▶ walker tercer ruta   ➌
      trekking SIMPLE                >>ef<<             │ └─┬> primer constructor: caracter
      match    FAIL               rexp[ef]              │   └──▶ comparacion
                                  text[gh]              │
      walker   PATH                     >>gh<<          └─┬▶ walker cuarta ruta   ➍
      trekking SIMPLE                   >>gh<<            └─┬> primer constructor: caracter
      match    OK                    rexp[gh]               └──▶ comparacion
                                     text[gh]
      (\/)(^-^)(\/)
    #+END_EXAMPLE

    De nuevo el resultado es correcto. Por el registro, parece que todo funciona
    correctamente, en especial el recorrido por las rutas ➊➋➌➍.

    Para terminar esta seccion apliquemos una bateria de pruebas mas
    completa. Modifica el contenido de @c(test.c) a esto:

    #+BEGIN_SRC c
      #include <stdio.h>

      #include "regexp3.h"

      int raptorTest(){
        int result = 0;
        int errs   = 0;
        int total  = 0;

      #define NTEST( text, re, n )                            \
        result = regexp3( text, re );                         \
        total++;                                              \
        if( result != n ){                                    \
          printf( "%s:%d Error on N-TEST >%s< >%s<\n",        \
                  __FILE__, __LINE__, text, re );             \
          printf( "results %d - %d expected\n", result, n );  \
          errs++;                                             \
        }

        NTEST( "a", "a", 1 );
        NTEST( "aa", "aa", 1 );
        NTEST( "raptor", "raptor", 1 );
        NTEST( "a", "(a)", 1 );
        NTEST( "a", "<a>", 1 );
        NTEST( "a", "((a))", 1 );
        NTEST( "a", "<<a>>", 1 );
        NTEST( "a", "((((((a))))))", 1 );
        NTEST( "a", "<<<<<<a>>>>>>", 1 );
        NTEST( "a", "b|a", 1 );
        NTEST( "a", "c|b|a", 1 );
        NTEST( "a", "(b|a)", 1 );
        NTEST( "a", "(c|b|a)", 1 );
        NTEST( "a", "(c|b)|a", 1 );
        NTEST( "a", "((<c>|<b>)|a)", 1 );
        NTEST( "raptor", "b|raptor", 1 );
        NTEST( "raptor", "c|b|raptor", 1 );
        NTEST( "raptor", "(b|raptor)", 1 );
        NTEST( "raptor", "(c|raptor)|a", 1 );
        NTEST( "raptor", "((<c>|<raptor>)|a)", 1 );
        NTEST( "ab", "a(b|c)|A(B|C)", 1 );
        NTEST( "ac", "a(b|c)|A(B|C)", 1 );
        NTEST( "AB", "a(b|c)|A(B|C)", 1 );
        NTEST( "AC", "a(b|c)|A(B|C)", 1 );
        NTEST( "ab", "a<b|c>|A<B|C>", 1 );
        NTEST( "ac", "a<b|c>|A<B|C>", 1 );
        NTEST( "AB", "a<b|c>|A<B|C>", 1 );
        NTEST( "AC", "a<b|c>|A<B|C>", 1 );
        NTEST( "ab"    , "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "ac"    , "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "AB"    , "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "AC"    , "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "ab"    , "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "ac"    , "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "AB"    , "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "AC"    , "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "1234ea", "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "1234eb", "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "1234ec", "(a(b|c)|A(B|C))|1234(ea|eb|ec)", 1 );
        NTEST( "1234ea", "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "1234eb", "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "1234ec", "<a<b|c>|A<B|C>>|1234<ea|eb|ec>", 1 );
        NTEST( "abd", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "abe", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "acd", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ace", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ABD", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ABE", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ACD", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "ACE", "a(b|c)(d|e)|A(B|C)(D|E)", 1 );
        NTEST( "raptor", "(c|r)(e|a)(p|q)(t|u)(0|o)(t|r)", 1 );

        printf( "TEST %d *** ERRS %d\n\n", total, errs );
        return !errs;
      }

      int main(){
        if( raptorTest() ) puts( "I am the Raptor" );

        return 0;
      }
    #+END_SRC

    Compila y ejecuta, en mi sistema todas las pruebas fueron correctas.

    La macro @c(NTEST), consiste en comprobar que el numero de coincidencias es
    el esperado, de lo contrario despliega un mensaje de error, con el numero de
    linea, el fichero, la prueba, el resultado optenido y el esperado.

    Ninguna bateria de pruebas es suficiente, siempre pueden presentarse casos
    imprevistos, por ejemplo, como reaciona el motor ante un conjunto o una ruta
    vacia? que deberia hacer cuando la cadena o la regexp son apuntadores
    vacios? despues de una coincidencia deberia consultarse el siguiente
    caracter de la cadena o continuar al final de la coincidencia?

    Las respuestas a estos misterios y mucho mas, en el proximo capitulo!

    - PD ::

      Apartir de la siguiente seccion, eliminare todos los mensajes que se
      producen en @f(regexp3.h), son bastate molestos. Podrian suprimirse
      colocando el codigo dentro de directivas de compilacion condicional...
      pero cosidero que esto solo enturbia la estructura del codigo.

      Una vez te familiarices con el codigo, no necesitaras mas mensajes que
      los que se producen en las pruebas.

*** loops

    El motor ya puede realizar busquedas reales, pero estas se limitan a la
    primer posicion de la cadana.

    En esta seccion, con unas pocas lineas mas, vamos a extender la busqueda por
    toda la cadena, ademas se agregara una nueva caracteristica:
    @e(cuantificadores).

    (´・ω・)っ Al codigo

    #+BEGIN_SRC c
      #include <ctype.h>
      #include <string.h>
      #include <stdlib.h>

      #define TRUE            1
      #define FALSE           0
      #define INF    1073741824 // 2^30

      struct TEXT {
        char *ptr;
        int   pos;
        int   len;
      } static text;

      enum TYPE { PATH, GROUP, HOOK, BACKREF, SET, RANGEAB, META, POINT, SIMPLE };

      struct RE {
        char     *ptr;
        int       len;
        enum TYPE type;
        unsigned int loopsMin, loopsMax;
      };

      static int  walker     ( struct RE  rexp );
      static int  trekking   ( struct RE *rexp );
      static int  looper     ( struct RE *rexp );
      static int  tracker    ( struct RE *rexp, struct RE *track );
      static int  trackByType( struct RE *rexp, struct RE *track, int type );
      static void trackByLen ( struct RE *rexp, struct RE *track, int len, int type );
      static void fwrRexp    ( struct RE *rexp, int len );

      static void getLoops   ( struct RE *rexp, struct RE *track );

      static int  match      ( struct RE *rexp );

      static int  countCharDigits( char *str );

      unsigned int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.len     = strlen( re );
        rexp.type    = PATH;
        text.len     = strlen( txt );

        if( text.len == 0 || rexp.len == 0 ) return 0;

        int result   = 0;
        for( int forward, i = 0, loops = text.len; i < loops; i += forward ){
          forward    = 1;
          text.pos   = 0;
          text.ptr   = txt   + i;
          text.len   = loops - i;

          if( walker( rexp ) ){
            result++;
            if( text.pos > 0 ) forward = text.pos;
          }
        }

        return result;
      }

      static int walker( struct RE rexp ){
        struct RE track;
        for( const int oPos = text.pos; trackByType( &rexp, &track, PATH ); text.pos = oPos )
          if( trekking( &track ) ) return TRUE;

        return FALSE;
      }

      static int trekking( struct RE *rexp ){
        struct RE track;
        while( tracker( rexp, &track ) )
          if( looper( &track ) == FALSE ) return FALSE;

        return TRUE;
      }

      static int looper( struct RE *rexp ){
        int loops = 0;

        switch( rexp->type ){
        case HOOK: case GROUP: case PATH:
          while( loops < rexp->loopsMax && walker( *rexp ) )
            loops++;
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:
          while( loops < rexp->loopsMax && text.pos < text.len && match( rexp ) ){
            text.pos += rexp->len;
            loops++;
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;
      }

      static int trackByType( struct RE *rexp, struct RE *track, int type ){
        if( rexp->len == 0 ) return FALSE;

        *track = *rexp;
        track->type = type;

        for( int cut, i = 0, deep = 0; i < rexp->len; i++ ){
          switch( rexp->ptr[ i ] ){
          case '(': case '<': deep++; break;
          case ')': case '>': deep--; break;
          }

          switch( type ){
          case HOOK    : cut = deep == 0; break;
          case GROUP   : cut = deep == 0; break;
          case PATH    : cut = deep == 0 && rexp->ptr[i] == '|'; break;
          }

          if( cut ){
            track->len  = i;
            fwrRexp( rexp, i + 1 );
            if( type != PATH ) fwrRexp( track, 1 );
            return TRUE;
          }
        }

        fwrRexp( rexp, rexp->len );
        return TRUE;
      }

      static int tracker( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case '(': trackByType( rexp, track, GROUP ); break;
        case '<': trackByType( rexp, track, HOOK  ); break;
        default :
          for( int i = 1; i < rexp->len; i++ )
            switch( rexp->ptr[ i ] ){
            case '(': case '<':
              trackByLen( rexp, track, i, SIMPLE  ); goto getL;
            case '?': case '+': case '*': case '{':
              if( i == 1 ) trackByLen( rexp, track, 1, SIMPLE  );
              else         trackByLen( rexp, track, i - 1, SIMPLE  );
              goto getL;
            }

          trackByLen( rexp, track, rexp->len, SIMPLE  );
        }

       getL:
        getLoops( rexp, track );
        return TRUE;
      }

      static void trackByLen( struct RE *rexp, struct RE *track, int len, int type ){
        *track       = *rexp;
        track->type  = type;
        track->len   = len;
        fwrRexp( rexp, len );
      }


      static void fwrRexp( struct RE *rexp, int len ){
        rexp->ptr += len; rexp->len -= len;
      }

      static void getLoops( struct RE *rexp, struct RE *track ){
        track->loopsMin = 1; track->loopsMax = 1;

        if( rexp->len )
          switch( *rexp->ptr ){
          case '?' : track->loopsMin = 0; track->loopsMax =   1; fwrRexp( rexp, 1 ); return;
          case '+' : track->loopsMin = 1; track->loopsMax = INF; fwrRexp( rexp, 1 ); return;
          case '*' : track->loopsMin = 0; track->loopsMax = INF; fwrRexp( rexp, 1 ); return;
          case '{' : fwrRexp( rexp, 1 );
            track->loopsMin = atoi( rexp->ptr );
            fwrRexp( rexp, countCharDigits( rexp->ptr ) );
            if( *rexp->ptr == ',' ){
              fwrRexp( rexp, 1 );
              if( *rexp->ptr == '}' )
                track->loopsMax = INF;
              else {
                track->loopsMax = atoi( rexp->ptr );
                fwrRexp( rexp, countCharDigits( rexp->ptr  ) );
              }
            } else
              track->loopsMax = track->loopsMin;

            fwrRexp( rexp, 1 );
          }
      }

      static int countCharDigits( char *str ){
        for( int digits = 0; ; digits++ )
          if( isdigit( *str++ ) == 0 ) return digits;
      }

      static int match( struct RE *rexp ){
        return strncmp( text.ptr + text.pos, rexp->ptr, rexp->len ) == 0 ? rexp->len : 0;
      }
    #+END_SRC

    En primer lugar, se elimino el encabezado @c(<stdio.h>) y todas las
    intrucciones @c(printf).

    Un poco mas adelante de declara una nueva constante

    #+BEGIN_SRC c
      #define INF   1073741824 // 2^30
    #+END_SRC

    su aparicion esta relacionada con dos nuevas variables que se agregan a la
    estrucura @c(RE)

    #+BEGIN_SRC c
      unsigned int loopsMin, loopsMax;
    #+END_SRC

    y dos nuevas funciones @c(getLoops) y @c(looper).

    Examinemos @c(getLoops):

    #+BEGIN_SRC c
      static void getLoops( struct RE *rexp, struct RE *track ){
        track->loopsMin = 1; track->loopsMax = 1;               // ➊

        if( rexp->len )
          switch( *rexp->ptr ){
          case '?' : fwrRexp( rexp, 1 ); track->loopsMin = 0; track->loopsMax =   1; return; // ➋
          case '+' : fwrRexp( rexp, 1 ); track->loopsMin = 1; track->loopsMax = INF; return; // ➌
          case '*' : fwrRexp( rexp, 1 ); track->loopsMin = 0; track->loopsMax = INF; return; // ➍
          case '{' : fwrRexp( rexp, 1 );                        // ➎
            track->loopsMin = atoi( rexp->ptr );                // ➏
            fwrRexp( rexp, countCharDigits( rexp->ptr ) );
            if( *rexp->ptr == ',' ){
              fwrRexp( rexp, 1 );
              if( *rexp->ptr == '}' )
                track->loopsMax = INF;                          // ➐
              else {
                track->loopsMax = atoi( rexp->ptr );            // ➑
                fwrRexp( rexp, countCharDigits( rexp->ptr  ) );
              }
            } else track->loopsMax = track->loopsMin;           // ➒

            fwrRexp( rexp, 1 );
          }
      }
    #+END_SRC

    en este documento los @e(cuantificadores) no se consideran un constructor,
    son una caracteristica (siempre presente) de estos.

    Cuando no se especifica ningun cuantificador, el motor debe evaluar el
    constructor una vez ➊. Para el resto de casos

    - @c(?) cero o una vez ➋
    - @c(+) una o mas veces ➌
    - @c(*) cero o mas veces ➍
    - @c({n}) exactamente @m(n) veces ➏➒
    - @c({n,}) al menos  @m(n) veces ➏➐
    - @c({a,b}) al menos @m(a) y no mas de @m(b) veces ➏➑


    ... y asi es como establecemos el numero de repeticiones de un constructor,
    mediate un rango, e aqui la razon de agregar las nuevas variables
    @c(loopsMin) y @c(loopsMax) dentro de la estructura @c(RE).

    Ya que la expresion @e(mas veces) no es una cifra concreta, lo mas sencillo
    es recurrir a un valor lo suficientemente grande como para ser improbable
    (que no imposible) llegar a el, asi se explica la constante @c(INF). El
    valor de @c(INF) es @m(2) elevado a @m(30). Esta cantidad, equivale en el
    peor de los casos, a localizar 1 GiB de caracteres, por ejemplo, si el
    constructor fuese de tipo punto.

    En esencia, luego que @c(tracker) optiene el constructor llama a
    @c(getLoops) para examinar el resto de la exprecion (@c(rexp)) establecer el
    rango de repeticiones y eliminar la @"(paja) en la siguiente iteracion, esa
    es la funcion de las instrucciones @c(fwrRexp). Veamos como ocurre la
    coordinacion @c(tracker)-@c(getLoops):

    #+BEGIN_SRC c
      static int tracker( struct RE *rexp, struct RE *track ){
        if( rexp->len == 0 ) return FALSE;

        switch( *rexp->ptr ){
        case '(': trackByType( rexp, track, GROUP ); break;              // 🅐
        case '<': trackByType( rexp, track, HOOK  ); break;              // 🅑
        default :
          for( int i = 1; i < rexp->len; i++ )
            switch( rexp->ptr[ i ] ){
            case '(': case '<':                                          // 🅒
              trackByLen( rexp, track, i, SIMPLE  ); goto getL;          // 🅓
            case '?': case '+': case '*': case '{':                      // 🅔
              if( i == 1 ) trackByLen( rexp, track, 1, SIMPLE  );        // 🅕
              else         trackByLen( rexp, track, i - 1, SIMPLE  );    // 🅖
              goto getL;                                                 // 🅗
            }

          trackByLen( rexp, track, rexp->len, SIMPLE  );                 // 🅘
        }

       getL:                                                             // 🅙
        getLoops( rexp, track );                                         // 🅚
        return TRUE;
      }
    #+END_SRC

    No hay cambio para los constructores de tipo agrupacion 🅐🅑, termina el @c(switch),
    optenemos el rango 🅙 y regresamos verdadero.

    Distinto es realizar el corte de secciones tipo @c(SIMPLE)

    1. Si encontramos operadores @c[(] o @c(<) 🅒, cortamos la seccion y
       @e(saltamos) a optener el cuantificador 🅙

       ｢(ﾟﾍﾟ) con @c(goto)!? ejeem, un @c(break) romperia el @c(switch) pero el
       bucle segura en ejecucion. Otra solucion seria colocar una @e(bandera) en
       el ciclo pero requiere una comprobacion adicional en cada iteracion, la
       tercer alternativa es separar el caso @c(default) en una una funcion
       adicional y romper el ciclo con @c(return).

       Debemos evitar utilizar @c(goto) a toda costa? en general, siempre hay
       alternativas.

       Todos sus usos son condenables? no, hay casos donde utilarlo es
       razonable, incluso preferible, este supongo es uno de ellos, aunque si
       miras el codigo del repositorio no lo encontraras mas.

       @c(goto) no es el mal, el mal es crear codigo inteligible (por otros
       humanos).

    2. Debemos agregar los signos @c(?), @c(+), @c(*) y @c({) como casos de
       @"(rastreo) 🅔. Bien, por que el @c(if)-@c(else)? respondo a esa pregunta
       con otra pregunta, en la siguiente expresion, a cual caracter afecta el
       cuantificador?

       #+BEGIN_EXAMPLE
         abcd+ef
       #+END_EXAMPLE

       @c(+) no afecta a toda la cadena, solamente al caracter @c(d) asi que el
       corte debe ocurrir un caracter antes del cuantificador 🅖, es decir, la
       region de @c(a) a @c(c). Podemos tratar dicha seccion como si fuese una
       cadena de caracteres, pues todos ellos tiene un cuantificador @c(1)-@c(1)

       En la siguiente iteracion (@c(trekking)), resiviremos

       #+BEGIN_EXAMPLE
         d+ef
       #+END_EXAMPLE

       ahora tenemos el caracter al que afecta el cuantificador, asi que el corte
       tiene una dimencion de un caracter 🅕

       en ambos casos se rompe el bucle con un @c(goto) 🅗🅙, @c(getLoosp) se
       encarga del resto. Si terminamos el ciclo sin ningun corte, el corte
       abarca la longitud de la expresion 🅘


    Antes mencionamos a @c(trekking)

    #+BEGIN_SRC c
      static int trekking( struct RE *rexp ){
        struct RE track;
        while( tracker( rexp, &track ) )                // ➊
          if( looper( &track ) == FALSE ) return FALSE; // ➋

        return TRUE;
      }
    #+END_SRC

    @e(huuu, que recorte!!!). @c(trekking) se encarga de verificar que cada
    constructor ➊ este presente en la cadena, las @m(n) veces que haga falta ➋,
    en caso contrario regresa @c(FALSE).

    Vamos a ver que hace @c(looper)

    #+BEGIN_SRC c
      static int looper( struct RE *rexp ){
        int loops = 0;

        switch( rexp->type ){                                 // ➊
        case HOOK: case GROUP: case PATH:                     // ➋
          while( loops < rexp->loopsMax && walker( *rexp ) )  // ➌
            loops++;
          break;
        case SET: case BACKREF: case META: case RANGEAB: case POINT: case SIMPLE:   // ➍
          while( loops < rexp->loopsMax && text.pos < text.len && match( rexp ) ){  // ➎
            text.pos += rexp->len;                                                  // ➏
            loops++;
          }
        }

        return loops < rexp->loopsMin ? FALSE : TRUE;          // ➐
      }
    #+END_SRC

    en esta funcion debemos evaluar un constructor tantas veces como indique su
    cuantificador, esto se logra enviando la expresion a una funcion segun sea
    el caso ➊ a @c(walker) ➋➌ o a @c(match) ➍➎, un numero no mayor de ocaciones
    de lo que indica el limite superior @c(loopsMax). El bucle termina cuando la
    funcion retorna un valor falso o cuando se alcanza el limite superior (en
    caso los constructores enviados a @c(match), tambien termina si la cadena ha
    llegado a su fin @c(text.pos < text.len)). Luego comprobamos que el numero
    de ciclos sea igual o mayor al limite inferior ➐ y conocemos el resultado.

    El avance, por la cadena se logra sumando la longitud de la expresion a la
    posicion de la cadena ➏. De momento solo el caso @c(SIMPLE) entra en esta
    comparacion, aun asi agrege el resto de casos a modo de anticipo de lo que
    vendra, ademas esto evita una alarma del compilador, que tambien puede
    prevenirse colocando un caso @c(defalut), pero creo que esta forma es mucho
    mas expresiva.

    Necesario es, resaltar que las pruebas @c(walker) o @c(match) pueden fallar
    y aun asi la funcion @c(looper) regresar @c(TRUE) siempre y cuando el indice
    inferior (@c(loopsMin)) sea igual a cero, con un avance por la cadena igual
    a? @e(cero).

    Aqui concluye el bucle por los constructores... Continuamos con el bucle por
    la cadena:

    #+BEGIN_SRC c
      unsigned int regexp3( char *txt, char *re ){
        struct RE    rexp;
        rexp.ptr     = re;
        rexp.type    = PATH;
        rexp.len     = strlen( re );
        text.len     = strlen( txt );

        if( text.len == 0 || rexp.len == 0 ) return 0;    // ➊

        int result   = 0;                                 // ➋
        for( int forward, i = 0, loops = text.len; i < loops; i += forward ){ // ➌
          forward    = 1;                                 // ➍
          text.pos   = 0;                                 // ➎
          text.ptr   = txt   + i;                         // ➏
          text.len   = loops - i;                         // ➐

          if( walker( rexp ) ){                           // ➑
            result++;
            if( text.pos > 0 ) forward = text.pos;        // ➒
          }
        }

        return result;                                    // ➓
      }
    #+END_SRC

    Si queremos conocer cuantas coincidencias hay en la cadena, debemos realizar
    busquedas en todas las posiciones de esta, es decir, el numero de consultas
    depende de la longitud de la cadena (@c(loops = text.len) ➌), a cada nueva
    consulta el inicio y longitud de la cadena se recorre en un caracter ➍➏➐, la
    posicion de inicio siempre es el primer caracter de la nueva cadena ➎.

    Cada coincidencia ➑ incrementa en @m(1) la variable @c(result) ➋, una vez
    termina el bucle se regresa el numero de coincidencias ➓

    Gestionar las busquedas por la cadena requiere una variable adicional ➍.
    Segun el resto de implementaciones regexp, cuando se localiza un patron, la
    siguiente busqueda continua al final de la coincidencia... y resulta que
    podemos conocer la longitud de la coincidencia si vemos la ultima posicion
    de la cadena @c(text.pos), asi que solo hace falta agregar el valor al indice
    @c(i). Entonces, a que se debe la comprobacion ➒?

    otra, pregunta, que genera esta sentecia?

    #+BEGIN_SRC c
      regexp3( "a", "b?" );
    #+END_SRC

    (-᷅_-᷄๑) el retorno del valor 1, con un avance cero?

    (^._.^) exacto, si la expresion fuese:

    #+BEGIN_SRC c
      regexp3( "aaa", "b?" );
    #+END_SRC

    que haria el ciclo, @c(for)?

    (｀_´)ゞ sin la condicion ➒, la suma seria @m(0) y entraria en un bucle
    infinito comprobando la primer posicion de la cadena una y otra ves. Gracias
    a la comparacion, y a la instruccion ➍ se asegura continuar la busqueda en
    la siguiente posicion.

    (ง’ω’)و三 ง’ω’)ڡ≡ c-o-r-r-e-c-t-o.

    Hay otro @"(problema) con los constructores que pueden aparecer cero o mas
    veces, si se comparan con una cadena vacia, tambien regresan verdadero.

    No se cual sea el uso que le des al motor, pero en mi caso si le envio una
    cadena vacia quiero que me regrese falso sin importar la exprecion que le
    envie ➊. Obviamente si se resive una expresion vacia, tampoco hay nada que
    hacer.

    Pasemos a las pruebas!

    Agrega lo siguiente despues de la ultima prueba @c(NTEST) en @f(test.c)

    #+BEGIN_SRC c
      NTEST( "",  "",  0 );
      NTEST( "", "a",  0 );
      NTEST( "a", "",  0 );
      NTEST( "a", "o", 0 );
      NTEST( "a", "a", 1 );
      NTEST( "aaa", "a", 3 );
      NTEST( "a", "aaa", 0 );
      NTEST( "a aaa aaa", "aaa", 2 );
      NTEST( "Raptor Test", "a", 1 );
      NTEST( "Raptor Test", "t", 2 );
      NTEST( "aeiou", "a|e|i|o|u", 5 );
      NTEST( "aeiou", "(a|e|i|o|u)", 5 );
      NTEST( "aeiou", "(a|e)|i|(o|u)", 5 );
      NTEST( "aeiou", "(a|(e))|(i|(o|u))", 5 );
      NTEST( "aa ae ai ao au", "a(a|e|i|o|u)", 5 );
      NTEST( "aa ae ai ao au", "a(1|2|3|4|5)", 0 );
      NTEST( "a1 a2 a3 ao au", "a(1|2|3|4|5)", 3 );
      NTEST( "a1 a2 a3 a4 a5", "a(1|2|3|4|5)", 5 );
      NTEST( "aa ae ai ao au", "a(a|e|i|o|u) ", 4 );
      NTEST( "aa ae Ai ao au", "A(a|e|i|o|u)", 1 );
      NTEST( "aa ae Ai ao au", "(A|a)(a|e|i|o|u)", 5 );
      NTEST( "aae aei Aio aoa auu", "(A|a)(a|e|i|o|u)(a|e|i|o|u)", 5 );

      NTEST( "aa aaaa aaaa", "a", 10 );
      NTEST( "aa aaaa aaaa", "aa", 5 );
      NTEST( "aa aaaa aaaa", "aaa", 2 );
      NTEST( "aa aaaa aaaa", "aaaa", 2 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a", 20 );
      NTEST( "abababababababababababababababababababab", "a"  , 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "(a)", 20 );
      NTEST( "abababababababababababababababababababab", "(a)", 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "<a>", 20 );
      NTEST( "abababababababababababababababababababab", "<a>", 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a+",   1 );
      NTEST( "abababababababababababababababababababab", "a+" , 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a?", 20 );
      NTEST( "abababababababababababababababababababab", "a?" , 40 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a*", 1 );
      NTEST( "abababababababababababababababababababab", "a*" , 40 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1}", 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1,}", 1 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1}", 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{5}", 4 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{5,}", 1 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1,5}", 4 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{5,5}", 4 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{10}", 2 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{10,}", 1 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1,100}", 1 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{001,00100}", 1 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{0001,}", 1 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{021,}", 0 );
      NTEST( "abababababababababababababababababababab", "a{1}" , 20 );
      NTEST( "abababababababababababababababababababab", "a{1,}" , 20 );
      NTEST( "abababababababababababababababababababab", "a{001}" , 20 );
      NTEST( "abababababababababababababababababababab", "a{001,}" , 20 );
      NTEST( "abababababababababababababababababababab", "b{1}" , 20 );
      NTEST( "abababababababababababababababababababab", "b{1,}" , 20 );
      NTEST( "abababababababababababababababababababab", "b{001}" , 20 );
      NTEST( "abababababababababababababababababababab", "b{001,}" , 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{1,1}", 20 );
      NTEST( "abababababababababababababababababababab", "a{1,1}" , 20 );
      NTEST( "abababababababababababababababababababab", "a{001,000001}" , 20 );
      NTEST( "aaaaaaaaaaaaaaaaaaaa", "a{20}", 1 );
      NTEST( "abababababababababababababababababababab", "(a|b){1}" , 40 );
      NTEST( "abababababababababababababababababababab", "(a|b){1,}" , 1 );
      NTEST( "abababababababababababababababababababab", "(a|b){1,1}" , 40 );

      NTEST( "ab accc abbc", "ab+c", 1 );
      NTEST( "ab accc abbc", "a+bc", 0 );
      NTEST( "ab accc aabc", "a+bc", 1 );
      NTEST( "ab abcc abcc", "abc+", 2 );
      NTEST( "ac abbc abcc", "abc+", 1 );
      NTEST( "ab accc abbc", "ab*c", 2 );
      NTEST( "ab accc abbc", "a*bc", 1 );
      NTEST( "bc abcc aabc", "a*bc", 3 );
      NTEST( "ab abcc abcc", "abc*", 3 );
      NTEST( "ac abbc abcc", "abc*", 2 );

      NTEST( "ab accc abbc", "ab{2}c", 1 );
      NTEST( "ab accc abbc", "a{1,}bc", 0 );
      NTEST( "ab accc aabc", "a{1,2}bc", 1 );
      NTEST( "ab abcc abcc", "abc{01,03}", 2 );
      NTEST( "ac abbc abcc", "abc{01,03}", 1 );
      NTEST( "ab accc abbc", "ab{000,}c", 2 );
      NTEST( "ab accc abbc", "a{000}bc", 1 );
      NTEST( "bc abcc aabc", "a{000,5}bc", 3 );
      NTEST( "ab abcc abcc", "abc{0,}", 3 );
      NTEST( "ac abbc abcc", "abc{0,0100}", 2 );

      NTEST( "a", "a?", 1 );
      NTEST( "a", "b?", 1 );
      NTEST( "a", "a+", 1 );
      NTEST( "a", "a*", 1 );
      NTEST( "a", "b*", 1 );
      NTEST( "a", "aa?", 1 );
      NTEST( "a", "ab?", 1 );
      NTEST( "a", "aa+", 0 );
      NTEST( "a", "aa*", 1 );
      NTEST( "a", "ab*", 1 );
      NTEST( "a", "a{1,2}", 1 );
      NTEST( "aaa", "a+", 1 );
      NTEST( "aaa", "a*", 1 );
      NTEST( "aaa", "a+", 1 );
      NTEST( "aaa", "a?", 3 );
      NTEST( "aaab", "a+", 1 );
      NTEST( "aaab", "a*", 2 );
      NTEST( "aaab", "a?", 4 );
      NTEST( "aaab", "a+b", 1 );
      NTEST( "aaab", "a*b", 1 );
      NTEST( "aaab", "a?b", 1 );
      NTEST( "aaab", "a+b?", 1 );
      NTEST( "aaab", "a*b?", 1 );
      NTEST( "aaab", "a?b?", 3 );
      NTEST( "aaab", "a+b+", 1 );
      NTEST( "aaab", "a*b+", 1 );
      NTEST( "aaab", "a?b+", 1 );
      NTEST( "aaab", "a+b*", 1 );
      NTEST( "aaab", "a*b*", 1 );
      NTEST( "aaab", "a?b*", 3 );
      NTEST( "aaabaaa", "a+", 2 );
      NTEST( "aaabaaa", "a*", 3 );
      NTEST( "aaabaaa", "a*", 3 );
      NTEST( "aaabaaa", "a*", 3 );
      NTEST( "a", "(a)?", 1 );
      NTEST( "a", "(b)?", 1 );
      NTEST( "a", "(a)+", 1 );
      NTEST( "a", "(a)*", 1 );
      NTEST( "a", "(b)*", 1 );
      NTEST( "aaa", "(a)+", 1 );
      NTEST( "aaa", "(a)*", 1 );

      NTEST( "abc", "<b>", 1 );
      NTEST( "abc", "a<b>", 1 );
      NTEST( "abc", "<b>c", 1 );
      NTEST( "abc", "a<b>c", 1 );
      NTEST( "abc", "<a|b>", 2 );
      NTEST( "abc", "<a|b|c>", 3 );
      NTEST( "abc", "<(a|b)|c>", 3 );
      NTEST( "aa aaaa aaaa", "<aa>", 5 );
      NTEST( "abc", "a<x>", 0 );
      NTEST( "abc", "<a>x", 0 );
      NTEST( "abc", "<a|b>x", 0 );
      NTEST( "abc", "<<a|b>x|abc>", 1 );
      NTEST( "abc", "<x<a|b>|abc>", 1 );
      NTEST( "abc abc abc", "<a|b|c>", 9 );
      NTEST( "abc abc abc", "<(a|b|c)(a|b|c)(a|b|c)>", 3 );
      NTEST( "abc abc abc", "<(a|b|c)(a|b|c)(a|b|c)> ", 2 );
      NTEST( "abc iecc oeb", "<<(a|e)|(i|o)>e<b|c>|abc>", 3 );

      NTEST( "Raptor Test",     "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
      NTEST( "Raaaaptor TFest", "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
      NTEST( "CaptorTest",      "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
      NTEST( "Cap CaptorTest",  "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
      NTEST( "Rap Captor Fest", "<((C|R)ap C|C|R)(a+p{1}tor) ?((<T|F>+e)(st))>", 1 );
    #+END_SRC

*** set & meta & point
*** mods
*** Catch
*** backreferences
*** Stand Alone Complex
* Regexp3 (UTF-8)
** utf-8
** codigo
** xx.*yy
* Regexp4
** El raptor necesita un mapa
** Lista de instrucciones
** showTable
** interprete
** goodbye cruel regexp
* fuentes

  https://blog.staffannoteberg.com/2013/01/30/regular-expressions-a-brief-history/

  https://en.wikipedia.org/wiki/Regular_expression

  https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular

  https://es.wikipedia.org/wiki/Grep

  https://es.wikipedia.org/wiki/ASCII

  https://es.wikipedia.org/wiki/UTF-8

  https://es.wikipedia.org/wiki/Byte

  https://elbauldelprogramador.com/por-que-un-switch-es-mas-rapido-que-su-homologo-if-then-else/

  Mastering Regular Expressions, 2nd Edition By Jeffrey E. F. Friedl
  https://se.ifmo.ru/~ad/Documentation/Mastering_RegExp/mastregex2-CHP-4-SECT-3.html
